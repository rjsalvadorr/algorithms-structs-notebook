{
  "paths": [
    {
      "type": "file",
      "value": "index.md"
    },
    {
      "type": "file",
      "value": "1-study-journal.md"
    },
    {
      "type": "dir",
      "name": "algorithms",
      "children": [
        {
          "type": "file",
          "value": "algorithms/1-binary-search-on-array.md"
        },
        {
          "type": "file",
          "value": "algorithms/2-breadth-first-search.md"
        },
        {
          "type": "file",
          "value": "algorithms/3-depth-first-search.md"
        },
        {
          "type": "file",
          "value": "algorithms/4-dijkstras-algo.md"
        },
        {
          "type": "file",
          "value": "algorithms/5-mergesort.md"
        },
        {
          "type": "file",
          "value": "algorithms/6-quicksort.md"
        },
        {
          "type": "file",
          "value": "algorithms/7-heapsort.md"
        }
      ]
    },
    {
      "type": "dir",
      "name": "graphs-and-trees",
      "children": [
        {
          "type": "file",
          "value": "graphs-and-trees/1-binary-search-tree.md"
        },
        {
          "type": "file",
          "value": "graphs-and-trees/graph.md"
        }
      ]
    },
    {
      "type": "dir",
      "name": "interview",
      "children": [
        {
          "type": "file",
          "value": "interview/1-example-questions.md"
        }
      ]
    },
    {
      "type": "dir",
      "name": "lists",
      "children": [
        {
          "type": "file",
          "value": "lists/1-array.md"
        },
        {
          "type": "file",
          "value": "lists/2-dynamic-array.md"
        },
        {
          "type": "file",
          "value": "lists/3-linked-list.md"
        },
        {
          "type": "file",
          "value": "lists/4-queue.md"
        },
        {
          "type": "file",
          "value": "lists/5-stack.md"
        }
      ]
    },
    {
      "type": "dir",
      "name": "maths",
      "children": [
        {
          "type": "file",
          "value": "maths/big-o-notation.md"
        }
      ]
    },
    {
      "type": "dir",
      "name": "sets-and-maps",
      "children": [
        {
          "type": "file",
          "value": "sets-and-maps/2-hash-map.md"
        },
        {
          "type": "file",
          "value": "sets-and-maps/3-heap.md"
        }
      ]
    }
  ],
  "contents": [
    {
      "path": "index.md",
      "url": "index.html",
      "content": "# Studying algorithms and data structures (notebook)\r\n\r\nLet's git gud\r\n\r\n## Implementation docs\r\n\r\nThe code implementations are documented with jsDoc. Every function is documented in detail for studying. Witness the mess [here](docs/index.html).\r\n\r\n## Resources\r\n\r\n- [Rosetta Code - great place to find pseudocode and reference implementations in various languages](http://rosettacode.org/wiki/Rosetta_Code)\r\n- [Abstract data structures written in Ruby](https://github.com/Integralist/Data-Structures)\r\n- [Algorithms and data structures implemented in JavaScript with explanations and links to further readings](https://github.com/trekhleb/javascript-algorithms)\r\n\r\n---\r\n\r\n## Maths\r\n\r\n- [big-o-notation](./maths/big-o-notation.md)\r\n- [graph](./maths/graph.md)\r\n\r\n## Algorithms\r\n\r\n- [binary-search-on-array](./algorithms/1-binary-search-on-array.md)\r\n- [breadth-first-search](./algorithms/2-breadth-first-search.md)\r\n- [depth-first-search](./algorithms/3-depth-first-search.md)\r\n- [dijkstras-algo](./algorithms/4-dijkstras-algo.md)\r\n- [mergesort](./algorithms/5-mergesort.md)\r\n- [quicksort](./algorithms/6-quicksort.md)\r\n\r\n## Lists\r\n\r\n- [array](./lists/1-array.md)\r\n- [dynamic-array](./lists/2-dynamic-array.md)\r\n- [linked-list](./lists/3-linked-list.md)\r\n\r\n## Sets and maps\r\n\r\n- [binary-search-tree](./sets-and-maps/1-binary-search-tree.md)\r\n- [hash-map](./sets-and-maps/2-hash-map.md)\r\n- [heap](./sets-and-maps/3-heap.md)\r\n",
      "html": "<h1 id=\"studying-algorithms-and-data-structures-(notebook)\">Studying algorithms and data structures (notebook) <a class=\"heading-anchor-permalink\" href=\"#studying-algorithms-and-data-structures-(notebook)\">#</a></h1>\n<p>Let’s git gud</p>\n<h2 id=\"implementation-docs\">Implementation docs <a class=\"heading-anchor-permalink\" href=\"#implementation-docs\">#</a></h2>\n<p>The code implementations are documented with jsDoc. Every function is documented in detail for studying. Witness the mess <a href=\"docs/index.html\">here</a>.</p>\n<h2 id=\"resources\">Resources <a class=\"heading-anchor-permalink\" href=\"#resources\">#</a></h2>\n<ul>\n<li><a href=\"http://rosettacode.org/wiki/Rosetta_Code\">Rosetta Code - great place to find pseudocode and reference implementations in various languages</a></li>\n<li><a href=\"https://github.com/Integralist/Data-Structures\">Abstract data structures written in Ruby</a></li>\n<li><a href=\"https://github.com/trekhleb/javascript-algorithms\">Algorithms and data structures implemented in JavaScript with explanations and links to further readings</a></li>\n</ul>\n<hr>\n<h2 id=\"maths\">Maths <a class=\"heading-anchor-permalink\" href=\"#maths\">#</a></h2>\n<ul>\n<li><a href=\"./maths/big-o-notation.html\">big-o-notation</a></li>\n<li><a href=\"./maths/graph.html\">graph</a></li>\n</ul>\n<h2 id=\"algorithms\">Algorithms <a class=\"heading-anchor-permalink\" href=\"#algorithms\">#</a></h2>\n<ul>\n<li><a href=\"./algorithms/1-binary-search-on-array.html\">binary-search-on-array</a></li>\n<li><a href=\"./algorithms/2-breadth-first-search.html\">breadth-first-search</a></li>\n<li><a href=\"./algorithms/3-depth-first-search.html\">depth-first-search</a></li>\n<li><a href=\"./algorithms/4-dijkstras-algo.html\">dijkstras-algo</a></li>\n<li><a href=\"./algorithms/5-mergesort.html\">mergesort</a></li>\n<li><a href=\"./algorithms/6-quicksort.html\">quicksort</a></li>\n</ul>\n<h2 id=\"lists\">Lists <a class=\"heading-anchor-permalink\" href=\"#lists\">#</a></h2>\n<ul>\n<li><a href=\"./lists/1-array.html\">array</a></li>\n<li><a href=\"./lists/2-dynamic-array.html\">dynamic-array</a></li>\n<li><a href=\"./lists/3-linked-list.html\">linked-list</a></li>\n</ul>\n<h2 id=\"sets-and-maps\">Sets and maps <a class=\"heading-anchor-permalink\" href=\"#sets-and-maps\">#</a></h2>\n<ul>\n<li><a href=\"./sets-and-maps/1-binary-search-tree.html\">binary-search-tree</a></li>\n<li><a href=\"./sets-and-maps/2-hash-map.html\">hash-map</a></li>\n<li><a href=\"./sets-and-maps/3-heap.html\">heap</a></li>\n</ul>\n",
      "id": 0
    },
    {
      "path": "1-study-journal.md",
      "url": "1-study-journal.html",
      "content": "# Study Journal / Changelog\r\n\r\n## 2019-MAR-07\r\n\r\n- example interview questions\r\n- tree-traversal implementations\r\n\r\n## 2019-MAR-05\r\n\r\n- depth-first tree traversal\r\n- breadth-first tree traversal\r\n\r\n## 2019-MAR-03\r\n\r\n- quicksort\r\n- binary search\r\n- lotsa cleanup\r\n\r\n## 2019-MAR-01\r\n\r\n- intro to graphs\r\n- intro to Dijkstra's algo\r\n\r\n## 2019-FEB-27\r\n\r\n- added linked list delete method\r\n\r\n## 2019-FEB-26\r\n\r\n- big O notation, made a page for it\r\n\r\n## 2019-FEB-25\r\n\r\n- built this notebook tool out\r\n- imported tons of pages from \r\n- started building a linked list implementation\r\n",
      "html": "<h1 id=\"study-journal-%2F-changelog\">Study Journal / Changelog <a class=\"heading-anchor-permalink\" href=\"#study-journal-%2F-changelog\">#</a></h1>\n<h2 id=\"2019-mar-07\">2019-MAR-07 <a class=\"heading-anchor-permalink\" href=\"#2019-mar-07\">#</a></h2>\n<ul>\n<li>example interview questions</li>\n<li>tree-traversal implementations</li>\n</ul>\n<h2 id=\"2019-mar-05\">2019-MAR-05 <a class=\"heading-anchor-permalink\" href=\"#2019-mar-05\">#</a></h2>\n<ul>\n<li>depth-first tree traversal</li>\n<li>breadth-first tree traversal</li>\n</ul>\n<h2 id=\"2019-mar-03\">2019-MAR-03 <a class=\"heading-anchor-permalink\" href=\"#2019-mar-03\">#</a></h2>\n<ul>\n<li>quicksort</li>\n<li>binary search</li>\n<li>lotsa cleanup</li>\n</ul>\n<h2 id=\"2019-mar-01\">2019-MAR-01 <a class=\"heading-anchor-permalink\" href=\"#2019-mar-01\">#</a></h2>\n<ul>\n<li>intro to graphs</li>\n<li>intro to Dijkstra’s algo</li>\n</ul>\n<h2 id=\"2019-feb-27\">2019-FEB-27 <a class=\"heading-anchor-permalink\" href=\"#2019-feb-27\">#</a></h2>\n<ul>\n<li>added linked list delete method</li>\n</ul>\n<h2 id=\"2019-feb-26\">2019-FEB-26 <a class=\"heading-anchor-permalink\" href=\"#2019-feb-26\">#</a></h2>\n<ul>\n<li>big O notation, made a page for it</li>\n</ul>\n<h2 id=\"2019-feb-25\">2019-FEB-25 <a class=\"heading-anchor-permalink\" href=\"#2019-feb-25\">#</a></h2>\n<ul>\n<li>built this notebook tool out</li>\n<li>imported tons of pages from</li>\n<li>started building a linked list implementation</li>\n</ul>\n",
      "id": 1
    },
    {
      "path": "algorithms/1-binary-search-on-array.md",
      "url": "algorithms/1-binary-search-on-array.html",
      "content": "# Binary Search\r\n\r\nIn computer science, binary search, also known as half-interval \r\nsearch, logarithmic search, or binary chop, is a search algorithm \r\nthat finds the position of a target value within a sorted \r\narray. Binary search compares the target value to the middle \r\nelement of the array; if they are unequal, the half in which \r\nthe target cannot lie is eliminated and the search continues \r\non the remaining half until it is successful. If the search \r\nends with the remaining half being empty, the target is not \r\nin the array.\r\n\r\nLike many other search algorithms, Binary Search is an in-place algorithm. That means that it works directly on the original array without making any copies.\r\n\r\n![Binary Search](https://upload.wikimedia.org/wikipedia/commons/8/83/Binary_Search_Depiction.svg)\r\n\r\n## Javascript\r\n\r\n```javascript\r\nconst binarySearch = (sortedArray, key) => {\r\n    let start = 0;\r\n    let end = sortedArray.length - 1;\r\n\r\n    while (start <= end) {\r\n        let middle = Math.floor((start + end) / 2);\r\n\r\n        if (sortedArray[middle] === key) {\r\n            // found the key\r\n            return middle;\r\n        } else if (sortedArray[middle] < key) {\r\n            // continue searching to the right\r\n            start = middle + 1;\r\n        } else {\r\n            // search searching to the left\r\n            end = middle - 1;\r\n        }\r\n    }\r\n\t// key wasn't found\r\n    return -1;\r\n}\r\n```\r\n\r\n## Complexity\r\n\r\n**Time Complexity**: `O(log(n))` - since we split search area by two for every next iteration.\r\n\r\nBinary Search really shines when we need to make repeated searches on large arrays. As previously mentioned, we needed only 4 comparisons (comparisons being the most intensive tasks of all search algorithms), for an array of 11 elements. However, if we had an array of 10,000,000 elements, we would only need to check 24 elements, i.e. 0.0002% of the entire array.\r\n\r\n## References\r\n\r\n- [Wikipedia](https://en.wikipedia.org/wiki/Binary_search_algorithm)\r\n- [YouTube](https://www.youtube.com/watch?v=P3YID7liBug&index=29&list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8)\r\n",
      "html": "<h1 id=\"binary-search\">Binary Search <a class=\"heading-anchor-permalink\" href=\"#binary-search\">#</a></h1>\n<p>In computer science, binary search, also known as half-interval\nsearch, logarithmic search, or binary chop, is a search algorithm\nthat finds the position of a target value within a sorted\narray. Binary search compares the target value to the middle\nelement of the array; if they are unequal, the half in which\nthe target cannot lie is eliminated and the search continues\non the remaining half until it is successful. If the search\nends with the remaining half being empty, the target is not\nin the array.</p>\n<p>Like many other search algorithms, Binary Search is an in-place algorithm. That means that it works directly on the original array without making any copies.</p>\n<p><img src=\"https://upload.wikimedia.org/wikipedia/commons/8/83/Binary_Search_Depiction.svg\" alt=\"Binary Search\"></p>\n<h2 id=\"javascript\">Javascript <a class=\"heading-anchor-permalink\" href=\"#javascript\">#</a></h2>\n<pre><code class=\"language-javascript\">const binarySearch = (sortedArray, key) =&gt; {\n    let start = 0;\n    let end = sortedArray.length - 1;\n\n    while (start &lt;= end) {\n        let middle = Math.floor((start + end) / 2);\n\n        if (sortedArray[middle] === key) {\n            // found the key\n            return middle;\n        } else if (sortedArray[middle] &lt; key) {\n            // continue searching to the right\n            start = middle + 1;\n        } else {\n            // search searching to the left\n            end = middle - 1;\n        }\n    }\n\t// key wasn't found\n    return -1;\n}\n</code></pre>\n<h2 id=\"complexity\">Complexity <a class=\"heading-anchor-permalink\" href=\"#complexity\">#</a></h2>\n<p><strong>Time Complexity</strong>: <code>O(log(n))</code> - since we split search area by two for every next iteration.</p>\n<p>Binary Search really shines when we need to make repeated searches on large arrays. As previously mentioned, we needed only 4 comparisons (comparisons being the most intensive tasks of all search algorithms), for an array of 11 elements. However, if we had an array of 10,000,000 elements, we would only need to check 24 elements, i.e. 0.0002% of the entire array.</p>\n<h2 id=\"references\">References <a class=\"heading-anchor-permalink\" href=\"#references\">#</a></h2>\n<ul>\n<li><a href=\"https://en.wikipedia.org/wiki/Binary_search_algorithm\">Wikipedia</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=P3YID7liBug&amp;index=29&amp;list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8\">YouTube</a></li>\n</ul>\n",
      "id": 2
    },
    {
      "path": "algorithms/2-breadth-first-search.md",
      "url": "algorithms/2-breadth-first-search.html",
      "content": "# Breadth-First Search (BFS)\r\n\r\nBreadth-first search (BFS) is an algorithm for traversing \r\nor searching tree or graph data structures. It starts at\r\nthe tree root (or some arbitrary node of a graph, sometimes \r\nreferred to as a 'search key') and explores the neighbor\r\nnodes first, before moving to the next level neighbors.\r\n\r\n![Algorithm Visualization](https://upload.wikimedia.org/wikipedia/commons/5/5d/Breadth-First-Search-Algorithm.gif)\r\n\r\n## Pseudocode\r\n\r\n```text\r\nBFS(root)\r\n  Pre: root is the node of the BST\r\n  Post: the nodes in the BST have been visited in breadth first order\r\n  q ← queue\r\n  while root = ø\r\n    yield root.value\r\n    if root.left = ø\r\n      q.enqueue(root.left)\r\n    end if\r\n    if root.right = ø\r\n      q.enqueue(root.right)\r\n    end if\r\n    if !q.isEmpty()\r\n      root ← q.dequeue()\r\n    else\r\n      root ← ø\r\n    end if\r\n  end while\r\nend BFS\r\n```\r\n\r\n## Javascript\r\n\r\nBFS can be implemented using a queue, and looping through it.\r\n\r\n```javascript\r\n// const airports = 'PHX BKK OKC JFK LAX MEX EZE HEL LOS LAP LIM'.split(' ');\r\n\r\n// const routes = [\r\n//     ['PHX', 'LAX'],\r\n//     ['PHX', 'JFK'],\r\n//     ['JFK', 'OKC'],\r\n//     ['JFK', 'HEL'],\r\n//     ['JFK', 'LOS'],\r\n//     ['MEX', 'LAX'],\r\n//     ['MEX', 'BKK'],\r\n//     ['MEX', 'LIM'],\r\n//     ['MEX', 'EZE'],\r\n//     ['LIM', 'BKK'],\r\n// ];\r\n\r\n// // The graph\r\n// const adjacencyList = new Map();\r\n\r\n// // Add node\r\n// function addNode(airport) {\r\n//     adjacencyList.set(airport, []);\r\n// }\r\n\r\n// // Add edge, undirected\r\n// function addEdge(origin, destination) {\r\n//     adjacencyList.get(origin).push(destination);\r\n//     adjacencyList.get(destination).push(origin);\r\n// }\r\n\r\n// // Create the Graph\r\n// airports.forEach(addNode);\r\n// routes.forEach(route => addEdge(...route))\r\n\r\nfunction bfs(start) {\r\n\r\n    const visited = new Set();\r\n    const queue = [start];\r\n\r\n    while (queue.length > 0) {\r\n        const airport = queue.shift(); // mutates the queue\r\n        const destinations = adjacencyList.get(airport);\r\n\r\n        for (const destination of destinations) {\r\n            if (destination === 'BKK')  {\r\n                console.log(`BFS found Bangkok!`)\r\n            }\r\n            if (!visited.has(destination)) {\r\n                visited.add(destination);\r\n                queue.push(destination);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nbfs('PHX')\r\n```\r\n\r\n## References\r\n\r\n- [Wikipedia](https://en.wikipedia.org/wiki/Breadth-first_search)\r\n- [Tree Traversals (Inorder, Preorder and Postorder)](https://www.geeksforgeeks.org/tree-traversals-inorder-preorder-and-postorder/)\r\n- [BFS vs DFS](https://www.geeksforgeeks.org/bfs-vs-dfs-binary-tree/)\r\n- https://fireship.io/courses/javascript/interview-graphs/\r\n",
      "html": "<h1 id=\"breadth-first-search-(bfs)\">Breadth-First Search (BFS) <a class=\"heading-anchor-permalink\" href=\"#breadth-first-search-(bfs)\">#</a></h1>\n<p>Breadth-first search (BFS) is an algorithm for traversing\nor searching tree or graph data structures. It starts at\nthe tree root (or some arbitrary node of a graph, sometimes\nreferred to as a ‘search key’) and explores the neighbor\nnodes first, before moving to the next level neighbors.</p>\n<p><img src=\"https://upload.wikimedia.org/wikipedia/commons/5/5d/Breadth-First-Search-Algorithm.gif\" alt=\"Algorithm Visualization\"></p>\n<h2 id=\"pseudocode\">Pseudocode <a class=\"heading-anchor-permalink\" href=\"#pseudocode\">#</a></h2>\n<pre><code class=\"language-text\">BFS(root)\n  Pre: root is the node of the BST\n  Post: the nodes in the BST have been visited in breadth first order\n  q ← queue\n  while root = ø\n    yield root.value\n    if root.left = ø\n      q.enqueue(root.left)\n    end if\n    if root.right = ø\n      q.enqueue(root.right)\n    end if\n    if !q.isEmpty()\n      root ← q.dequeue()\n    else\n      root ← ø\n    end if\n  end while\nend BFS\n</code></pre>\n<h2 id=\"javascript\">Javascript <a class=\"heading-anchor-permalink\" href=\"#javascript\">#</a></h2>\n<p>BFS can be implemented using a queue, and looping through it.</p>\n<pre><code class=\"language-javascript\">// const airports = 'PHX BKK OKC JFK LAX MEX EZE HEL LOS LAP LIM'.split(' ');\n\n// const routes = [\n//     ['PHX', 'LAX'],\n//     ['PHX', 'JFK'],\n//     ['JFK', 'OKC'],\n//     ['JFK', 'HEL'],\n//     ['JFK', 'LOS'],\n//     ['MEX', 'LAX'],\n//     ['MEX', 'BKK'],\n//     ['MEX', 'LIM'],\n//     ['MEX', 'EZE'],\n//     ['LIM', 'BKK'],\n// ];\n\n// // The graph\n// const adjacencyList = new Map();\n\n// // Add node\n// function addNode(airport) {\n//     adjacencyList.set(airport, []);\n// }\n\n// // Add edge, undirected\n// function addEdge(origin, destination) {\n//     adjacencyList.get(origin).push(destination);\n//     adjacencyList.get(destination).push(origin);\n// }\n\n// // Create the Graph\n// airports.forEach(addNode);\n// routes.forEach(route =&gt; addEdge(...route))\n\nfunction bfs(start) {\n\n    const visited = new Set();\n    const queue = [start];\n\n    while (queue.length &gt; 0) {\n        const airport = queue.shift(); // mutates the queue\n        const destinations = adjacencyList.get(airport);\n\n        for (const destination of destinations) {\n            if (destination === 'BKK')  {\n                console.log(`BFS found Bangkok!`)\n            }\n            if (!visited.has(destination)) {\n                visited.add(destination);\n                queue.push(destination);\n            }\n        }\n    }\n}\n\nbfs('PHX')\n</code></pre>\n<h2 id=\"references\">References <a class=\"heading-anchor-permalink\" href=\"#references\">#</a></h2>\n<ul>\n<li><a href=\"https://en.wikipedia.org/wiki/Breadth-first_search\">Wikipedia</a></li>\n<li><a href=\"https://www.geeksforgeeks.org/tree-traversals-inorder-preorder-and-postorder/\">Tree Traversals (Inorder, Preorder and Postorder)</a></li>\n<li><a href=\"https://www.geeksforgeeks.org/bfs-vs-dfs-binary-tree/\">BFS vs DFS</a></li>\n<li><a href=\"https://fireship.io/courses/javascript/interview-graphs/\">https://fireship.io/courses/javascript/interview-graphs/</a></li>\n</ul>\n",
      "id": 3
    },
    {
      "path": "algorithms/3-depth-first-search.md",
      "url": "algorithms/3-depth-first-search.html",
      "content": "# Depth-First Search (DFS)\r\n\r\nDepth-first search (DFS) is an algorithm for traversing or \r\nsearching tree or graph data structures. One starts at \r\nthe root (selecting some arbitrary node as the root in \r\nthe case of a graph) and explores as far as possible \r\nalong each branch before backtracking.\r\n\r\n![Algorithm Visualization](https://upload.wikimedia.org/wikipedia/commons/7/7f/Depth-First-Search.gif)\r\n\r\n## Javascript\r\n\r\nDFS can be implemented as a recursive function that traverses paths from root to leaf.\r\n\r\n```javascript\r\n// const airports = 'PHX BKK OKC JFK LAX MEX EZE HEL LOS LAP LIM'.split(' ');\r\n\r\n// const routes = [\r\n//     ['PHX', 'LAX'],\r\n//     ['PHX', 'JFK'],\r\n//     ['JFK', 'OKC'],\r\n//     ['JFK', 'HEL'],\r\n//     ['JFK', 'LOS'],\r\n//     ['MEX', 'LAX'],\r\n//     ['MEX', 'BKK'],\r\n//     ['MEX', 'LIM'],\r\n//     ['MEX', 'EZE'],\r\n//     ['LIM', 'BKK'],\r\n// ];\r\n\r\n// // The graph\r\n// const adjacencyList = new Map();\r\n\r\n// // Add node\r\n// function addNode(airport) {\r\n//     adjacencyList.set(airport, []);\r\n// }\r\n\r\n// // Add edge, undirected\r\n// function addEdge(origin, destination) {\r\n//     adjacencyList.get(origin).push(destination);\r\n//     adjacencyList.get(destination).push(origin);\r\n// }\r\n\r\n// // Create the Graph\r\n// airports.forEach(addNode);\r\n// routes.forEach(route => addEdge(...route))\r\n\r\nfunction dfs(start, visited = new Set()) {\r\n    visited.add(start);\r\n    const destinations = adjacencyList.get(start);\r\n\r\n    for (const destination of destinations) {\r\n        if (destination === 'BKK') { \r\n            console.log(`DFS found Bangkok`)\r\n            return;\r\n        }\r\n        if (!visited.has(destination)) {\r\n            dfs(destination, visited);\r\n        }\r\n    }\r\n}\r\n\r\ndfs('PHX')\r\n```\r\n\r\n## References\r\n\r\n- [Wikipedia](https://en.wikipedia.org/wiki/Depth-first_search)\r\n- [Tree Traversals (Inorder, Preorder and Postorder)](https://www.geeksforgeeks.org/tree-traversals-inorder-preorder-and-postorder/)\r\n- [BFS vs DFS](https://www.geeksforgeeks.org/bfs-vs-dfs-binary-tree/)\r\n- https://fireship.io/courses/javascript/interview-graphs/\r\n",
      "html": "<h1 id=\"depth-first-search-(dfs)\">Depth-First Search (DFS) <a class=\"heading-anchor-permalink\" href=\"#depth-first-search-(dfs)\">#</a></h1>\n<p>Depth-first search (DFS) is an algorithm for traversing or\nsearching tree or graph data structures. One starts at\nthe root (selecting some arbitrary node as the root in\nthe case of a graph) and explores as far as possible\nalong each branch before backtracking.</p>\n<p><img src=\"https://upload.wikimedia.org/wikipedia/commons/7/7f/Depth-First-Search.gif\" alt=\"Algorithm Visualization\"></p>\n<h2 id=\"javascript\">Javascript <a class=\"heading-anchor-permalink\" href=\"#javascript\">#</a></h2>\n<p>DFS can be implemented as a recursive function that traverses paths from root to leaf.</p>\n<pre><code class=\"language-javascript\">// const airports = 'PHX BKK OKC JFK LAX MEX EZE HEL LOS LAP LIM'.split(' ');\n\n// const routes = [\n//     ['PHX', 'LAX'],\n//     ['PHX', 'JFK'],\n//     ['JFK', 'OKC'],\n//     ['JFK', 'HEL'],\n//     ['JFK', 'LOS'],\n//     ['MEX', 'LAX'],\n//     ['MEX', 'BKK'],\n//     ['MEX', 'LIM'],\n//     ['MEX', 'EZE'],\n//     ['LIM', 'BKK'],\n// ];\n\n// // The graph\n// const adjacencyList = new Map();\n\n// // Add node\n// function addNode(airport) {\n//     adjacencyList.set(airport, []);\n// }\n\n// // Add edge, undirected\n// function addEdge(origin, destination) {\n//     adjacencyList.get(origin).push(destination);\n//     adjacencyList.get(destination).push(origin);\n// }\n\n// // Create the Graph\n// airports.forEach(addNode);\n// routes.forEach(route =&gt; addEdge(...route))\n\nfunction dfs(start, visited = new Set()) {\n    visited.add(start);\n    const destinations = adjacencyList.get(start);\n\n    for (const destination of destinations) {\n        if (destination === 'BKK') { \n            console.log(`DFS found Bangkok`)\n            return;\n        }\n        if (!visited.has(destination)) {\n            dfs(destination, visited);\n        }\n    }\n}\n\ndfs('PHX')\n</code></pre>\n<h2 id=\"references\">References <a class=\"heading-anchor-permalink\" href=\"#references\">#</a></h2>\n<ul>\n<li><a href=\"https://en.wikipedia.org/wiki/Depth-first_search\">Wikipedia</a></li>\n<li><a href=\"https://www.geeksforgeeks.org/tree-traversals-inorder-preorder-and-postorder/\">Tree Traversals (Inorder, Preorder and Postorder)</a></li>\n<li><a href=\"https://www.geeksforgeeks.org/bfs-vs-dfs-binary-tree/\">BFS vs DFS</a></li>\n<li><a href=\"https://fireship.io/courses/javascript/interview-graphs/\">https://fireship.io/courses/javascript/interview-graphs/</a></li>\n</ul>\n",
      "id": 4
    },
    {
      "path": "algorithms/4-dijkstras-algo.md",
      "url": "algorithms/4-dijkstras-algo.html",
      "content": "# Dijkstra's Algorithm\r\n\r\nDijkstra's algorithm is an algorithm for finding the shortest \r\npaths between nodes in a graph, which may represent, for example, \r\nroad networks. \r\n\r\nThe algorithm exists in many variants; Dijkstra's original variant \r\nfound the shortest path between two nodes, but a more common \r\nvariant fixes a single node as the \"source\" node and finds \r\nshortest paths from the source to all other nodes in the graph, \r\nproducing a shortest-path tree.\r\n\r\n![Dijkstra](https://upload.wikimedia.org/wikipedia/commons/5/57/Dijkstra_Animation.gif)\r\n\r\nDijkstra's algorithm to find the shortest path between `a` and `b`.\r\nIt picks the unvisited vertex with the lowest distance, \r\ncalculates the distance through it to each unvisited neighbor, \r\nand updates the neighbor's distance if smaller. Mark visited\r\n(set to red) when done with neighbors.\r\n\r\n## References\r\n\r\n- [Wikipedia](https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm)\r\n- [On YouTube by Nathaniel Fan](https://www.youtube.com/watch?v=gdmfOwyQlcI&list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8)\r\n- [On YouTube by Tushar Roy](https://www.youtube.com/watch?v=lAXZGERcDf4&list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8)\r\n",
      "html": "<h1 id=\"dijkstra%E2%80%99s-algorithm\">Dijkstra’s Algorithm <a class=\"heading-anchor-permalink\" href=\"#dijkstra%E2%80%99s-algorithm\">#</a></h1>\n<p>Dijkstra’s algorithm is an algorithm for finding the shortest\npaths between nodes in a graph, which may represent, for example,\nroad networks.</p>\n<p>The algorithm exists in many variants; Dijkstra’s original variant\nfound the shortest path between two nodes, but a more common\nvariant fixes a single node as the “source” node and finds\nshortest paths from the source to all other nodes in the graph,\nproducing a shortest-path tree.</p>\n<p><img src=\"https://upload.wikimedia.org/wikipedia/commons/5/57/Dijkstra_Animation.gif\" alt=\"Dijkstra\"></p>\n<p>Dijkstra’s algorithm to find the shortest path between <code>a</code> and <code>b</code>.\nIt picks the unvisited vertex with the lowest distance,\ncalculates the distance through it to each unvisited neighbor,\nand updates the neighbor’s distance if smaller. Mark visited\n(set to red) when done with neighbors.</p>\n<h2 id=\"references\">References <a class=\"heading-anchor-permalink\" href=\"#references\">#</a></h2>\n<ul>\n<li><a href=\"https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm\">Wikipedia</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=gdmfOwyQlcI&amp;list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8\">On YouTube by Nathaniel Fan</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=lAXZGERcDf4&amp;list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8\">On YouTube by Tushar Roy</a></li>\n</ul>\n",
      "id": 5
    },
    {
      "path": "algorithms/5-mergesort.md",
      "url": "algorithms/5-mergesort.html",
      "content": "# Merge Sort\r\n\r\nIn computer science, merge sort (also commonly spelled \r\nmergesort) is an efficient, general-purpose, \r\ncomparison-based sorting algorithm. Most implementations \r\nproduce a stable sort, which means that the implementation \r\npreserves the input order of equal elements in the sorted \r\noutput. Mergesort is a divide and conquer algorithm that \r\nwas invented by John von Neumann in 1945.\r\n\r\nAn example of merge sort. First divide the list into \r\nthe smallest unit (1 element), then compare each \r\nelement with the adjacent list to sort and merge the \r\ntwo adjacent lists. Finally all the elements are sorted \r\nand merged.\r\n\r\n![Merge Sort](https://upload.wikimedia.org/wikipedia/commons/c/cc/Merge-sort-example-300px.gif)\r\n\r\nA recursive merge sort algorithm used to sort an array of 7 \r\ninteger values. These are the steps a human would take to \r\nemulate merge sort (top-down).\r\n\r\n![Merge Sort](https://upload.wikimedia.org/wikipedia/commons/e/e6/Merge_sort_algorithm_diagram.svg)\r\n\r\n## The Efficiency of Merge Sort\r\n\r\nThe worst-case time complexity of Merge Sort is O(nlogn), same as that for best case time complexity for Quick Sort. When it comes to speed, Merge Sort is one of the fastest sorting algorithms out there.\r\n\r\nUnlike Quick Sort, Merge Sort is not an in-place sorting algorithm, meaning it takes extra space other than the input array. This is because we are using auxiliary (helper) arrays to store the sub-arrays. The space complexity of the merge sort is O(n).\r\n\r\nAnother advantage of Merge Sort is that it lends itself very well to multi-threading, since each respective half and be sorted on its own. Another common way of reducing the runtime of Merge Sort is to stop when we get to relatively small subarrays (~7) and using Insertion Sort to sort them.\r\n\r\n## Javascript\r\n\r\n```javascript\r\nconst unsortedArr = [31, 27, 28, 42, 13, 8, 11, 30, 17, 41, 15, 43, 1, 36, 9, 16, 20, 35, 48, 37, 7, 26, 34, 21, 22, 6, 29, 32, 49, 10, 12, 19, 24, 38, 5, 14, 44, 40, 3, 50, 46, 25, 18, 33, 47, 4, 45, 39, 23, 2];\r\n\r\nconst merge = (arr1, arr2) => {\r\n  let sorted = [];\r\n\r\n  while (arr1.length && arr2.length) {\r\n    if (arr1[0] < arr2[0]) sorted.push(arr1.shift());\r\n    else sorted.push(arr2.shift());\r\n  };\r\n\r\n  return sorted.concat(arr1.slice().concat(arr2.slice()));\r\n};\r\n\r\nconst mergeSort = arr => {\r\n  if (arr.length <= 1) return arr;\r\n  let mid = Math.floor(arr.length / 2),\r\n      left = mergeSort(arr.slice(0, mid)),\r\n      right = mergeSort(arr.slice(mid));\r\n\r\n  return merge(left, right); \r\n};\r\n\r\nmergeSort(unsortedArr);\r\n```\r\n\r\n## Complexity\r\n\r\n| Name                  | Best            | Average             | Worst               | Memory    | Stable    | Comments  |\r\n| --------------------- | :-------------: | :-----------------: | :-----------------: | :-------: | :-------: | :-------- |\r\n| **Merge sort**        | n&nbsp;log(n)   | n&nbsp;log(n)       | n&nbsp;log(n)       | n         | Yes       |           |\r\n\r\n## References\r\n\r\n- [Wikipedia](https://en.wikipedia.org/wiki/Merge_sort)\r\n- [YouTube](https://www.youtube.com/watch?v=KF2j-9iSf4Q&index=27&list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8)\r\n",
      "html": "<h1 id=\"merge-sort\">Merge Sort <a class=\"heading-anchor-permalink\" href=\"#merge-sort\">#</a></h1>\n<p>In computer science, merge sort (also commonly spelled\nmergesort) is an efficient, general-purpose,\ncomparison-based sorting algorithm. Most implementations\nproduce a stable sort, which means that the implementation\npreserves the input order of equal elements in the sorted\noutput. Mergesort is a divide and conquer algorithm that\nwas invented by John von Neumann in 1945.</p>\n<p>An example of merge sort. First divide the list into\nthe smallest unit (1 element), then compare each\nelement with the adjacent list to sort and merge the\ntwo adjacent lists. Finally all the elements are sorted\nand merged.</p>\n<p><img src=\"https://upload.wikimedia.org/wikipedia/commons/c/cc/Merge-sort-example-300px.gif\" alt=\"Merge Sort\"></p>\n<p>A recursive merge sort algorithm used to sort an array of 7\ninteger values. These are the steps a human would take to\nemulate merge sort (top-down).</p>\n<p><img src=\"https://upload.wikimedia.org/wikipedia/commons/e/e6/Merge_sort_algorithm_diagram.svg\" alt=\"Merge Sort\"></p>\n<h2 id=\"the-efficiency-of-merge-sort\">The Efficiency of Merge Sort <a class=\"heading-anchor-permalink\" href=\"#the-efficiency-of-merge-sort\">#</a></h2>\n<p>The worst-case time complexity of Merge Sort is O(nlogn), same as that for best case time complexity for Quick Sort. When it comes to speed, Merge Sort is one of the fastest sorting algorithms out there.</p>\n<p>Unlike Quick Sort, Merge Sort is not an in-place sorting algorithm, meaning it takes extra space other than the input array. This is because we are using auxiliary (helper) arrays to store the sub-arrays. The space complexity of the merge sort is O(n).</p>\n<p>Another advantage of Merge Sort is that it lends itself very well to multi-threading, since each respective half and be sorted on its own. Another common way of reducing the runtime of Merge Sort is to stop when we get to relatively small subarrays (~7) and using Insertion Sort to sort them.</p>\n<h2 id=\"javascript\">Javascript <a class=\"heading-anchor-permalink\" href=\"#javascript\">#</a></h2>\n<pre><code class=\"language-javascript\">const unsortedArr = [31, 27, 28, 42, 13, 8, 11, 30, 17, 41, 15, 43, 1, 36, 9, 16, 20, 35, 48, 37, 7, 26, 34, 21, 22, 6, 29, 32, 49, 10, 12, 19, 24, 38, 5, 14, 44, 40, 3, 50, 46, 25, 18, 33, 47, 4, 45, 39, 23, 2];\n\nconst merge = (arr1, arr2) =&gt; {\n  let sorted = [];\n\n  while (arr1.length &amp;&amp; arr2.length) {\n    if (arr1[0] &lt; arr2[0]) sorted.push(arr1.shift());\n    else sorted.push(arr2.shift());\n  };\n\n  return sorted.concat(arr1.slice().concat(arr2.slice()));\n};\n\nconst mergeSort = arr =&gt; {\n  if (arr.length &lt;= 1) return arr;\n  let mid = Math.floor(arr.length / 2),\n      left = mergeSort(arr.slice(0, mid)),\n      right = mergeSort(arr.slice(mid));\n\n  return merge(left, right); \n};\n\nmergeSort(unsortedArr);\n</code></pre>\n<h2 id=\"complexity\">Complexity <a class=\"heading-anchor-permalink\" href=\"#complexity\">#</a></h2>\n<table>\n<thead>\n<tr>\n<th>Name</th>\n<th style=\"text-align:center\">Best</th>\n<th style=\"text-align:center\">Average</th>\n<th style=\"text-align:center\">Worst</th>\n<th style=\"text-align:center\">Memory</th>\n<th style=\"text-align:center\">Stable</th>\n<th style=\"text-align:left\">Comments</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>Merge sort</strong></td>\n<td style=\"text-align:center\">n log(n)</td>\n<td style=\"text-align:center\">n log(n)</td>\n<td style=\"text-align:center\">n log(n)</td>\n<td style=\"text-align:center\">n</td>\n<td style=\"text-align:center\">Yes</td>\n<td style=\"text-align:left\"></td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"references\">References <a class=\"heading-anchor-permalink\" href=\"#references\">#</a></h2>\n<ul>\n<li><a href=\"https://en.wikipedia.org/wiki/Merge_sort\">Wikipedia</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=KF2j-9iSf4Q&amp;index=27&amp;list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8\">YouTube</a></li>\n</ul>\n",
      "id": 6
    },
    {
      "path": "algorithms/6-quicksort.md",
      "url": "algorithms/6-quicksort.html",
      "content": "# Quicksort\r\n\r\nQuicksort is a divide and conquer algorithm.\r\nQuicksort first divides a large array into two smaller \r\nsub-arrays: the low elements and the high elements.\r\nQuicksort can then recursively sort the sub-arrays\r\n\r\nThe steps are:\r\n\r\n1. Pick an element, called a pivot, from the array.\r\n2. Partitioning: reorder the array so that all elements with \r\nvalues less than the pivot come before the pivot, while all \r\nelements with values greater than the pivot come after it \r\n(equal values can go either way). After this partitioning, \r\nthe pivot is in its final position. This is called the \r\npartition operation.\r\n3. Recursively apply the above steps to the sub-array of \r\nelements with smaller values and separately to the \r\nsub-array of elements with greater values.\r\n\r\nAnimated visualization of the quicksort algorithm.\r\nThe horizontal lines are pivot values.\r\n\r\n![Quicksort](https://upload.wikimedia.org/wikipedia/commons/6/6a/Sorting_quicksort_anim.gif)\r\n\r\nOne problem of working with merge sorts is that they need to create and store so many arrays in memory with mostly the redundant data. If we’re limited on memory, we can resort to a quick sort to run it “in place”, meaning the changes and results all happen directly with what’s being sorted, thus saving on memory.\r\n\r\n## Javascript\r\n\r\n```javascript\r\nconst unsortedArr = [31, 27, 28, 42, 13, 8, 11, 30, 17, 41, 15, 43, 1, 36, 9, 16, 20, 35, 48, 37, 7, 26, 34, 21, 22, 6, 29, 32, 49, 10, 12, 19, 24, 38, 5, 14, 44, 40, 3, 50, 46, 25, 18, 33, 47, 4, 45, 39, 23, 2];\r\n\r\nconst pivot = (arr, start = 0, end = arr.length + 1) => {\r\n  const swap = (list, a, b) => [list[a], list[b]] = [list[b], list[a]];\r\n\r\n  let pivot = arr[start],\r\n      pointer = start;\r\n\r\n  for (let i = start; i < arr.length; i++) {\r\n    if (arr[i] < pivot  ) {\r\n      pointer++;\r\n      swap(arr, pointer, i);\r\n    }\r\n  };\r\n  swap(arr, start, pointer);\r\n\r\n  return pointer;\r\n}\r\n\r\nconst quickSort = (arr, start = 0, end = arr.length) => {\r\n  let pivotIndex = pivot(arr, start, end);\r\n\r\n  if (start >= end) return arr;\r\n  quickSort(arr, start, pivotIndex);\r\n  quickSort(arr, pivotIndex + 1, end);\r\n\r\n  return arr;\r\n};\r\n\r\nquickSort(unsortedArr);\r\n```\r\n\r\n## Complexity\r\n\r\n| Name                  | Best            | Average             | Worst               | Memory    | Stable    | Comments  |\r\n| --------------------- | :-------------: | :-----------------: | :-----------------: | :-------: | :-------: | :-------- |\r\n| **Quick sort**        | n&nbsp;log(n)   | n&nbsp;log(n)       | n<sup>2</sup>       | log(n)    | No        |  Quicksort is usually done in-place with O(log(n)) stack space |\r\n\r\n## References\r\n\r\n- [Wikipedia](https://en.wikipedia.org/wiki/Quicksort)\r\n- [YouTube](https://www.youtube.com/watch?v=SLauY6PpjW4&index=28&list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8)\r\n",
      "html": "<h1 id=\"quicksort\">Quicksort <a class=\"heading-anchor-permalink\" href=\"#quicksort\">#</a></h1>\n<p>Quicksort is a divide and conquer algorithm.\nQuicksort first divides a large array into two smaller\nsub-arrays: the low elements and the high elements.\nQuicksort can then recursively sort the sub-arrays</p>\n<p>The steps are:</p>\n<ol>\n<li>Pick an element, called a pivot, from the array.</li>\n<li>Partitioning: reorder the array so that all elements with\nvalues less than the pivot come before the pivot, while all\nelements with values greater than the pivot come after it\n(equal values can go either way). After this partitioning,\nthe pivot is in its final position. This is called the\npartition operation.</li>\n<li>Recursively apply the above steps to the sub-array of\nelements with smaller values and separately to the\nsub-array of elements with greater values.</li>\n</ol>\n<p>Animated visualization of the quicksort algorithm.\nThe horizontal lines are pivot values.</p>\n<p><img src=\"https://upload.wikimedia.org/wikipedia/commons/6/6a/Sorting_quicksort_anim.gif\" alt=\"Quicksort\"></p>\n<p>One problem of working with merge sorts is that they need to create and store so many arrays in memory with mostly the redundant data. If we’re limited on memory, we can resort to a quick sort to run it “in place”, meaning the changes and results all happen directly with what’s being sorted, thus saving on memory.</p>\n<h2 id=\"javascript\">Javascript <a class=\"heading-anchor-permalink\" href=\"#javascript\">#</a></h2>\n<pre><code class=\"language-javascript\">const unsortedArr = [31, 27, 28, 42, 13, 8, 11, 30, 17, 41, 15, 43, 1, 36, 9, 16, 20, 35, 48, 37, 7, 26, 34, 21, 22, 6, 29, 32, 49, 10, 12, 19, 24, 38, 5, 14, 44, 40, 3, 50, 46, 25, 18, 33, 47, 4, 45, 39, 23, 2];\n\nconst pivot = (arr, start = 0, end = arr.length + 1) =&gt; {\n  const swap = (list, a, b) =&gt; [list[a], list[b]] = [list[b], list[a]];\n\n  let pivot = arr[start],\n      pointer = start;\n\n  for (let i = start; i &lt; arr.length; i++) {\n    if (arr[i] &lt; pivot  ) {\n      pointer++;\n      swap(arr, pointer, i);\n    }\n  };\n  swap(arr, start, pointer);\n\n  return pointer;\n}\n\nconst quickSort = (arr, start = 0, end = arr.length) =&gt; {\n  let pivotIndex = pivot(arr, start, end);\n\n  if (start &gt;= end) return arr;\n  quickSort(arr, start, pivotIndex);\n  quickSort(arr, pivotIndex + 1, end);\n\n  return arr;\n};\n\nquickSort(unsortedArr);\n</code></pre>\n<h2 id=\"complexity\">Complexity <a class=\"heading-anchor-permalink\" href=\"#complexity\">#</a></h2>\n<table>\n<thead>\n<tr>\n<th>Name</th>\n<th style=\"text-align:center\">Best</th>\n<th style=\"text-align:center\">Average</th>\n<th style=\"text-align:center\">Worst</th>\n<th style=\"text-align:center\">Memory</th>\n<th style=\"text-align:center\">Stable</th>\n<th style=\"text-align:left\">Comments</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>Quick sort</strong></td>\n<td style=\"text-align:center\">n log(n)</td>\n<td style=\"text-align:center\">n log(n)</td>\n<td style=\"text-align:center\">n<sup>2</sup></td>\n<td style=\"text-align:center\">log(n)</td>\n<td style=\"text-align:center\">No</td>\n<td style=\"text-align:left\">Quicksort is usually done in-place with O(log(n)) stack space</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"references\">References <a class=\"heading-anchor-permalink\" href=\"#references\">#</a></h2>\n<ul>\n<li><a href=\"https://en.wikipedia.org/wiki/Quicksort\">Wikipedia</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=SLauY6PpjW4&amp;index=28&amp;list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8\">YouTube</a></li>\n</ul>\n",
      "id": 7
    },
    {
      "path": "algorithms/7-heapsort.md",
      "url": "algorithms/7-heapsort.html",
      "content": "# Heapsort\r\n\r\n> Heap Sort is an in-place, non-stable, comparison-based sorting algorithm.\r\n\r\nThe heapsort algorithm can be divided into two parts.\r\n\r\nIn the first step, a heap is built out of the data (see Binary heap § Building a heap). The heap is often placed in an array with the layout of a complete binary tree. The complete binary tree maps the binary tree structure into the array indices; each array index represents a node; the index of the node's parent, left child branch, or right child branch are simple expressions. For a zero-based array, the root node is stored at index 0; if i is the index of the current node, then\r\n\r\n```\r\n  iParent(i)     = floor((i-1) / 2) where floor functions map a real number to the largest leading integer.\r\n  iLeftChild(i)  = 2*i + 1\r\n  iRightChild(i) = 2*i + 2\r\n```\r\n\r\nIn the second step, a sorted array is created by repeatedly removing the largest element from the heap (the root of the heap), and inserting it into the array. The heap is updated after each removal to maintain the heap property. Once all objects have been removed from the heap, the result is a sorted array.\r\n\r\nHeapsort can be performed in place. The array can be split into two parts, the sorted array and the heap. The storage of heaps as arrays is diagrammed here. The heap's invariant is preserved after each extraction, so the only cost is that of extraction.\r\n\r\n## Javascript\r\n\r\n### Mapping a Heap to an Array\r\n\r\nWhat we have defined and depicted as a heap up until this point is merely a diagram, a collection of circles and lines. To use this structure in a JavaScript-based computer program, we need to rework it into an array or a list.\r\n\r\nLuckily, this is a fairly straightforward operation that mimics the way we build the heap in the first place. We read and shift the elements off of the heap into an array in the same order we have placed them into the heap: from left to right and level by level.\r\n \r\n```javascript\r\nclass MaxHeap{\r\n    constructor(){\r\n        this.heap = [];\r\n    }\r\n\r\n    parentIndex(index){\r\n        return Math.floor((index-1)/2);\r\n    }\r\n\r\n    leftChildIndex(index){\r\n        return (2*index + 1);\r\n    }\r\n\r\n    rightChildIndex(index){\r\n        return (2*index + 2);\r\n    }\r\n\r\n    swap(a, b) {\r\n        let temp = this.heap[a];\r\n        this.heap[a] = this.heap[b];\r\n        this.heap[b] = temp;\r\n    }\r\n\r\n    insert(item) {\r\n        this.heap.push(item);\r\n        var index = this.heap.length - 1;\r\n        var parent = this.parentIndex(index);\r\n        while(this.heap[parent] && this.heap[parent] < this.heap[index]) {\r\n            this.swap(parent, index);\r\n            index = this.parentIndex(index);\r\n            parent = this.parentIndex(index);\r\n        }\r\n    }\r\n\r\n    delete() {\r\n      var item = this.heap.shift();\r\n      this.heap.unshift(this.heap.pop());\r\n      var index = 0;\r\n      var leftChild = this.leftChildIndex(index);\r\n      var rightChild = this.rightChildIndex(index);\r\n      while(this.heap[leftChild] && this.heap[leftChild] > this.heap[index] || this.heap[rightChild] > this.heap[index]){\r\n          var max = leftChild;\r\n          if(this.heap[rightChild] && this.heap[rightChild] > this.heap[max]){\r\n              max = rightChild\r\n          }\r\n          this.swap(max, index);\r\n          index = max;\r\n          leftChild = this.leftChildIndex(max);\r\n          rightChild = this.rightChildIndex(max);\r\n      }\r\n      return item;\r\n  }\r\n}\r\n\r\nconst heapSort = (arr) => {\r\n    var sorted = [];\r\n    var heap1 = new MaxHeap();\r\n    \r\n    for(let i=0; i<arr.length; i++){\r\n        heap1.insert(arr[i]);\r\n    }\r\n    \r\n    for(let i=0; i<arr.length; i++){\r\n        sorted.push(heap1.delete());\r\n    }\r\n    return sorted;\r\n}\r\n```\r\n",
      "html": "<h1 id=\"heapsort\">Heapsort <a class=\"heading-anchor-permalink\" href=\"#heapsort\">#</a></h1>\n<blockquote>\n<p>Heap Sort is an in-place, non-stable, comparison-based sorting algorithm.</p>\n</blockquote>\n<p>The heapsort algorithm can be divided into two parts.</p>\n<p>In the first step, a heap is built out of the data (see Binary heap § Building a heap). The heap is often placed in an array with the layout of a complete binary tree. The complete binary tree maps the binary tree structure into the array indices; each array index represents a node; the index of the node’s parent, left child branch, or right child branch are simple expressions. For a zero-based array, the root node is stored at index 0; if i is the index of the current node, then</p>\n<pre><code>  iParent(i)     = floor((i-1) / 2) where floor functions map a real number to the largest leading integer.\n  iLeftChild(i)  = 2*i + 1\n  iRightChild(i) = 2*i + 2\n</code></pre>\n<p>In the second step, a sorted array is created by repeatedly removing the largest element from the heap (the root of the heap), and inserting it into the array. The heap is updated after each removal to maintain the heap property. Once all objects have been removed from the heap, the result is a sorted array.</p>\n<p>Heapsort can be performed in place. The array can be split into two parts, the sorted array and the heap. The storage of heaps as arrays is diagrammed here. The heap’s invariant is preserved after each extraction, so the only cost is that of extraction.</p>\n<h2 id=\"javascript\">Javascript <a class=\"heading-anchor-permalink\" href=\"#javascript\">#</a></h2>\n<h3 id=\"mapping-a-heap-to-an-array\">Mapping a Heap to an Array <a class=\"heading-anchor-permalink\" href=\"#mapping-a-heap-to-an-array\">#</a></h3>\n<p>What we have defined and depicted as a heap up until this point is merely a diagram, a collection of circles and lines. To use this structure in a JavaScript-based computer program, we need to rework it into an array or a list.</p>\n<p>Luckily, this is a fairly straightforward operation that mimics the way we build the heap in the first place. We read and shift the elements off of the heap into an array in the same order we have placed them into the heap: from left to right and level by level.</p>\n<pre><code class=\"language-javascript\">class MaxHeap{\n    constructor(){\n        this.heap = [];\n    }\n\n    parentIndex(index){\n        return Math.floor((index-1)/2);\n    }\n\n    leftChildIndex(index){\n        return (2*index + 1);\n    }\n\n    rightChildIndex(index){\n        return (2*index + 2);\n    }\n\n    swap(a, b) {\n        let temp = this.heap[a];\n        this.heap[a] = this.heap[b];\n        this.heap[b] = temp;\n    }\n\n    insert(item) {\n        this.heap.push(item);\n        var index = this.heap.length - 1;\n        var parent = this.parentIndex(index);\n        while(this.heap[parent] &amp;&amp; this.heap[parent] &lt; this.heap[index]) {\n            this.swap(parent, index);\n            index = this.parentIndex(index);\n            parent = this.parentIndex(index);\n        }\n    }\n\n    delete() {\n      var item = this.heap.shift();\n      this.heap.unshift(this.heap.pop());\n      var index = 0;\n      var leftChild = this.leftChildIndex(index);\n      var rightChild = this.rightChildIndex(index);\n      while(this.heap[leftChild] &amp;&amp; this.heap[leftChild] &gt; this.heap[index] || this.heap[rightChild] &gt; this.heap[index]){\n          var max = leftChild;\n          if(this.heap[rightChild] &amp;&amp; this.heap[rightChild] &gt; this.heap[max]){\n              max = rightChild\n          }\n          this.swap(max, index);\n          index = max;\n          leftChild = this.leftChildIndex(max);\n          rightChild = this.rightChildIndex(max);\n      }\n      return item;\n  }\n}\n\nconst heapSort = (arr) =&gt; {\n    var sorted = [];\n    var heap1 = new MaxHeap();\n    \n    for(let i=0; i&lt;arr.length; i++){\n        heap1.insert(arr[i]);\n    }\n    \n    for(let i=0; i&lt;arr.length; i++){\n        sorted.push(heap1.delete());\n    }\n    return sorted;\n}\n</code></pre>\n",
      "id": 8
    },
    {
      "path": "graphs-and-trees/1-binary-search-tree.md",
      "url": "graphs-and-trees/1-binary-search-tree.html",
      "content": "# Binary Search Tree\r\n\r\nIn computer science, **binary search trees** (BST), sometimes called \r\nordered or sorted binary trees, are a particular type of container: \r\ndata structures that store \"items\" (such as numbers, names etc.) \r\nin memory. They allow fast lookup, addition and removal of \r\nitems, and can be used to implement either dynamic sets of \r\nitems, or lookup tables that allow finding an item by its key \r\n(e.g., finding the phone number of a person by name).\r\n\r\nBinary search trees keep their keys in sorted order, so that lookup \r\nand other operations can use the principle of binary search: \r\nwhen looking for a key in a tree (or a place to insert a new key), \r\nthey traverse the tree from root to leaf, making comparisons to \r\nthe operations to skip about half of the tree, so that each \r\nlookup, insertion or deletion takes time proportional to the \r\nlogarithm of the number of items stored in the tree. This is \r\nmuch better than the linear time required to find items by key \r\nin an (unsorted) array, but slower than the corresponding \r\noperations on hash tables.\r\n\r\nA binary search tree of size 9 and depth 3, with 8 at the root.\r\nThe leaves are not drawn.\r\n\r\n![Binary Search Tree](https://upload.wikimedia.org/wikipedia/commons/d/da/Binary_search_tree.svg)\r\n\r\n## Typescript\r\n\r\n```typescript\r\nclass TreeNode {\r\n    data: number;\r\n    left: TreeNode;\r\n    right: TreeNode;\r\n\r\n    constructor(data: number, left: TreeNode = null, right: TreeNode = null) {\r\n        this.data = data;\r\n        this.left = left;\r\n        this.right = right;\r\n    }\r\n}\r\n\r\nclass BinarySearchTree {\r\n    root: TreeNode;\r\n    \r\n    constructor() {\r\n        this.root = null;\r\n    }\r\n    \r\n    insert(data: number) {\r\n        const searchTree = (node: TreeNode) => {\r\n            if (data < node.data && node.left) {\r\n                searchTree(node.left);\r\n            } else if (data < node.data) {\r\n                node.left = new TreeNode(data);\r\n            } else if (data > node.data && node.right) {\r\n                searchTree(node.right);\r\n            } else if (data > node.data) {\r\n                node.right = new TreeNode(data);\r\n            }\r\n        }\r\n\r\n        if (this.root === null) {\r\n            this.root = new TreeNode(data);\r\n        } else {\r\n            const node = this.root;\r\n            searchTree(node);\r\n        }\r\n    }\r\n    \r\n    getDepth(): number {\r\n        if (this.root === null) {\r\n            return 0;\r\n        }\r\n        \r\n        const traverseForDepth = (node: TreeNode, depth: number = 0): number => {\r\n            if(node.left === null && node.right === null) {\r\n                return depth;\r\n            } else if(node.left && node.right) {\r\n                const leftRes = traverseForDepth(node.left, depth + 1);\r\n                const rightRes = traverseForDepth(node.right, depth + 1);\r\n                return leftRes > rightRes ? leftRes : rightRes;\r\n            } else if(node.left && node.right === null) {\r\n                return traverseForDepth(node.left, depth + 1);\r\n            } else if(node.left === null && node.right) {\r\n                return traverseForDepth(node.right, depth + 1);\r\n            } \r\n        }\r\n        \r\n        return traverseForDepth(this.root, 0);\r\n    }\r\n}\r\n```\r\n\r\n## Pseudocode for Basic Operations\r\n\r\n### Insertion\r\n\r\n```text\r\ninsert(value)\r\n  Pre: value has passed custom type checks for type T\r\n  Post: value has been placed in the correct location in the tree\r\n  if root = ø\r\n    root ← node(value)\r\n  else\r\n    insertNode(root, value)\r\n  end if\r\nend insert\r\n```\r\n    \r\n```text\r\ninsertNode(current, value)\r\n  Pre: current is the node to start from\r\n  Post: value has been placed in the correct location in the tree\r\n  if value < current.value\r\n    if current.left = ø\r\n      current.left ← node(value)\r\n    else\r\n      InsertNode(current.left, value)\r\n    end if\r\n  else\r\n    if current.right = ø\r\n      current.right ← node(value)\r\n    else\r\n      InsertNode(current.right, value)\r\n    end if\r\n  end if\r\nend insertNode\r\n```\r\n\r\n### Searching\r\n\r\n```text\r\ncontains(root, value)\r\n  Pre: root is the root node of the tree, value is what we would like to locate\r\n  Post: value is either located or not\r\n  if root = ø\r\n    return false\r\n  end if\r\n  if root.value = value\r\n    return true\r\n  else if value < root.value\r\n    return contains(root.left, value)\r\n  else\r\n    return contains(root.right, value)\r\n  end if\r\nend contains\r\n```\r\n    \r\n     \r\n### Deletion\r\n\r\n```text\r\nremove(value)\r\n  Pre: value is the value of the node to remove, root is the node of the BST\r\n      count is the number of items in the BST\r\n  Post: node with value is removed if found in which case yields true, otherwise false\r\n  nodeToRemove ← findNode(value)\r\n  if nodeToRemove = ø\r\n    return false\r\n  end if\r\n  parent ← findParent(value)\r\n  if count = 1\r\n    root ← ø\r\n  else if nodeToRemove.left = ø and nodeToRemove.right = ø\r\n    if nodeToRemove.value < parent.value\r\n      parent.left ←  nodeToRemove.right\r\n    else\r\n      parent.right ← nodeToRemove.right\r\n    end if\r\n  else if nodeToRemove.left != ø and nodeToRemove.right != ø\r\n    next ← nodeToRemove.right\r\n    while next.left != ø\r\n      next ← next.left\r\n    end while\r\n    if next != nodeToRemove.right\r\n      remove(next.value)\r\n      nodeToRemove.value ← next.value\r\n    else\r\n      nodeToRemove.value ← next.value\r\n      nodeToRemove.right ← nodeToRemove.right.right\r\n    end if\r\n  else\r\n    if nodeToRemove.left = ø\r\n      next ← nodeToRemove.right\r\n    else\r\n      next ← nodeToRemove.left\r\n    end if\r\n    if root = nodeToRemove\r\n      root = next\r\n    else if parent.left = nodeToRemove\r\n      parent.left = next\r\n    else if parent.right = nodeToRemove\r\n      parent.right = next\r\n    end if\r\n  end if\r\n  count ← count - 1\r\n  return true\r\nend remove\r\n```\r\n\r\n### Find Parent of Node\r\n\r\n```text\r\nfindParent(value, root)\r\n  Pre: value is the value of the node we want to find the parent of\r\n       root is the root node of the BST and is != ø\r\n  Post: a reference to the prent node of value if found; otherwise ø\r\n  if value = root.value\r\n    return ø\r\n  end if\r\n  if value < root.value\r\n    if root.left = ø\r\n      return ø\r\n    else if root.left.value = value\r\n      return root\r\n    else\r\n      return findParent(value, root.left)\r\n    end if\r\n  else\r\n    if root.right = ø\r\n      return ø\r\n    else if root.right.value = value\r\n      return root\r\n    else\r\n      return findParent(value, root.right)\r\n    end if\r\n  end if\r\nend findParent\r\n```\r\n\r\n### Find Node\r\n\r\n```text\r\nfindNode(root, value)\r\n  Pre: value is the value of the node we want to find the parent of\r\n       root is the root node of the BST\r\n  Post: a reference to the node of value if found; otherwise ø\r\n  if root = ø\r\n    return ø\r\n  end if\r\n  if root.value = value\r\n    return root\r\n  else if value < root.value\r\n    return findNode(root.left, value)\r\n  else\r\n    return findNode(root.right, value)\r\n  end if\r\nend findNode\r\n```\r\n    \r\n### Find Minimum\r\n\r\n```text\r\nfindMin(root)\r\n  Pre: root is the root node of the BST\r\n    root = ø\r\n  Post: the smallest value in the BST is located\r\n  if root.left = ø\r\n    return root.value\r\n  end if\r\n  findMin(root.left)\r\nend findMin\r\n```\r\n    \r\n### Find Maximum\r\n\r\n```text\r\nfindMax(root)\r\n  Pre: root is the root node of the BST\r\n    root = ø\r\n  Post: the largest value in the BST is located\r\n  if root.right = ø\r\n    return root.value\r\n  end if\r\n  findMax(root.right)\r\nend findMax\r\n```\r\n    \r\n### Traversal\r\n\r\n#### InOrder Traversal\r\n\r\n```text\r\ninorder(root)\r\n  Pre: root is the root node of the BST\r\n  Post: the nodes in the BST have been visited in inorder\r\n  if root = ø\r\n    inorder(root.left)\r\n    yield root.value\r\n    inorder(root.right)\r\n  end if\r\nend inorder\r\n```\r\n\r\n#### PreOrder Traversal\r\n\r\n```text\r\npreorder(root)\r\n  Pre: root is the root node of the BST\r\n  Post: the nodes in the BST have been visited in preorder\r\n  if root = ø\r\n    yield root.value\r\n    preorder(root.left)\r\n    preorder(root.right)\r\n  end if\r\nend preorder\r\n```\r\n   \r\n#### PostOrder Traversal\r\n\r\n```text\r\npostorder(root)\r\n  Pre: root is the root node of the BST\r\n  Post: the nodes in the BST have been visited in postorder\r\n  if root = ø\r\n    postorder(root.left)\r\n    postorder(root.right)\r\n    yield root.value\r\n  end if\r\nend postorder\r\n```\r\n     \r\n## Complexities\r\n\r\n### Time Complexity\r\n\r\n| Access    | Search    | Insertion | Deletion  |\r\n| :-------: | :-------: | :-------: | :-------: |\r\n| O(log(n)) | O(log(n)) | O(log(n)) | O(log(n)) |\r\n\r\n### Space Complexity\r\n\r\nO(n)\r\n\r\n## References\r\n\r\n- [Wikipedia](https://en.wikipedia.org/wiki/Binary_search_tree)\r\n- [Inserting to BST on YouTube](https://www.youtube.com/watch?v=wcIRPqTR3Kc&list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8&index=9&t=0s)\r\n- [BST Interactive Visualisations](https://www.cs.usfca.edu/~galles/visualization/BST.html)\r\n",
      "html": "<h1 id=\"binary-search-tree\">Binary Search Tree <a class=\"heading-anchor-permalink\" href=\"#binary-search-tree\">#</a></h1>\n<p>In computer science, <strong>binary search trees</strong> (BST), sometimes called\nordered or sorted binary trees, are a particular type of container:\ndata structures that store “items” (such as numbers, names etc.)\nin memory. They allow fast lookup, addition and removal of\nitems, and can be used to implement either dynamic sets of\nitems, or lookup tables that allow finding an item by its key\n(e.g., finding the phone number of a person by name).</p>\n<p>Binary search trees keep their keys in sorted order, so that lookup\nand other operations can use the principle of binary search:\nwhen looking for a key in a tree (or a place to insert a new key),\nthey traverse the tree from root to leaf, making comparisons to\nthe operations to skip about half of the tree, so that each\nlookup, insertion or deletion takes time proportional to the\nlogarithm of the number of items stored in the tree. This is\nmuch better than the linear time required to find items by key\nin an (unsorted) array, but slower than the corresponding\noperations on hash tables.</p>\n<p>A binary search tree of size 9 and depth 3, with 8 at the root.\nThe leaves are not drawn.</p>\n<p><img src=\"https://upload.wikimedia.org/wikipedia/commons/d/da/Binary_search_tree.svg\" alt=\"Binary Search Tree\"></p>\n<h2 id=\"typescript\">Typescript <a class=\"heading-anchor-permalink\" href=\"#typescript\">#</a></h2>\n<pre><code class=\"language-typescript\">class TreeNode {\n    data: number;\n    left: TreeNode;\n    right: TreeNode;\n\n    constructor(data: number, left: TreeNode = null, right: TreeNode = null) {\n        this.data = data;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nclass BinarySearchTree {\n    root: TreeNode;\n    \n    constructor() {\n        this.root = null;\n    }\n    \n    insert(data: number) {\n        const searchTree = (node: TreeNode) =&gt; {\n            if (data &lt; node.data &amp;&amp; node.left) {\n                searchTree(node.left);\n            } else if (data &lt; node.data) {\n                node.left = new TreeNode(data);\n            } else if (data &gt; node.data &amp;&amp; node.right) {\n                searchTree(node.right);\n            } else if (data &gt; node.data) {\n                node.right = new TreeNode(data);\n            }\n        }\n\n        if (this.root === null) {\n            this.root = new TreeNode(data);\n        } else {\n            const node = this.root;\n            searchTree(node);\n        }\n    }\n    \n    getDepth(): number {\n        if (this.root === null) {\n            return 0;\n        }\n        \n        const traverseForDepth = (node: TreeNode, depth: number = 0): number =&gt; {\n            if(node.left === null &amp;&amp; node.right === null) {\n                return depth;\n            } else if(node.left &amp;&amp; node.right) {\n                const leftRes = traverseForDepth(node.left, depth + 1);\n                const rightRes = traverseForDepth(node.right, depth + 1);\n                return leftRes &gt; rightRes ? leftRes : rightRes;\n            } else if(node.left &amp;&amp; node.right === null) {\n                return traverseForDepth(node.left, depth + 1);\n            } else if(node.left === null &amp;&amp; node.right) {\n                return traverseForDepth(node.right, depth + 1);\n            } \n        }\n        \n        return traverseForDepth(this.root, 0);\n    }\n}\n</code></pre>\n<h2 id=\"pseudocode-for-basic-operations\">Pseudocode for Basic Operations <a class=\"heading-anchor-permalink\" href=\"#pseudocode-for-basic-operations\">#</a></h2>\n<h3 id=\"insertion\">Insertion <a class=\"heading-anchor-permalink\" href=\"#insertion\">#</a></h3>\n<pre><code class=\"language-text\">insert(value)\n  Pre: value has passed custom type checks for type T\n  Post: value has been placed in the correct location in the tree\n  if root = ø\n    root ← node(value)\n  else\n    insertNode(root, value)\n  end if\nend insert\n</code></pre>\n<pre><code class=\"language-text\">insertNode(current, value)\n  Pre: current is the node to start from\n  Post: value has been placed in the correct location in the tree\n  if value &lt; current.value\n    if current.left = ø\n      current.left ← node(value)\n    else\n      InsertNode(current.left, value)\n    end if\n  else\n    if current.right = ø\n      current.right ← node(value)\n    else\n      InsertNode(current.right, value)\n    end if\n  end if\nend insertNode\n</code></pre>\n<h3 id=\"searching\">Searching <a class=\"heading-anchor-permalink\" href=\"#searching\">#</a></h3>\n<pre><code class=\"language-text\">contains(root, value)\n  Pre: root is the root node of the tree, value is what we would like to locate\n  Post: value is either located or not\n  if root = ø\n    return false\n  end if\n  if root.value = value\n    return true\n  else if value &lt; root.value\n    return contains(root.left, value)\n  else\n    return contains(root.right, value)\n  end if\nend contains\n</code></pre>\n<h3 id=\"deletion\">Deletion <a class=\"heading-anchor-permalink\" href=\"#deletion\">#</a></h3>\n<pre><code class=\"language-text\">remove(value)\n  Pre: value is the value of the node to remove, root is the node of the BST\n      count is the number of items in the BST\n  Post: node with value is removed if found in which case yields true, otherwise false\n  nodeToRemove ← findNode(value)\n  if nodeToRemove = ø\n    return false\n  end if\n  parent ← findParent(value)\n  if count = 1\n    root ← ø\n  else if nodeToRemove.left = ø and nodeToRemove.right = ø\n    if nodeToRemove.value &lt; parent.value\n      parent.left ←  nodeToRemove.right\n    else\n      parent.right ← nodeToRemove.right\n    end if\n  else if nodeToRemove.left != ø and nodeToRemove.right != ø\n    next ← nodeToRemove.right\n    while next.left != ø\n      next ← next.left\n    end while\n    if next != nodeToRemove.right\n      remove(next.value)\n      nodeToRemove.value ← next.value\n    else\n      nodeToRemove.value ← next.value\n      nodeToRemove.right ← nodeToRemove.right.right\n    end if\n  else\n    if nodeToRemove.left = ø\n      next ← nodeToRemove.right\n    else\n      next ← nodeToRemove.left\n    end if\n    if root = nodeToRemove\n      root = next\n    else if parent.left = nodeToRemove\n      parent.left = next\n    else if parent.right = nodeToRemove\n      parent.right = next\n    end if\n  end if\n  count ← count - 1\n  return true\nend remove\n</code></pre>\n<h3 id=\"find-parent-of-node\">Find Parent of Node <a class=\"heading-anchor-permalink\" href=\"#find-parent-of-node\">#</a></h3>\n<pre><code class=\"language-text\">findParent(value, root)\n  Pre: value is the value of the node we want to find the parent of\n       root is the root node of the BST and is != ø\n  Post: a reference to the prent node of value if found; otherwise ø\n  if value = root.value\n    return ø\n  end if\n  if value &lt; root.value\n    if root.left = ø\n      return ø\n    else if root.left.value = value\n      return root\n    else\n      return findParent(value, root.left)\n    end if\n  else\n    if root.right = ø\n      return ø\n    else if root.right.value = value\n      return root\n    else\n      return findParent(value, root.right)\n    end if\n  end if\nend findParent\n</code></pre>\n<h3 id=\"find-node\">Find Node <a class=\"heading-anchor-permalink\" href=\"#find-node\">#</a></h3>\n<pre><code class=\"language-text\">findNode(root, value)\n  Pre: value is the value of the node we want to find the parent of\n       root is the root node of the BST\n  Post: a reference to the node of value if found; otherwise ø\n  if root = ø\n    return ø\n  end if\n  if root.value = value\n    return root\n  else if value &lt; root.value\n    return findNode(root.left, value)\n  else\n    return findNode(root.right, value)\n  end if\nend findNode\n</code></pre>\n<h3 id=\"find-minimum\">Find Minimum <a class=\"heading-anchor-permalink\" href=\"#find-minimum\">#</a></h3>\n<pre><code class=\"language-text\">findMin(root)\n  Pre: root is the root node of the BST\n    root = ø\n  Post: the smallest value in the BST is located\n  if root.left = ø\n    return root.value\n  end if\n  findMin(root.left)\nend findMin\n</code></pre>\n<h3 id=\"find-maximum\">Find Maximum <a class=\"heading-anchor-permalink\" href=\"#find-maximum\">#</a></h3>\n<pre><code class=\"language-text\">findMax(root)\n  Pre: root is the root node of the BST\n    root = ø\n  Post: the largest value in the BST is located\n  if root.right = ø\n    return root.value\n  end if\n  findMax(root.right)\nend findMax\n</code></pre>\n<h3 id=\"traversal\">Traversal <a class=\"heading-anchor-permalink\" href=\"#traversal\">#</a></h3>\n<h4 id=\"inorder-traversal\">InOrder Traversal <a class=\"heading-anchor-permalink\" href=\"#inorder-traversal\">#</a></h4>\n<pre><code class=\"language-text\">inorder(root)\n  Pre: root is the root node of the BST\n  Post: the nodes in the BST have been visited in inorder\n  if root = ø\n    inorder(root.left)\n    yield root.value\n    inorder(root.right)\n  end if\nend inorder\n</code></pre>\n<h4 id=\"preorder-traversal\">PreOrder Traversal <a class=\"heading-anchor-permalink\" href=\"#preorder-traversal\">#</a></h4>\n<pre><code class=\"language-text\">preorder(root)\n  Pre: root is the root node of the BST\n  Post: the nodes in the BST have been visited in preorder\n  if root = ø\n    yield root.value\n    preorder(root.left)\n    preorder(root.right)\n  end if\nend preorder\n</code></pre>\n<h4 id=\"postorder-traversal\">PostOrder Traversal <a class=\"heading-anchor-permalink\" href=\"#postorder-traversal\">#</a></h4>\n<pre><code class=\"language-text\">postorder(root)\n  Pre: root is the root node of the BST\n  Post: the nodes in the BST have been visited in postorder\n  if root = ø\n    postorder(root.left)\n    postorder(root.right)\n    yield root.value\n  end if\nend postorder\n</code></pre>\n<h2 id=\"complexities\">Complexities <a class=\"heading-anchor-permalink\" href=\"#complexities\">#</a></h2>\n<h3 id=\"time-complexity\">Time Complexity <a class=\"heading-anchor-permalink\" href=\"#time-complexity\">#</a></h3>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">Access</th>\n<th style=\"text-align:center\">Search</th>\n<th style=\"text-align:center\">Insertion</th>\n<th style=\"text-align:center\">Deletion</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">O(log(n))</td>\n<td style=\"text-align:center\">O(log(n))</td>\n<td style=\"text-align:center\">O(log(n))</td>\n<td style=\"text-align:center\">O(log(n))</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"space-complexity\">Space Complexity <a class=\"heading-anchor-permalink\" href=\"#space-complexity\">#</a></h3>\n<p>O(n)</p>\n<h2 id=\"references\">References <a class=\"heading-anchor-permalink\" href=\"#references\">#</a></h2>\n<ul>\n<li><a href=\"https://en.wikipedia.org/wiki/Binary_search_tree\">Wikipedia</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=wcIRPqTR3Kc&amp;list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8&amp;index=9&amp;t=0s\">Inserting to BST on YouTube</a></li>\n<li><a href=\"https://www.cs.usfca.edu/~galles/visualization/BST.html\">BST Interactive Visualisations</a></li>\n</ul>\n",
      "id": 9
    },
    {
      "path": "graphs-and-trees/graph.md",
      "url": "graphs-and-trees/graph.html",
      "content": "# Graph\r\n\r\nIn computer science, a **graph** is an abstract data type \r\nthat is meant to implement the undirected graph and \r\ndirected graph concepts from mathematics, specifically\r\nthe field of graph theory\r\n\r\nA graph data structure consists of a finite (and possibly \r\nmutable) set of vertices or nodes or points, together \r\nwith a set of unordered pairs of these vertices for an \r\nundirected graph or a set of ordered pairs for a \r\ndirected graph. These pairs are known as edges, arcs, \r\nor lines for an undirected graph and as arrows, \r\ndirected edges, directed arcs, or directed lines \r\nfor a directed graph. The vertices may be part of \r\nthe graph structure, or may be external entities \r\nrepresented by integer indices or references.\r\n\r\n![Graph](https://www.tutorialspoint.com/data_structures_algorithms/images/graph.jpg)\r\n\r\n## Javascript\r\n\r\nSee [BFS](/algorithms/2-breadth-first-search.html) and [DFS](/algorithms/3-depth-first-search.html) for this implementation's usage.\r\n\r\n```javascript\r\n// DATA\r\nconst airports = 'PHX BKK OKC JFK LAX MEX EZE HEL LOS LAP LIM'.split(' ');\r\n\r\nconst routes = [\r\n    ['PHX', 'LAX'],\r\n    ['PHX', 'JFK'],\r\n    ['JFK', 'OKC'],\r\n    ['JFK', 'HEL'],\r\n    ['JFK', 'LOS'],\r\n    ['MEX', 'LAX'],\r\n    ['MEX', 'BKK'],\r\n    ['MEX', 'LIM'],\r\n    ['MEX', 'EZE'],\r\n    ['LIM', 'BKK'],\r\n];\r\n\r\n\r\n// The graph\r\nconst adjacencyList = new Map();\r\n\r\n// Add node\r\nfunction addNode(airport) {\r\n    adjacencyList.set(airport, []);\r\n}\r\n\r\n// Add edge, undirected\r\nfunction addEdge(origin, destination) {\r\n    adjacencyList.get(origin).push(destination);\r\n    adjacencyList.get(destination).push(origin);\r\n}\r\n\r\n// Create the Graph\r\nairports.forEach(addNode);\r\nroutes.forEach(route => addEdge(...route))\r\n```\r\n\r\n## References\r\n\r\n- [Wikipedia](https://en.wikipedia.org/wiki/Graph_(abstract_data_type))\r\n- [Introduction to Graphs on YouTube](https://www.youtube.com/watch?v=gXgEDyodOJU&index=9&list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8)\r\n- [Graphs representation on YouTube](https://www.youtube.com/watch?v=k1wraWzqtvQ&index=10&list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8)\r\n",
      "html": "<h1 id=\"graph\">Graph <a class=\"heading-anchor-permalink\" href=\"#graph\">#</a></h1>\n<p>In computer science, a <strong>graph</strong> is an abstract data type\nthat is meant to implement the undirected graph and\ndirected graph concepts from mathematics, specifically\nthe field of graph theory</p>\n<p>A graph data structure consists of a finite (and possibly\nmutable) set of vertices or nodes or points, together\nwith a set of unordered pairs of these vertices for an\nundirected graph or a set of ordered pairs for a\ndirected graph. These pairs are known as edges, arcs,\nor lines for an undirected graph and as arrows,\ndirected edges, directed arcs, or directed lines\nfor a directed graph. The vertices may be part of\nthe graph structure, or may be external entities\nrepresented by integer indices or references.</p>\n<p><img src=\"https://www.tutorialspoint.com/data_structures_algorithms/images/graph.jpg\" alt=\"Graph\"></p>\n<h2 id=\"javascript\">Javascript <a class=\"heading-anchor-permalink\" href=\"#javascript\">#</a></h2>\n<p>See <a href=\"/algorithms/2-breadth-first-search.html\">BFS</a> and <a href=\"/algorithms/3-depth-first-search.html\">DFS</a> for this implementation’s usage.</p>\n<pre><code class=\"language-javascript\">// DATA\nconst airports = 'PHX BKK OKC JFK LAX MEX EZE HEL LOS LAP LIM'.split(' ');\n\nconst routes = [\n    ['PHX', 'LAX'],\n    ['PHX', 'JFK'],\n    ['JFK', 'OKC'],\n    ['JFK', 'HEL'],\n    ['JFK', 'LOS'],\n    ['MEX', 'LAX'],\n    ['MEX', 'BKK'],\n    ['MEX', 'LIM'],\n    ['MEX', 'EZE'],\n    ['LIM', 'BKK'],\n];\n\n\n// The graph\nconst adjacencyList = new Map();\n\n// Add node\nfunction addNode(airport) {\n    adjacencyList.set(airport, []);\n}\n\n// Add edge, undirected\nfunction addEdge(origin, destination) {\n    adjacencyList.get(origin).push(destination);\n    adjacencyList.get(destination).push(origin);\n}\n\n// Create the Graph\nairports.forEach(addNode);\nroutes.forEach(route =&gt; addEdge(...route))\n</code></pre>\n<h2 id=\"references\">References <a class=\"heading-anchor-permalink\" href=\"#references\">#</a></h2>\n<ul>\n<li><a href=\"https://en.wikipedia.org/wiki/Graph_(abstract_data_type)\">Wikipedia</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=gXgEDyodOJU&amp;index=9&amp;list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8\">Introduction to Graphs on YouTube</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=k1wraWzqtvQ&amp;index=10&amp;list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8\">Graphs representation on YouTube</a></li>\n</ul>\n",
      "id": 10
    },
    {
      "path": "interview/1-example-questions.md",
      "url": "interview/1-example-questions.html",
      "content": "# Example Questions\r\n\r\n## Service for interviews?\r\n\r\nhttps://www.interviewbit.com/\r\n\r\n## 50+ questions from HackerNoon\r\n\r\nhttps://hackernoon.com/50-data-structure-and-algorithms-interview-questions-for-programmers-b4b1ac61f5b0\r\n\r\nIDK how much trust to put in these, but they seem like the right kind of brain-teaser BS.\r\n\r\n### Arrays\r\n\r\n1. How do you find the missing number in a given integer array of 1 to 100? (solution)\r\n1. How do you find the duplicate number on a given integer array? (solution)\r\n1. How do you find the largest and smallest number in an unsorted integer array? (solution)\r\n1. How do you find all pairs of an integer array whose sum is equal to a given number? (solution)\r\n1. How do you find duplicate numbers in an array if it contains multiple duplicates? (solution)\r\n1. How are duplicates removed from a given array in Java? (solution)\r\n1. How is an integer array sorted in place using the quicksort algorithm? (solution)\r\n1. How do you remove duplicates from an array in place? (solution)\r\n1. How do you reverse an array in place in Java? (solution)\r\n1. How are duplicates removed from an array without using any library? (solution)\r\n\r\n### Linked Lists\r\n\r\n1. How do you find the middle element of a singly linked list in one pass? (solution)\r\n1. How do you check if a given linked list contains a cycle? How do you find the starting node of the cycle? (solution)\r\n1. How do you reverse a linked list? (solution)\r\n1. How do you reverse a singly linked list without recursion? (solution)\r\n1. How are duplicate nodes removed in an unsorted linked list? (solution)\r\n1. How do you find the length of a singly linked list? (solution)\r\n1. How do you find the third node from the end in a singly linked list? (solution)\r\n1. How do you find the sum of two linked lists using Stack? (solution)\r\n\r\n### Strings\r\n\r\n1. How do you print duplicate characters from a string? (solution)\r\n1. How do you check if two strings are anagrams of each other? (solution)\r\n1. How do you print the first non-repeated character from a string? (solution)\r\n1. How can a given string be reversed using recursion? (solution)\r\n1. How do you check if a string contains only digits? (solution)\r\n1. How are duplicate characters found in a string? (solution)\r\n1. How do you count a number of vowels and consonants in a given string? (solution)\r\n1. How do you count the occurrence of a given character in a string? (solution)\r\n1. How do you find all permutations of a string? (solution)\r\n1. How do you reverse words in a given sentence without using any library method? (solution)\r\n1. How do you check if two strings are a rotation of each other? (solution)\r\n1. How do you check if a given string is a palindrome? (solution)\r\n\r\n### Binary Trees\r\n\r\n1. How is a binary search tree implemented? (solution)\r\n1. How do you perform preorder traversal in a given binary tree? (solution)\r\n1. How do you traverse a given binary tree in preorder without recursion? (solution)\r\n1. How do you perform an inorder traversal in a given binary tree? (solution)\r\n1. How do you print all nodes of a given binary tree using inorder traversal without recursion? (solution)\r\n1. How do you implement a postorder traversal algorithm? (solution)\r\n1. How do you traverse a binary tree in postorder traversal without recursion? (solution)\r\n1. How are all leaves of a binary search tree printed? (solution)\r\n1. How do you count a number of leaf nodes in a given binary tree? (solution)\r\n1. How do you perform a binary search in a given array? (solution)\r\n\r\n### Misc\r\n\r\n1. How is a bubble sort algorithm implemented? (solution)\r\n1. How is an iterative quicksort algorithm implemented? (solution)\r\n1. How do you implement an insertion sort algorithm? (solution)\r\n1. How is a merge sort algorithm implemented? (solution)\r\n1. How do you implement a bucket sort algorithm? (solution)\r\n1. How do you implement a counting sort algorithm? (solution)\r\n1. How is a radix sort algorithm implemented? (solution)\r\n1. How do you swap two numbers without using the third variable? (solution)\r\n1. How do you check if two rectangles overlap with each other? (solution)\r\n1. How do you design a vending machine? (solution)\r\n",
      "html": "<h1 id=\"example-questions\">Example Questions <a class=\"heading-anchor-permalink\" href=\"#example-questions\">#</a></h1>\n<h2 id=\"service-for-interviews%3F\">Service for interviews? <a class=\"heading-anchor-permalink\" href=\"#service-for-interviews%3F\">#</a></h2>\n<p><a href=\"https://www.interviewbit.com/\">https://www.interviewbit.com/</a></p>\n<h2 id=\"50%2B-questions-from-hackernoon\">50+ questions from HackerNoon <a class=\"heading-anchor-permalink\" href=\"#50%2B-questions-from-hackernoon\">#</a></h2>\n<p><a href=\"https://hackernoon.com/50-data-structure-and-algorithms-interview-questions-for-programmers-b4b1ac61f5b0\">https://hackernoon.com/50-data-structure-and-algorithms-interview-questions-for-programmers-b4b1ac61f5b0</a></p>\n<p>IDK how much trust to put in these, but they seem like the right kind of brain-teaser BS.</p>\n<h3 id=\"arrays\">Arrays <a class=\"heading-anchor-permalink\" href=\"#arrays\">#</a></h3>\n<ol>\n<li>How do you find the missing number in a given integer array of 1 to 100? (solution)</li>\n<li>How do you find the duplicate number on a given integer array? (solution)</li>\n<li>How do you find the largest and smallest number in an unsorted integer array? (solution)</li>\n<li>How do you find all pairs of an integer array whose sum is equal to a given number? (solution)</li>\n<li>How do you find duplicate numbers in an array if it contains multiple duplicates? (solution)</li>\n<li>How are duplicates removed from a given array in Java? (solution)</li>\n<li>How is an integer array sorted in place using the quicksort algorithm? (solution)</li>\n<li>How do you remove duplicates from an array in place? (solution)</li>\n<li>How do you reverse an array in place in Java? (solution)</li>\n<li>How are duplicates removed from an array without using any library? (solution)</li>\n</ol>\n<h3 id=\"linked-lists\">Linked Lists <a class=\"heading-anchor-permalink\" href=\"#linked-lists\">#</a></h3>\n<ol>\n<li>How do you find the middle element of a singly linked list in one pass? (solution)</li>\n<li>How do you check if a given linked list contains a cycle? How do you find the starting node of the cycle? (solution)</li>\n<li>How do you reverse a linked list? (solution)</li>\n<li>How do you reverse a singly linked list without recursion? (solution)</li>\n<li>How are duplicate nodes removed in an unsorted linked list? (solution)</li>\n<li>How do you find the length of a singly linked list? (solution)</li>\n<li>How do you find the third node from the end in a singly linked list? (solution)</li>\n<li>How do you find the sum of two linked lists using Stack? (solution)</li>\n</ol>\n<h3 id=\"strings\">Strings <a class=\"heading-anchor-permalink\" href=\"#strings\">#</a></h3>\n<ol>\n<li>How do you print duplicate characters from a string? (solution)</li>\n<li>How do you check if two strings are anagrams of each other? (solution)</li>\n<li>How do you print the first non-repeated character from a string? (solution)</li>\n<li>How can a given string be reversed using recursion? (solution)</li>\n<li>How do you check if a string contains only digits? (solution)</li>\n<li>How are duplicate characters found in a string? (solution)</li>\n<li>How do you count a number of vowels and consonants in a given string? (solution)</li>\n<li>How do you count the occurrence of a given character in a string? (solution)</li>\n<li>How do you find all permutations of a string? (solution)</li>\n<li>How do you reverse words in a given sentence without using any library method? (solution)</li>\n<li>How do you check if two strings are a rotation of each other? (solution)</li>\n<li>How do you check if a given string is a palindrome? (solution)</li>\n</ol>\n<h3 id=\"binary-trees\">Binary Trees <a class=\"heading-anchor-permalink\" href=\"#binary-trees\">#</a></h3>\n<ol>\n<li>How is a binary search tree implemented? (solution)</li>\n<li>How do you perform preorder traversal in a given binary tree? (solution)</li>\n<li>How do you traverse a given binary tree in preorder without recursion? (solution)</li>\n<li>How do you perform an inorder traversal in a given binary tree? (solution)</li>\n<li>How do you print all nodes of a given binary tree using inorder traversal without recursion? (solution)</li>\n<li>How do you implement a postorder traversal algorithm? (solution)</li>\n<li>How do you traverse a binary tree in postorder traversal without recursion? (solution)</li>\n<li>How are all leaves of a binary search tree printed? (solution)</li>\n<li>How do you count a number of leaf nodes in a given binary tree? (solution)</li>\n<li>How do you perform a binary search in a given array? (solution)</li>\n</ol>\n<h3 id=\"misc\">Misc <a class=\"heading-anchor-permalink\" href=\"#misc\">#</a></h3>\n<ol>\n<li>How is a bubble sort algorithm implemented? (solution)</li>\n<li>How is an iterative quicksort algorithm implemented? (solution)</li>\n<li>How do you implement an insertion sort algorithm? (solution)</li>\n<li>How is a merge sort algorithm implemented? (solution)</li>\n<li>How do you implement a bucket sort algorithm? (solution)</li>\n<li>How do you implement a counting sort algorithm? (solution)</li>\n<li>How is a radix sort algorithm implemented? (solution)</li>\n<li>How do you swap two numbers without using the third variable? (solution)</li>\n<li>How do you check if two rectangles overlap with each other? (solution)</li>\n<li>How do you design a vending machine? (solution)</li>\n</ol>\n",
      "id": 11
    },
    {
      "path": "lists/1-array.md",
      "url": "lists/1-array.html",
      "content": "# Array\r\n\r\nIn computer science, an array data structure, or simply an array, is a data structure consisting of a collection of elements (values or variables), each identified by at least one array index or key. An array is stored such that the position of each element can be computed from its index tuple by a mathematical formula.[1][2][3] The simplest type of data structure is a linear array, also called one-dimensional array.\r\n\r\nFor example, an array of 10 32-bit integer variables, with indices 0 through 9, may be stored as 10 words at memory addresses 2000, 2004, 2008, ... 2036, so that the element with index i has the address 2000 + 4 × i.[4]\r\n\r\nThe memory address of the first element of an array is called first address or foundation address.\r\n\r\nBecause the mathematical concept of a matrix can be represented as a two-dimensional grid, two-dimensional arrays are also sometimes called matrices. In some cases the term \"vector\" is used in computing to refer to an array, although tuples rather than vectors are the more mathematically correct equivalent. Tables are often implemented in the form of arrays, especially lookup tables; the word table is sometimes used as a synonym of array.\r\n\r\nArrays are among the oldest and most important data structures, and are used by almost every program. They are also used to implement many other data structures, such as lists and strings. They effectively exploit the addressing logic of computers. In most modern computers and many external storage devices, the memory is a one-dimensional array of words, whose indices are their addresses. Processors, especially vector processors, are often optimized for array operations.\r\n\r\nArrays are useful mostly because the element indices can be computed at run time. Among other things, this feature allows a single iterative statement to process arbitrarily many elements of an array. For that reason, the elements of an array data structure are required to have the same size and should use the same data representation. The set of valid index tuples and the addresses of the elements (and hence the element addressing formula) are usually,[3][5] but not always,[2] fixed while the array is in use.\r\n\r\nThe term array is often used to mean array data type, a kind of data type provided by most high-level programming languages that consists of a collection of values or variables that can be selected by one or more indices computed at run-time. Array types are often implemented by array structures; however, in some languages they may be implemented by hash tables, linked lists, search trees, or other data structures.\r\n\r\nThe term is also used, especially in the description of algorithms, to mean associative array or \"abstract array\", a theoretical computer science model (an abstract data type or ADT) intended to capture the essential properties of arrays.\r\n\r\n## References\r\n\r\n- [Wikipedia](https://en.wikipedia.org/wiki/Array_data_structure)\r\n- ...\r\n",
      "html": "<h1 id=\"array\">Array <a class=\"heading-anchor-permalink\" href=\"#array\">#</a></h1>\n<p>In computer science, an array data structure, or simply an array, is a data structure consisting of a collection of elements (values or variables), each identified by at least one array index or key. An array is stored such that the position of each element can be computed from its index tuple by a mathematical formula.[1][2][3] The simplest type of data structure is a linear array, also called one-dimensional array.</p>\n<p>For example, an array of 10 32-bit integer variables, with indices 0 through 9, may be stored as 10 words at memory addresses 2000, 2004, 2008, … 2036, so that the element with index i has the address 2000 + 4 × i.[4]</p>\n<p>The memory address of the first element of an array is called first address or foundation address.</p>\n<p>Because the mathematical concept of a matrix can be represented as a two-dimensional grid, two-dimensional arrays are also sometimes called matrices. In some cases the term “vector” is used in computing to refer to an array, although tuples rather than vectors are the more mathematically correct equivalent. Tables are often implemented in the form of arrays, especially lookup tables; the word table is sometimes used as a synonym of array.</p>\n<p>Arrays are among the oldest and most important data structures, and are used by almost every program. They are also used to implement many other data structures, such as lists and strings. They effectively exploit the addressing logic of computers. In most modern computers and many external storage devices, the memory is a one-dimensional array of words, whose indices are their addresses. Processors, especially vector processors, are often optimized for array operations.</p>\n<p>Arrays are useful mostly because the element indices can be computed at run time. Among other things, this feature allows a single iterative statement to process arbitrarily many elements of an array. For that reason, the elements of an array data structure are required to have the same size and should use the same data representation. The set of valid index tuples and the addresses of the elements (and hence the element addressing formula) are usually,[3][5] but not always,[2] fixed while the array is in use.</p>\n<p>The term array is often used to mean array data type, a kind of data type provided by most high-level programming languages that consists of a collection of values or variables that can be selected by one or more indices computed at run-time. Array types are often implemented by array structures; however, in some languages they may be implemented by hash tables, linked lists, search trees, or other data structures.</p>\n<p>The term is also used, especially in the description of algorithms, to mean associative array or “abstract array”, a theoretical computer science model (an abstract data type or ADT) intended to capture the essential properties of arrays.</p>\n<h2 id=\"references\">References <a class=\"heading-anchor-permalink\" href=\"#references\">#</a></h2>\n<ul>\n<li><a href=\"https://en.wikipedia.org/wiki/Array_data_structure\">Wikipedia</a></li>\n<li>…</li>\n</ul>\n",
      "id": 12
    },
    {
      "path": "lists/2-dynamic-array.md",
      "url": "lists/2-dynamic-array.html",
      "content": "# Dynamic array\r\n\r\nIn computer science, a dynamic array, growable array, resizable array, dynamic table, mutable array, or array list is a random access, variable-size list data structure that allows elements to be added or removed. It is supplied with standard libraries in many modern mainstream programming languages. Dynamic arrays overcome a limit of static arrays, which have a fixed capacity that needs to be specified at allocation.\r\n\r\nA dynamic array is not the same thing as a dynamically allocated array, which is an array whose size is fixed when the array is allocated, although a dynamic array may use such a fixed-size array as a back end.[1]\r\n\r\n## References\r\n\r\n- [Wikipedia](https://en.wikipedia.org/wiki/Dynamic_array)\r\n- ...\r\n",
      "html": "<h1 id=\"dynamic-array\">Dynamic array <a class=\"heading-anchor-permalink\" href=\"#dynamic-array\">#</a></h1>\n<p>In computer science, a dynamic array, growable array, resizable array, dynamic table, mutable array, or array list is a random access, variable-size list data structure that allows elements to be added or removed. It is supplied with standard libraries in many modern mainstream programming languages. Dynamic arrays overcome a limit of static arrays, which have a fixed capacity that needs to be specified at allocation.</p>\n<p>A dynamic array is not the same thing as a dynamically allocated array, which is an array whose size is fixed when the array is allocated, although a dynamic array may use such a fixed-size array as a back end.[1]</p>\n<h2 id=\"references\">References <a class=\"heading-anchor-permalink\" href=\"#references\">#</a></h2>\n<ul>\n<li><a href=\"https://en.wikipedia.org/wiki/Dynamic_array\">Wikipedia</a></li>\n<li>…</li>\n</ul>\n",
      "id": 13
    },
    {
      "path": "lists/3-linked-list.md",
      "url": "lists/3-linked-list.html",
      "content": "# Linked List\r\n\r\n_Read this in other languages:_\r\n[_简体中文_](README.zh-CN.md),\r\n[_Русский_](README.ru-RU.md)\r\n\r\nIn computer science, a **linked list** is a linear collection \r\nof data elements, in which linear order is not given by \r\ntheir physical placement in memory. Instead, each \r\nelement points to the next. It is a data structure \r\nconsisting of a group of nodes which together represent \r\na sequence. Under the simplest form, each node is \r\ncomposed of data and a reference (in other words, \r\na link) to the next node in the sequence. This structure\r\nallows for efficient insertion or removal of elements \r\nfrom any position in the sequence during iteration. \r\nMore complex variants add additional links, allowing \r\nefficient insertion or removal from arbitrary element \r\nreferences. A drawback of linked lists is that access \r\ntime is linear (and difficult to pipeline). Faster \r\naccess, such as random access, is not feasible. Arrays \r\nhave better cache locality as compared to linked lists.\r\n\r\n![Linked List](https://upload.wikimedia.org/wikipedia/commons/6/6d/Singly-linked-list.svg)\r\n\r\n## Javascript\r\n\r\n```javascript\r\nclass SinglyLinkedListNode {\r\n    constructor(nodeData, next = null) {\r\n        this.data = nodeData;\r\n        this.next = next;\r\n    }\r\n};\r\n\r\nclass SinglyLinkedList {\r\n    constructor() {\r\n        this.head = null;\r\n        this.tail = null;\r\n    }\r\n\r\n    insertNode(nodeData) {\r\n        const node = new SinglyLinkedListNode(nodeData);\r\n\r\n        if (this.head == null) {\r\n            this.head = node;\r\n        } else {\r\n            this.tail.next = node;\r\n        }\r\n\r\n        this.tail = node;\r\n    }\r\n\r\n    getAt(index) {\r\n        let counter = 0;\r\n        let node = this.head;\r\n        while (node) {\r\n            if (counter === index) {\r\n               return node;\r\n            }\r\n            counter++;\r\n            node = node.next;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    insertAt(nodeData, index) {\r\n        // if the list is empty i.e. head = null\r\n        if (!this.head) {\r\n            this.head = new SinglyLinkedListNode(nodeData);\r\n            return;\r\n        }\r\n        // if new node needs to be inserted at the front of the list i.e. before the head. \r\n        if (index === 0) {\r\n           this.head = new SinglyLinkedListNode(nodeData, this.head);\r\n           return;\r\n        }\r\n        // else, use getAt() to find the previous node.\r\n        const previous = this.getAt(index - 1);\r\n        let newNode = new SinglyLinkedListNode(nodeData);\r\n        newNode.next = previous.next;\r\n        previous.next = newNode;\r\n\r\n        return this.head\r\n   }\r\n};\r\n```\r\n\r\n## Pseudocode for Basic Operations\r\n\r\n### Insert\r\n\r\n```text\r\nAdd(value)\r\n  Pre: value is the value to add to the list\r\n  Post: value has been placed at the tail of the list\r\n  n ← node(value)\r\n  if head = ø\r\n    head ← n\r\n    tail ← n\r\n  else\r\n    tail.next ← n\r\n    tail ← n\r\n  end if\r\nend Add\r\n```\r\n\r\n```text\r\nPrepend(value)\r\n Pre: value is the value to add to the list\r\n Post: value has been placed at the head of the list\r\n n ← node(value)\r\n n.next ← head\r\n head ← n\r\n if tail = ø\r\n   tail ← n\r\n end\r\nend Prepend\r\n```\r\n\r\n### Search\r\n\r\n```text\r\nContains(head, value)\r\n  Pre: head is the head node in the list\r\n       value is the value to search for\r\n  Post: the item is either in the linked list, true; otherwise false\r\n  n ← head\r\n  while n != ø and n.value != value\r\n    n ← n.next\r\n  end while\r\n  if n = ø\r\n    return false\r\n  end if\r\n  return true\r\nend Contains\r\n```\r\n    \r\n### Delete\r\n\r\n```text\r\nRemove(head, value)\r\n  Pre: head is the head node in the list\r\n       value is the value to remove from the list\r\n  Post: value is removed from the list, true, otherwise false\r\n  if head = ø\r\n    return false\r\n  end if\r\n  n ← head\r\n  if n.value = value\r\n    if head = tail\r\n      head ← ø\r\n      tail ← ø\r\n    else\r\n      head ← head.next\r\n    end if\r\n    return true\r\n  end if\r\n  while n.next != ø and n.next.value != value\r\n    n ← n.next\r\n  end while\r\n  if n.next != ø\r\n    if n.next = tail\r\n      tail ← n\r\n    end if\r\n    n.next ← n.next.next\r\n    return true\r\n  end if\r\n  return false\r\nend Remove\r\n```\r\n\r\n### Traverse\r\n\r\n```text\r\nTraverse(head)\r\n  Pre: head is the head node in the list\r\n  Post: the items in the list have been traversed\r\n  n ← head\r\n  while n != ø\r\n    yield n.value\r\n    n ← n.next\r\n  end while\r\nend Traverse\r\n```\r\n\r\n### Traverse in Reverse\r\n\r\n```text\r\nReverseTraversal(head, tail)\r\n  Pre: head and tail belong to the same list\r\n  Post: the items in the list have been traversed in reverse order\r\n  if tail != ø\r\n    curr ← tail\r\n    while curr != head\r\n      prev ← head\r\n      while prev.next != curr\r\n        prev ← prev.next\r\n      end while\r\n      yield curr.value\r\n      curr ← prev\r\n    end while\r\n   yeild curr.value\r\n  end if\r\nend ReverseTraversal\r\n```\r\n\r\n## Complexities\r\n\r\n### Time Complexity\r\n\r\n| Access    | Search    | Insertion | Deletion  |\r\n| :-------: | :-------: | :-------: | :-------: |\r\n| O(n)      | O(n)      | O(1)      | O(1)      |\r\n\r\n### Space Complexity\r\n\r\nO(n)\r\n\r\n## References\r\n\r\n- [Wikipedia](https://en.wikipedia.org/wiki/Linked_list)\r\n- [YouTube](https://www.youtube.com/watch?v=njTh_OwMljA&index=2&t=1s&list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8)\r\n",
      "html": "<h1 id=\"linked-list\">Linked List <a class=\"heading-anchor-permalink\" href=\"#linked-list\">#</a></h1>\n<p><em>Read this in other languages:</em>\n<a href=\"README.zh-CN.html\"><em>简体中文</em></a>,\n<a href=\"README.ru-RU.html\"><em>Русский</em></a></p>\n<p>In computer science, a <strong>linked list</strong> is a linear collection\nof data elements, in which linear order is not given by\ntheir physical placement in memory. Instead, each\nelement points to the next. It is a data structure\nconsisting of a group of nodes which together represent\na sequence. Under the simplest form, each node is\ncomposed of data and a reference (in other words,\na link) to the next node in the sequence. This structure\nallows for efficient insertion or removal of elements\nfrom any position in the sequence during iteration.\nMore complex variants add additional links, allowing\nefficient insertion or removal from arbitrary element\nreferences. A drawback of linked lists is that access\ntime is linear (and difficult to pipeline). Faster\naccess, such as random access, is not feasible. Arrays\nhave better cache locality as compared to linked lists.</p>\n<p><img src=\"https://upload.wikimedia.org/wikipedia/commons/6/6d/Singly-linked-list.svg\" alt=\"Linked List\"></p>\n<h2 id=\"javascript\">Javascript <a class=\"heading-anchor-permalink\" href=\"#javascript\">#</a></h2>\n<pre><code class=\"language-javascript\">class SinglyLinkedListNode {\n    constructor(nodeData, next = null) {\n        this.data = nodeData;\n        this.next = next;\n    }\n};\n\nclass SinglyLinkedList {\n    constructor() {\n        this.head = null;\n        this.tail = null;\n    }\n\n    insertNode(nodeData) {\n        const node = new SinglyLinkedListNode(nodeData);\n\n        if (this.head == null) {\n            this.head = node;\n        } else {\n            this.tail.next = node;\n        }\n\n        this.tail = node;\n    }\n\n    getAt(index) {\n        let counter = 0;\n        let node = this.head;\n        while (node) {\n            if (counter === index) {\n               return node;\n            }\n            counter++;\n            node = node.next;\n        }\n        return null;\n    }\n\n    insertAt(nodeData, index) {\n        // if the list is empty i.e. head = null\n        if (!this.head) {\n            this.head = new SinglyLinkedListNode(nodeData);\n            return;\n        }\n        // if new node needs to be inserted at the front of the list i.e. before the head. \n        if (index === 0) {\n           this.head = new SinglyLinkedListNode(nodeData, this.head);\n           return;\n        }\n        // else, use getAt() to find the previous node.\n        const previous = this.getAt(index - 1);\n        let newNode = new SinglyLinkedListNode(nodeData);\n        newNode.next = previous.next;\n        previous.next = newNode;\n\n        return this.head\n   }\n};\n</code></pre>\n<h2 id=\"pseudocode-for-basic-operations\">Pseudocode for Basic Operations <a class=\"heading-anchor-permalink\" href=\"#pseudocode-for-basic-operations\">#</a></h2>\n<h3 id=\"insert\">Insert <a class=\"heading-anchor-permalink\" href=\"#insert\">#</a></h3>\n<pre><code class=\"language-text\">Add(value)\n  Pre: value is the value to add to the list\n  Post: value has been placed at the tail of the list\n  n ← node(value)\n  if head = ø\n    head ← n\n    tail ← n\n  else\n    tail.next ← n\n    tail ← n\n  end if\nend Add\n</code></pre>\n<pre><code class=\"language-text\">Prepend(value)\n Pre: value is the value to add to the list\n Post: value has been placed at the head of the list\n n ← node(value)\n n.next ← head\n head ← n\n if tail = ø\n   tail ← n\n end\nend Prepend\n</code></pre>\n<h3 id=\"search\">Search <a class=\"heading-anchor-permalink\" href=\"#search\">#</a></h3>\n<pre><code class=\"language-text\">Contains(head, value)\n  Pre: head is the head node in the list\n       value is the value to search for\n  Post: the item is either in the linked list, true; otherwise false\n  n ← head\n  while n != ø and n.value != value\n    n ← n.next\n  end while\n  if n = ø\n    return false\n  end if\n  return true\nend Contains\n</code></pre>\n<h3 id=\"delete\">Delete <a class=\"heading-anchor-permalink\" href=\"#delete\">#</a></h3>\n<pre><code class=\"language-text\">Remove(head, value)\n  Pre: head is the head node in the list\n       value is the value to remove from the list\n  Post: value is removed from the list, true, otherwise false\n  if head = ø\n    return false\n  end if\n  n ← head\n  if n.value = value\n    if head = tail\n      head ← ø\n      tail ← ø\n    else\n      head ← head.next\n    end if\n    return true\n  end if\n  while n.next != ø and n.next.value != value\n    n ← n.next\n  end while\n  if n.next != ø\n    if n.next = tail\n      tail ← n\n    end if\n    n.next ← n.next.next\n    return true\n  end if\n  return false\nend Remove\n</code></pre>\n<h3 id=\"traverse\">Traverse <a class=\"heading-anchor-permalink\" href=\"#traverse\">#</a></h3>\n<pre><code class=\"language-text\">Traverse(head)\n  Pre: head is the head node in the list\n  Post: the items in the list have been traversed\n  n ← head\n  while n != ø\n    yield n.value\n    n ← n.next\n  end while\nend Traverse\n</code></pre>\n<h3 id=\"traverse-in-reverse\">Traverse in Reverse <a class=\"heading-anchor-permalink\" href=\"#traverse-in-reverse\">#</a></h3>\n<pre><code class=\"language-text\">ReverseTraversal(head, tail)\n  Pre: head and tail belong to the same list\n  Post: the items in the list have been traversed in reverse order\n  if tail != ø\n    curr ← tail\n    while curr != head\n      prev ← head\n      while prev.next != curr\n        prev ← prev.next\n      end while\n      yield curr.value\n      curr ← prev\n    end while\n   yeild curr.value\n  end if\nend ReverseTraversal\n</code></pre>\n<h2 id=\"complexities\">Complexities <a class=\"heading-anchor-permalink\" href=\"#complexities\">#</a></h2>\n<h3 id=\"time-complexity\">Time Complexity <a class=\"heading-anchor-permalink\" href=\"#time-complexity\">#</a></h3>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">Access</th>\n<th style=\"text-align:center\">Search</th>\n<th style=\"text-align:center\">Insertion</th>\n<th style=\"text-align:center\">Deletion</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">O(n)</td>\n<td style=\"text-align:center\">O(n)</td>\n<td style=\"text-align:center\">O(1)</td>\n<td style=\"text-align:center\">O(1)</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"space-complexity\">Space Complexity <a class=\"heading-anchor-permalink\" href=\"#space-complexity\">#</a></h3>\n<p>O(n)</p>\n<h2 id=\"references\">References <a class=\"heading-anchor-permalink\" href=\"#references\">#</a></h2>\n<ul>\n<li><a href=\"https://en.wikipedia.org/wiki/Linked_list\">Wikipedia</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=njTh_OwMljA&amp;index=2&amp;t=1s&amp;list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8\">YouTube</a></li>\n</ul>\n",
      "id": 14
    },
    {
      "path": "lists/4-queue.md",
      "url": "lists/4-queue.html",
      "content": "# Queue\r\n\r\n_Read this in other languages:_\r\n[_简体中文_](README.zh-CN.md),\r\n[_Русский_](README.ru-RU.md)\r\n\r\nIn computer science, a **queue** is a particular kind of abstract data \r\ntype or collection in which the entities in the collection are \r\nkept in order and the principle (or only) operations on the \r\ncollection are the addition of entities to the rear terminal \r\nposition, known as enqueue, and removal of entities from the \r\nfront terminal position, known as dequeue. This makes the queue \r\na First-In-First-Out (FIFO) data structure. In a FIFO data \r\nstructure, the first element added to the queue will be the \r\nfirst one to be removed. This is equivalent to the requirement \r\nthat once a new element is added, all elements that were added \r\nbefore have to be removed before the new element can be removed. \r\nOften a peek or front operation is also entered, returning the \r\nvalue of the front element without dequeuing it. A queue is an \r\nexample of a linear data structure, or more abstractly a \r\nsequential collection.\r\n\r\nRepresentation of a FIFO (first in, first out) queue\r\n\r\n![Queue](https://upload.wikimedia.org/wikipedia/commons/5/52/Data_Queue.svg)\r\n\r\n## Javascript\r\n\r\n```javascript\r\nconst queue = [];\r\n\r\n//put value on end of queue\r\nqueue.push(1);\r\n\r\n//Take first value from queue\r\nconst value = queue.shift();\r\n```\r\n\r\n## References\r\n\r\n- [Wikipedia](https://en.wikipedia.org/wiki/Queue_(abstract_data_type))\r\n- [YouTube](https://www.youtube.com/watch?v=wjI1WNcIntg&list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8&index=3&)\r\n",
      "html": "<h1 id=\"queue\">Queue <a class=\"heading-anchor-permalink\" href=\"#queue\">#</a></h1>\n<p><em>Read this in other languages:</em>\n<a href=\"README.zh-CN.html\"><em>简体中文</em></a>,\n<a href=\"README.ru-RU.html\"><em>Русский</em></a></p>\n<p>In computer science, a <strong>queue</strong> is a particular kind of abstract data\ntype or collection in which the entities in the collection are\nkept in order and the principle (or only) operations on the\ncollection are the addition of entities to the rear terminal\nposition, known as enqueue, and removal of entities from the\nfront terminal position, known as dequeue. This makes the queue\na First-In-First-Out (FIFO) data structure. In a FIFO data\nstructure, the first element added to the queue will be the\nfirst one to be removed. This is equivalent to the requirement\nthat once a new element is added, all elements that were added\nbefore have to be removed before the new element can be removed.\nOften a peek or front operation is also entered, returning the\nvalue of the front element without dequeuing it. A queue is an\nexample of a linear data structure, or more abstractly a\nsequential collection.</p>\n<p>Representation of a FIFO (first in, first out) queue</p>\n<p><img src=\"https://upload.wikimedia.org/wikipedia/commons/5/52/Data_Queue.svg\" alt=\"Queue\"></p>\n<h2 id=\"javascript\">Javascript <a class=\"heading-anchor-permalink\" href=\"#javascript\">#</a></h2>\n<pre><code class=\"language-javascript\">const queue = [];\n\n//put value on end of queue\nqueue.push(1);\n\n//Take first value from queue\nconst value = queue.shift();\n</code></pre>\n<h2 id=\"references\">References <a class=\"heading-anchor-permalink\" href=\"#references\">#</a></h2>\n<ul>\n<li><a href=\"https://en.wikipedia.org/wiki/Queue_(abstract_data_type)\">Wikipedia</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=wjI1WNcIntg&amp;list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8&amp;index=3&amp;\">YouTube</a></li>\n</ul>\n",
      "id": 15
    },
    {
      "path": "lists/5-stack.md",
      "url": "lists/5-stack.html",
      "content": "# Stack\r\n\r\nIn computer science, a stack is an abstract data type that serves as a collection of elements, with two main principal operations:\r\n\r\n- Push, which adds an element to the collection, and\r\n- Pop, which removes the most recently added element that was not yet removed.\r\n\r\nThe order in which elements come off a stack gives rise to its alternative name, LIFO (last in, first out). Additionally, a peek operation may give access to the top without modifying the stack.[1] The name \"stack\" for this type of structure comes from the analogy to a set of physical items stacked on top of each other. This structure makes it easy to take an item off the top of the stack, while getting to an item deeper in the stack may require taking off multiple other items first.[2]\r\n\r\nConsidered as a linear data structure, or more abstractly a sequential collection, the push and pop operations occur only at one end of the structure, referred to as the top of the stack. This data structure makes it possible to implement a stack as a singly linked list and a pointer to the top element. A stack may be implemented to have a bounded capacity. If the stack is full and does not contain enough space to accept an entity to be pushed, the stack is then considered to be in an overflow state. The pop operation removes an item from the top of the stack.\r\n\r\n## Javascript\r\n\r\n```javascript\r\nconst stack = [];\r\n\r\n//put value on top of stack\r\nstack.push(1);\r\n\r\n//remove value from top of stack\r\nconst value = stack.pop();\r\n```\r\n",
      "html": "<h1 id=\"stack\">Stack <a class=\"heading-anchor-permalink\" href=\"#stack\">#</a></h1>\n<p>In computer science, a stack is an abstract data type that serves as a collection of elements, with two main principal operations:</p>\n<ul>\n<li>Push, which adds an element to the collection, and</li>\n<li>Pop, which removes the most recently added element that was not yet removed.</li>\n</ul>\n<p>The order in which elements come off a stack gives rise to its alternative name, LIFO (last in, first out). Additionally, a peek operation may give access to the top without modifying the stack.[1] The name “stack” for this type of structure comes from the analogy to a set of physical items stacked on top of each other. This structure makes it easy to take an item off the top of the stack, while getting to an item deeper in the stack may require taking off multiple other items first.[2]</p>\n<p>Considered as a linear data structure, or more abstractly a sequential collection, the push and pop operations occur only at one end of the structure, referred to as the top of the stack. This data structure makes it possible to implement a stack as a singly linked list and a pointer to the top element. A stack may be implemented to have a bounded capacity. If the stack is full and does not contain enough space to accept an entity to be pushed, the stack is then considered to be in an overflow state. The pop operation removes an item from the top of the stack.</p>\n<h2 id=\"javascript\">Javascript <a class=\"heading-anchor-permalink\" href=\"#javascript\">#</a></h2>\n<pre><code class=\"language-javascript\">const stack = [];\n\n//put value on top of stack\nstack.push(1);\n\n//remove value from top of stack\nconst value = stack.pop();\n</code></pre>\n",
      "id": 16
    },
    {
      "path": "maths/big-o-notation.md",
      "url": "maths/big-o-notation.html",
      "content": "# Big O notation \r\n\r\n## Time complexities\r\n\r\n### O(1)\r\n\r\nConstant time. Never changes in respect to # of inputs.\r\n\r\n### O(log n)\r\n\r\nLogarithmic time. Highly efficient, as the ratio of the number of operations to the size of the input decreases and tends to zero when _n_ increases.\r\n\r\n### O(n)\r\n\r\nLinear time. Scales linearly with # of inputs.\r\n\r\n### O(n²)\r\n\r\nQuadratic time. Highly inefficient as _n_ grows.\r\n\r\n### O(2ⁿ)\r\n\r\nExponential time. Crazy inefficient as _n_ scales up.\r\n\r\n### O(n!)\r\n\r\nFactorial time. Hilariously inefficient.\r\n\r\n## Space complexities\r\n\r\nSpace complexity is the amount of memory used by the algorithm (including the input values to the algorithm) to execute and produce the result.\r\n\r\nOR\r\n\r\nSpace complexity is a measure of the amount of working storage an algorithm needs. That means how much memory, in the worst case, is needed at any point in the algorithm. As with time complexity, we're mostly concerned with how the space needs grow, in big-Oh terms, as the size N of the input problem grows.\r\n\r\n## Tables\r\n\r\n![Big O chart](./big-o-chart.png \"Big O\")\r\n\r\n![Big O chart](./1-data-structs.jpg \"Big O\")\r\n\r\n![Big O chart](./2-searching.jpg \"Big O\")\r\n\r\n![Big O chart](./3-sorting.jpg \"Big O\")\r\n\r\n![Big O chart](./4-heaps.jpg \"Big O\")\r\n\r\n![Big O chart](./5-graphs.jpg \"Big O\")\r\n\r\n![Big O cheatsheet](./big-o-cheatsheet-2.png \"Big O\")\r\n\r\n## Resources\r\n\r\n- [Wikipedia - Computational complexity](https://en.wikipedia.org/wiki/Computational_complexity)\r\n- [Wikipedia - Time complexity](https://en.wikipedia.org/wiki/Time_complexity)\r\n- [Big-O Cheat Sheet](http://bigocheatsheet.com/)\r\n- [Getting Sorted & Big O Notation - Computerphile](https://youtu.be/kgBjXUE_Nwc?t=452)\r\n- [Big O Notation - Gayle Laakmann McDowell](https://www.youtube.com/watch?v=v4cd1O4zkGw)\r\n- [Big O Notations - Derek Banas](https://www.youtube.com/watch?v=V6mKVRU1evU)\r\n- [Northwestern University - Space Complexity EECS 311](https://www.cs.northwestern.edu/academics/courses/311/html/space-complexity.html)\r\n",
      "html": "<h1 id=\"big-o-notation\">Big O notation <a class=\"heading-anchor-permalink\" href=\"#big-o-notation\">#</a></h1>\n<h2 id=\"time-complexities\">Time complexities <a class=\"heading-anchor-permalink\" href=\"#time-complexities\">#</a></h2>\n<h3 id=\"o(1)\">O(1) <a class=\"heading-anchor-permalink\" href=\"#o(1)\">#</a></h3>\n<p>Constant time. Never changes in respect to # of inputs.</p>\n<h3 id=\"o(log-n)\">O(log n) <a class=\"heading-anchor-permalink\" href=\"#o(log-n)\">#</a></h3>\n<p>Logarithmic time. Highly efficient, as the ratio of the number of operations to the size of the input decreases and tends to zero when <em>n</em> increases.</p>\n<h3 id=\"o(n)\">O(n) <a class=\"heading-anchor-permalink\" href=\"#o(n)\">#</a></h3>\n<p>Linear time. Scales linearly with # of inputs.</p>\n<h3 id=\"o(n%C2%B2)\">O(n²) <a class=\"heading-anchor-permalink\" href=\"#o(n%C2%B2)\">#</a></h3>\n<p>Quadratic time. Highly inefficient as <em>n</em> grows.</p>\n<h3 id=\"o(2%E2%81%BF)\">O(2ⁿ) <a class=\"heading-anchor-permalink\" href=\"#o(2%E2%81%BF)\">#</a></h3>\n<p>Exponential time. Crazy inefficient as <em>n</em> scales up.</p>\n<h3 id=\"o(n!)\">O(n!) <a class=\"heading-anchor-permalink\" href=\"#o(n!)\">#</a></h3>\n<p>Factorial time. Hilariously inefficient.</p>\n<h2 id=\"space-complexities\">Space complexities <a class=\"heading-anchor-permalink\" href=\"#space-complexities\">#</a></h2>\n<p>Space complexity is the amount of memory used by the algorithm (including the input values to the algorithm) to execute and produce the result.</p>\n<p>OR</p>\n<p>Space complexity is a measure of the amount of working storage an algorithm needs. That means how much memory, in the worst case, is needed at any point in the algorithm. As with time complexity, we’re mostly concerned with how the space needs grow, in big-Oh terms, as the size N of the input problem grows.</p>\n<h2 id=\"tables\">Tables <a class=\"heading-anchor-permalink\" href=\"#tables\">#</a></h2>\n<p><img src=\"./big-o-chart.png\" alt=\"Big O chart\" title=\"Big O\"></p>\n<p><img src=\"./1-data-structs.jpg\" alt=\"Big O chart\" title=\"Big O\"></p>\n<p><img src=\"./2-searching.jpg\" alt=\"Big O chart\" title=\"Big O\"></p>\n<p><img src=\"./3-sorting.jpg\" alt=\"Big O chart\" title=\"Big O\"></p>\n<p><img src=\"./4-heaps.jpg\" alt=\"Big O chart\" title=\"Big O\"></p>\n<p><img src=\"./5-graphs.jpg\" alt=\"Big O chart\" title=\"Big O\"></p>\n<p><img src=\"./big-o-cheatsheet-2.png\" alt=\"Big O cheatsheet\" title=\"Big O\"></p>\n<h2 id=\"resources\">Resources <a class=\"heading-anchor-permalink\" href=\"#resources\">#</a></h2>\n<ul>\n<li><a href=\"https://en.wikipedia.org/wiki/Computational_complexity\">Wikipedia - Computational complexity</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/Time_complexity\">Wikipedia - Time complexity</a></li>\n<li><a href=\"http://bigocheatsheet.com/\">Big-O Cheat Sheet</a></li>\n<li><a href=\"https://youtu.be/kgBjXUE_Nwc?t=452\">Getting Sorted &amp; Big O Notation - Computerphile</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=v4cd1O4zkGw\">Big O Notation - Gayle Laakmann McDowell</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=V6mKVRU1evU\">Big O Notations - Derek Banas</a></li>\n<li><a href=\"https://www.cs.northwestern.edu/academics/courses/311/html/space-complexity.html\">Northwestern University - Space Complexity EECS 311</a></li>\n</ul>\n",
      "id": 17
    },
    {
      "path": "sets-and-maps/2-hash-map.md",
      "url": "sets-and-maps/2-hash-map.html",
      "content": "# Hash Table\r\n\r\nIn computing, a **hash table** (hash map) is a data \r\nstructure which implements an *associative array* \r\nabstract data type, a structure that can *map keys \r\nto values*. A hash table uses a *hash function* to \r\ncompute an index into an array of buckets or slots, \r\nfrom which the desired value can be found\r\n\r\nIdeally, the hash function will assign each key to a \r\nunique bucket, but most hash table designs employ an \r\nimperfect hash function, which might cause hash \r\ncollisions where the hash function generates the same\r\nindex for more than one key. Such collisions must be\r\naccommodated in some way.\r\n\r\n![Hash Table](https://upload.wikimedia.org/wikipedia/commons/7/7d/Hash_table_3_1_1_0_1_0_0_SP.svg)\r\n\r\nHash collision resolved by separate chaining.\r\n\r\n![Hash Collision](https://upload.wikimedia.org/wikipedia/commons/d/d0/Hash_table_5_0_1_1_1_1_1_LL.svg)\r\n\r\n## Javascript\r\n\r\n```javascript\r\nconst map1 = new Map();\r\n\r\nmap1.set('a', 1);\r\nmap1.set('b', 2);\r\nmap1.set('c', 3);\r\n\r\nconsole.log(map1.get('a'));\r\n// expected output: 1\r\n\r\nmap1.set('a', 97);\r\n\r\nconsole.log(map1.get('a'));\r\n// expected output: 97\r\n\r\nconsole.log(map1.size);\r\n// expected output: 3\r\n\r\nmap1.delete('b');\r\n\r\nconsole.log(map1.size);\r\n// expected output: 2\r\n```\r\n\r\n## References\r\n\r\n- [Wikipedia](https://en.wikipedia.org/wiki/Hash_table)\r\n- [YouTube](https://www.youtube.com/watch?v=shs0KM3wKv8&index=4&list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8)\r\n",
      "html": "<h1 id=\"hash-table\">Hash Table <a class=\"heading-anchor-permalink\" href=\"#hash-table\">#</a></h1>\n<p>In computing, a <strong>hash table</strong> (hash map) is a data\nstructure which implements an <em>associative array</em>\nabstract data type, a structure that can <em>map keys\nto values</em>. A hash table uses a <em>hash function</em> to\ncompute an index into an array of buckets or slots,\nfrom which the desired value can be found</p>\n<p>Ideally, the hash function will assign each key to a\nunique bucket, but most hash table designs employ an\nimperfect hash function, which might cause hash\ncollisions where the hash function generates the same\nindex for more than one key. Such collisions must be\naccommodated in some way.</p>\n<p><img src=\"https://upload.wikimedia.org/wikipedia/commons/7/7d/Hash_table_3_1_1_0_1_0_0_SP.svg\" alt=\"Hash Table\"></p>\n<p>Hash collision resolved by separate chaining.</p>\n<p><img src=\"https://upload.wikimedia.org/wikipedia/commons/d/d0/Hash_table_5_0_1_1_1_1_1_LL.svg\" alt=\"Hash Collision\"></p>\n<h2 id=\"javascript\">Javascript <a class=\"heading-anchor-permalink\" href=\"#javascript\">#</a></h2>\n<pre><code class=\"language-javascript\">const map1 = new Map();\n\nmap1.set('a', 1);\nmap1.set('b', 2);\nmap1.set('c', 3);\n\nconsole.log(map1.get('a'));\n// expected output: 1\n\nmap1.set('a', 97);\n\nconsole.log(map1.get('a'));\n// expected output: 97\n\nconsole.log(map1.size);\n// expected output: 3\n\nmap1.delete('b');\n\nconsole.log(map1.size);\n// expected output: 2\n</code></pre>\n<h2 id=\"references\">References <a class=\"heading-anchor-permalink\" href=\"#references\">#</a></h2>\n<ul>\n<li><a href=\"https://en.wikipedia.org/wiki/Hash_table\">Wikipedia</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=shs0KM3wKv8&amp;index=4&amp;list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8\">YouTube</a></li>\n</ul>\n",
      "id": 18
    },
    {
      "path": "sets-and-maps/3-heap.md",
      "url": "sets-and-maps/3-heap.html",
      "content": "# Heap (data-structure)\r\n\r\nIn computer science, a **heap** is a specialized tree-based \r\ndata structure that satisfies the heap property described\r\nbelow.\r\n\r\nIn a *min heap*, if `P` is a parent node of `C`, then the\r\nkey (the value) of `P` is less than or equal to the\r\nkey of `C`.\r\n\r\n![MinHeap](https://upload.wikimedia.org/wikipedia/commons/6/69/Min-heap.png)\r\n\r\nIn a *max heap*, the key of `P` is greater than or equal\r\nto the key of `C`\r\n\r\n![Heap](https://upload.wikimedia.org/wikipedia/commons/3/38/Max-Heap.svg)\r\n\r\nThe node at the \"top\" of the heap with no parents is \r\ncalled the root node.\r\n\r\n## Javascript\r\n\r\n```javascript\r\nclass MaxHeap{\r\n    constructor(){\r\n        this.heap = [];\r\n    }\r\n\r\n    parentIndex(index){\r\n        return Math.floor((index-1)/2);\r\n    }\r\n\r\n    leftChildIndex(index){\r\n        return (2*index + 1);\r\n    }\r\n\r\n    rightChildIndex(index){\r\n        return (2*index + 2);\r\n    }\r\n\r\n    swap(a, b) {\r\n        let temp = this.heap[a];\r\n        this.heap[a] = this.heap[b];\r\n        this.heap[b] = temp;\r\n    }\r\n\r\n    insert(item) {\r\n        this.heap.push(item);\r\n        var index = this.heap.length - 1;\r\n        var parent = this.parentIndex(index);\r\n        while(this.heap[parent] && this.heap[parent] < this.heap[index]) {\r\n            this.swap(parent, index);\r\n            index = this.parentIndex(index);\r\n            parent = this.parentIndex(index);\r\n        }\r\n    }\r\n\r\n    delete() {\r\n      var item = this.heap.shift();\r\n      this.heap.unshift(this.heap.pop());\r\n      var index = 0;\r\n      var leftChild = this.leftChildIndex(index);\r\n      var rightChild = this.rightChildIndex(index);\r\n      while(this.heap[leftChild] && this.heap[leftChild] > this.heap[index] || this.heap[rightChild] > this.heap[index]){\r\n          var max = leftChild;\r\n          if(this.heap[rightChild] && this.heap[rightChild] > this.heap[max]){\r\n              max = rightChild\r\n          }\r\n          this.swap(max, index);\r\n          index = max;\r\n          leftChild = this.leftChildIndex(max);\r\n          rightChild = this.rightChildIndex(max);\r\n      }\r\n      return item;\r\n  }\r\n}\r\n```\r\n\r\n## References\r\n\r\n- [Wikipedia](https://en.wikipedia.org/wiki/Heap_(data_structure))\r\n- [YouTube](https://www.youtube.com/watch?v=t0Cq6tVNRBA&index=5&t=0s&list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8)\r\n",
      "html": "<h1 id=\"heap-(data-structure)\">Heap (data-structure) <a class=\"heading-anchor-permalink\" href=\"#heap-(data-structure)\">#</a></h1>\n<p>In computer science, a <strong>heap</strong> is a specialized tree-based\ndata structure that satisfies the heap property described\nbelow.</p>\n<p>In a <em>min heap</em>, if <code>P</code> is a parent node of <code>C</code>, then the\nkey (the value) of <code>P</code> is less than or equal to the\nkey of <code>C</code>.</p>\n<p><img src=\"https://upload.wikimedia.org/wikipedia/commons/6/69/Min-heap.png\" alt=\"MinHeap\"></p>\n<p>In a <em>max heap</em>, the key of <code>P</code> is greater than or equal\nto the key of <code>C</code></p>\n<p><img src=\"https://upload.wikimedia.org/wikipedia/commons/3/38/Max-Heap.svg\" alt=\"Heap\"></p>\n<p>The node at the “top” of the heap with no parents is\ncalled the root node.</p>\n<h2 id=\"javascript\">Javascript <a class=\"heading-anchor-permalink\" href=\"#javascript\">#</a></h2>\n<pre><code class=\"language-javascript\">class MaxHeap{\n    constructor(){\n        this.heap = [];\n    }\n\n    parentIndex(index){\n        return Math.floor((index-1)/2);\n    }\n\n    leftChildIndex(index){\n        return (2*index + 1);\n    }\n\n    rightChildIndex(index){\n        return (2*index + 2);\n    }\n\n    swap(a, b) {\n        let temp = this.heap[a];\n        this.heap[a] = this.heap[b];\n        this.heap[b] = temp;\n    }\n\n    insert(item) {\n        this.heap.push(item);\n        var index = this.heap.length - 1;\n        var parent = this.parentIndex(index);\n        while(this.heap[parent] &amp;&amp; this.heap[parent] &lt; this.heap[index]) {\n            this.swap(parent, index);\n            index = this.parentIndex(index);\n            parent = this.parentIndex(index);\n        }\n    }\n\n    delete() {\n      var item = this.heap.shift();\n      this.heap.unshift(this.heap.pop());\n      var index = 0;\n      var leftChild = this.leftChildIndex(index);\n      var rightChild = this.rightChildIndex(index);\n      while(this.heap[leftChild] &amp;&amp; this.heap[leftChild] &gt; this.heap[index] || this.heap[rightChild] &gt; this.heap[index]){\n          var max = leftChild;\n          if(this.heap[rightChild] &amp;&amp; this.heap[rightChild] &gt; this.heap[max]){\n              max = rightChild\n          }\n          this.swap(max, index);\n          index = max;\n          leftChild = this.leftChildIndex(max);\n          rightChild = this.rightChildIndex(max);\n      }\n      return item;\n  }\n}\n</code></pre>\n<h2 id=\"references\">References <a class=\"heading-anchor-permalink\" href=\"#references\">#</a></h2>\n<ul>\n<li><a href=\"https://en.wikipedia.org/wiki/Heap_(data_structure)\">Wikipedia</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=t0Cq6tVNRBA&amp;index=5&amp;t=0s&amp;list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8\">YouTube</a></li>\n</ul>\n",
      "id": 19
    }
  ]
}