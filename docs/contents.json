{
  "paths": [
    {
      "type": "file",
      "value": "index.md"
    },
    {
      "type": "file",
      "value": "1-study-journal.md"
    },
    {
      "type": "dir",
      "name": "algorithms",
      "children": [
        {
          "type": "file",
          "value": "algorithms/1-binary-search-on-array.md"
        },
        {
          "type": "file",
          "value": "algorithms/2-breadth-first-search.md"
        },
        {
          "type": "file",
          "value": "algorithms/3-depth-first-search.md"
        },
        {
          "type": "file",
          "value": "algorithms/4-dijkstras-algo.md"
        },
        {
          "type": "file",
          "value": "algorithms/5-mergesort.md"
        },
        {
          "type": "file",
          "value": "algorithms/6-quicksort.md"
        },
        {
          "type": "file",
          "value": "algorithms/7-heapsort.md"
        }
      ]
    },
    {
      "type": "dir",
      "name": "graphs-and-trees",
      "children": [
        {
          "type": "file",
          "value": "graphs-and-trees/1-binary-search-tree.md"
        },
        {
          "type": "file",
          "value": "graphs-and-trees/graph.md"
        }
      ]
    },
    {
      "type": "dir",
      "name": "interview",
      "children": [
        {
          "type": "file",
          "value": "interview/1-example-questions.md"
        }
      ]
    },
    {
      "type": "dir",
      "name": "javascript",
      "children": [
        {
          "type": "file",
          "value": "javascript/array.md"
        },
        {
          "type": "file",
          "value": "javascript/concurrency-and-event-loop.md"
        },
        {
          "type": "file",
          "value": "javascript/editions.md"
        },
        {
          "type": "file",
          "value": "javascript/iteration.md"
        },
        {
          "type": "file",
          "value": "javascript/map.md"
        },
        {
          "type": "file",
          "value": "javascript/modules.md"
        },
        {
          "type": "file",
          "value": "javascript/promises-async.md"
        },
        {
          "type": "file",
          "value": "javascript/set.md"
        }
      ]
    },
    {
      "type": "dir",
      "name": "lists",
      "children": [
        {
          "type": "file",
          "value": "lists/1-array.md"
        },
        {
          "type": "file",
          "value": "lists/2-dynamic-array.md"
        },
        {
          "type": "file",
          "value": "lists/3-linked-list.md"
        },
        {
          "type": "file",
          "value": "lists/4-queue.md"
        },
        {
          "type": "file",
          "value": "lists/5-stack.md"
        }
      ]
    },
    {
      "type": "dir",
      "name": "maths",
      "children": [
        {
          "type": "file",
          "value": "maths/big-o-notation.md"
        }
      ]
    },
    {
      "type": "dir",
      "name": "sets-and-maps",
      "children": [
        {
          "type": "file",
          "value": "sets-and-maps/2-hash-map.md"
        },
        {
          "type": "file",
          "value": "sets-and-maps/3-heap.md"
        }
      ]
    }
  ],
  "contents": [
    {
      "path": "index.md",
      "url": "index.html",
      "content": "# Studying algorithms and data structures (notebook)\r\n\r\nLet's git gud\r\n\r\n## Implementation docs\r\n\r\nThe code implementations are documented with jsDoc. Every function is documented in detail for studying. Witness the mess [here](docs/index.html).\r\n\r\n## Resources\r\n\r\n- [Rosetta Code - great place to find pseudocode and reference implementations in various languages](http://rosettacode.org/wiki/Rosetta_Code)\r\n- [Abstract data structures written in Ruby](https://github.com/Integralist/Data-Structures)\r\n- [Algorithms and data structures implemented in JavaScript with explanations and links to further readings](https://github.com/trekhleb/javascript-algorithms)\r\n\r\n---\r\n\r\n## Maths\r\n\r\n- [big-o-notation](./maths/big-o-notation.md)\r\n- [graph](./maths/graph.md)\r\n\r\n## Algorithms\r\n\r\n- [binary-search-on-array](./algorithms/1-binary-search-on-array.md)\r\n- [breadth-first-search](./algorithms/2-breadth-first-search.md)\r\n- [depth-first-search](./algorithms/3-depth-first-search.md)\r\n- [dijkstras-algo](./algorithms/4-dijkstras-algo.md)\r\n- [mergesort](./algorithms/5-mergesort.md)\r\n- [quicksort](./algorithms/6-quicksort.md)\r\n\r\n## Lists\r\n\r\n- [array](./lists/1-array.md)\r\n- [dynamic-array](./lists/2-dynamic-array.md)\r\n- [linked-list](./lists/3-linked-list.md)\r\n\r\n## Sets and maps\r\n\r\n- [binary-search-tree](./sets-and-maps/1-binary-search-tree.md)\r\n- [hash-map](./sets-and-maps/2-hash-map.md)\r\n- [heap](./sets-and-maps/3-heap.md)\r\n",
      "html": "<h1 id=\"studying-algorithms-and-data-structures-(notebook)\">Studying algorithms and data structures (notebook) <a class=\"heading-anchor-permalink\" href=\"#studying-algorithms-and-data-structures-(notebook)\">#</a></h1>\n<p>Let’s git gud</p>\n<h2 id=\"implementation-docs\">Implementation docs <a class=\"heading-anchor-permalink\" href=\"#implementation-docs\">#</a></h2>\n<p>The code implementations are documented with jsDoc. Every function is documented in detail for studying. Witness the mess <a href=\"docs/index.html\">here</a>.</p>\n<h2 id=\"resources\">Resources <a class=\"heading-anchor-permalink\" href=\"#resources\">#</a></h2>\n<ul>\n<li><a href=\"http://rosettacode.org/wiki/Rosetta_Code\">Rosetta Code - great place to find pseudocode and reference implementations in various languages</a></li>\n<li><a href=\"https://github.com/Integralist/Data-Structures\">Abstract data structures written in Ruby</a></li>\n<li><a href=\"https://github.com/trekhleb/javascript-algorithms\">Algorithms and data structures implemented in JavaScript with explanations and links to further readings</a></li>\n</ul>\n<hr>\n<h2 id=\"maths\">Maths <a class=\"heading-anchor-permalink\" href=\"#maths\">#</a></h2>\n<ul>\n<li><a href=\"./maths/big-o-notation.html\">big-o-notation</a></li>\n<li><a href=\"./maths/graph.html\">graph</a></li>\n</ul>\n<h2 id=\"algorithms\">Algorithms <a class=\"heading-anchor-permalink\" href=\"#algorithms\">#</a></h2>\n<ul>\n<li><a href=\"./algorithms/1-binary-search-on-array.html\">binary-search-on-array</a></li>\n<li><a href=\"./algorithms/2-breadth-first-search.html\">breadth-first-search</a></li>\n<li><a href=\"./algorithms/3-depth-first-search.html\">depth-first-search</a></li>\n<li><a href=\"./algorithms/4-dijkstras-algo.html\">dijkstras-algo</a></li>\n<li><a href=\"./algorithms/5-mergesort.html\">mergesort</a></li>\n<li><a href=\"./algorithms/6-quicksort.html\">quicksort</a></li>\n</ul>\n<h2 id=\"lists\">Lists <a class=\"heading-anchor-permalink\" href=\"#lists\">#</a></h2>\n<ul>\n<li><a href=\"./lists/1-array.html\">array</a></li>\n<li><a href=\"./lists/2-dynamic-array.html\">dynamic-array</a></li>\n<li><a href=\"./lists/3-linked-list.html\">linked-list</a></li>\n</ul>\n<h2 id=\"sets-and-maps\">Sets and maps <a class=\"heading-anchor-permalink\" href=\"#sets-and-maps\">#</a></h2>\n<ul>\n<li><a href=\"./sets-and-maps/1-binary-search-tree.html\">binary-search-tree</a></li>\n<li><a href=\"./sets-and-maps/2-hash-map.html\">hash-map</a></li>\n<li><a href=\"./sets-and-maps/3-heap.html\">heap</a></li>\n</ul>\n",
      "id": 0
    },
    {
      "path": "1-study-journal.md",
      "url": "1-study-journal.html",
      "content": "# Study Journal / Changelog\r\n\r\n## 2019-MAR-07\r\n\r\n- example interview questions\r\n- tree-traversal implementations\r\n\r\n## 2019-MAR-05\r\n\r\n- depth-first tree traversal\r\n- breadth-first tree traversal\r\n\r\n## 2019-MAR-03\r\n\r\n- quicksort\r\n- binary search\r\n- lotsa cleanup\r\n\r\n## 2019-MAR-01\r\n\r\n- intro to graphs\r\n- intro to Dijkstra's algo\r\n\r\n## 2019-FEB-27\r\n\r\n- added linked list delete method\r\n\r\n## 2019-FEB-26\r\n\r\n- big O notation, made a page for it\r\n\r\n## 2019-FEB-25\r\n\r\n- built this notebook tool out\r\n- imported tons of pages from \r\n- started building a linked list implementation\r\n",
      "html": "<h1 id=\"study-journal-%2F-changelog\">Study Journal / Changelog <a class=\"heading-anchor-permalink\" href=\"#study-journal-%2F-changelog\">#</a></h1>\n<h2 id=\"2019-mar-07\">2019-MAR-07 <a class=\"heading-anchor-permalink\" href=\"#2019-mar-07\">#</a></h2>\n<ul>\n<li>example interview questions</li>\n<li>tree-traversal implementations</li>\n</ul>\n<h2 id=\"2019-mar-05\">2019-MAR-05 <a class=\"heading-anchor-permalink\" href=\"#2019-mar-05\">#</a></h2>\n<ul>\n<li>depth-first tree traversal</li>\n<li>breadth-first tree traversal</li>\n</ul>\n<h2 id=\"2019-mar-03\">2019-MAR-03 <a class=\"heading-anchor-permalink\" href=\"#2019-mar-03\">#</a></h2>\n<ul>\n<li>quicksort</li>\n<li>binary search</li>\n<li>lotsa cleanup</li>\n</ul>\n<h2 id=\"2019-mar-01\">2019-MAR-01 <a class=\"heading-anchor-permalink\" href=\"#2019-mar-01\">#</a></h2>\n<ul>\n<li>intro to graphs</li>\n<li>intro to Dijkstra’s algo</li>\n</ul>\n<h2 id=\"2019-feb-27\">2019-FEB-27 <a class=\"heading-anchor-permalink\" href=\"#2019-feb-27\">#</a></h2>\n<ul>\n<li>added linked list delete method</li>\n</ul>\n<h2 id=\"2019-feb-26\">2019-FEB-26 <a class=\"heading-anchor-permalink\" href=\"#2019-feb-26\">#</a></h2>\n<ul>\n<li>big O notation, made a page for it</li>\n</ul>\n<h2 id=\"2019-feb-25\">2019-FEB-25 <a class=\"heading-anchor-permalink\" href=\"#2019-feb-25\">#</a></h2>\n<ul>\n<li>built this notebook tool out</li>\n<li>imported tons of pages from</li>\n<li>started building a linked list implementation</li>\n</ul>\n",
      "id": 1
    },
    {
      "path": "algorithms/1-binary-search-on-array.md",
      "url": "algorithms/1-binary-search-on-array.html",
      "content": "# Binary Search\r\n\r\nIn computer science, binary search, also known as half-interval \r\nsearch, logarithmic search, or binary chop, is a search algorithm \r\nthat finds the position of a target value within a sorted \r\narray. Binary search compares the target value to the middle \r\nelement of the array; if they are unequal, the half in which \r\nthe target cannot lie is eliminated and the search continues \r\non the remaining half until it is successful. If the search \r\nends with the remaining half being empty, the target is not \r\nin the array.\r\n\r\nLike many other search algorithms, Binary Search is an in-place algorithm. That means that it works directly on the original array without making any copies.\r\n\r\n![Binary Search](https://upload.wikimedia.org/wikipedia/commons/8/83/Binary_Search_Depiction.svg)\r\n\r\n## Javascript\r\n\r\n```javascript\r\nconst binarySearch = (sortedArray, key) => {\r\n    let start = 0;\r\n    let end = sortedArray.length - 1;\r\n\r\n    while (start <= end) {\r\n        let middle = Math.floor((start + end) / 2);\r\n\r\n        if (sortedArray[middle] === key) {\r\n            // found the key\r\n            return middle;\r\n        } else if (sortedArray[middle] < key) {\r\n            // continue searching to the right\r\n            start = middle + 1;\r\n        } else {\r\n            // search searching to the left\r\n            end = middle - 1;\r\n        }\r\n    }\r\n\t// key wasn't found\r\n    return -1;\r\n}\r\n```\r\n\r\n## Complexity\r\n\r\n**Time Complexity**: `O(log(n))` - since we split search area by two for every next iteration.\r\n\r\nBinary Search really shines when we need to make repeated searches on large arrays. As previously mentioned, we needed only 4 comparisons (comparisons being the most intensive tasks of all search algorithms), for an array of 11 elements. However, if we had an array of 10,000,000 elements, we would only need to check 24 elements, i.e. 0.0002% of the entire array.\r\n\r\n## References\r\n\r\n- [Wikipedia](https://en.wikipedia.org/wiki/Binary_search_algorithm)\r\n- [YouTube](https://www.youtube.com/watch?v=P3YID7liBug&index=29&list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8)\r\n",
      "html": "<h1 id=\"binary-search\">Binary Search <a class=\"heading-anchor-permalink\" href=\"#binary-search\">#</a></h1>\n<p>In computer science, binary search, also known as half-interval\nsearch, logarithmic search, or binary chop, is a search algorithm\nthat finds the position of a target value within a sorted\narray. Binary search compares the target value to the middle\nelement of the array; if they are unequal, the half in which\nthe target cannot lie is eliminated and the search continues\non the remaining half until it is successful. If the search\nends with the remaining half being empty, the target is not\nin the array.</p>\n<p>Like many other search algorithms, Binary Search is an in-place algorithm. That means that it works directly on the original array without making any copies.</p>\n<p><img src=\"https://upload.wikimedia.org/wikipedia/commons/8/83/Binary_Search_Depiction.svg\" alt=\"Binary Search\"></p>\n<h2 id=\"javascript\">Javascript <a class=\"heading-anchor-permalink\" href=\"#javascript\">#</a></h2>\n<pre><code class=\"language-javascript\">const binarySearch = (sortedArray, key) =&gt; {\n    let start = 0;\n    let end = sortedArray.length - 1;\n\n    while (start &lt;= end) {\n        let middle = Math.floor((start + end) / 2);\n\n        if (sortedArray[middle] === key) {\n            // found the key\n            return middle;\n        } else if (sortedArray[middle] &lt; key) {\n            // continue searching to the right\n            start = middle + 1;\n        } else {\n            // search searching to the left\n            end = middle - 1;\n        }\n    }\n\t// key wasn't found\n    return -1;\n}\n</code></pre>\n<h2 id=\"complexity\">Complexity <a class=\"heading-anchor-permalink\" href=\"#complexity\">#</a></h2>\n<p><strong>Time Complexity</strong>: <code>O(log(n))</code> - since we split search area by two for every next iteration.</p>\n<p>Binary Search really shines when we need to make repeated searches on large arrays. As previously mentioned, we needed only 4 comparisons (comparisons being the most intensive tasks of all search algorithms), for an array of 11 elements. However, if we had an array of 10,000,000 elements, we would only need to check 24 elements, i.e. 0.0002% of the entire array.</p>\n<h2 id=\"references\">References <a class=\"heading-anchor-permalink\" href=\"#references\">#</a></h2>\n<ul>\n<li><a href=\"https://en.wikipedia.org/wiki/Binary_search_algorithm\">Wikipedia</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=P3YID7liBug&amp;index=29&amp;list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8\">YouTube</a></li>\n</ul>\n",
      "id": 2
    },
    {
      "path": "algorithms/2-breadth-first-search.md",
      "url": "algorithms/2-breadth-first-search.html",
      "content": "# Breadth-First Search (BFS)\r\n\r\nBreadth-first search (BFS) is an algorithm for traversing \r\nor searching tree or graph data structures. It starts at\r\nthe tree root (or some arbitrary node of a graph, sometimes \r\nreferred to as a 'search key') and explores the neighbor\r\nnodes first, before moving to the next level neighbors.\r\n\r\n![Algorithm Visualization](https://upload.wikimedia.org/wikipedia/commons/5/5d/Breadth-First-Search-Algorithm.gif)\r\n\r\n## Pseudocode\r\n\r\n```text\r\nBFS(root)\r\n  Pre: root is the node of the BST\r\n  Post: the nodes in the BST have been visited in breadth first order\r\n  q ← queue\r\n  while root = ø\r\n    yield root.value\r\n    if root.left = ø\r\n      q.enqueue(root.left)\r\n    end if\r\n    if root.right = ø\r\n      q.enqueue(root.right)\r\n    end if\r\n    if !q.isEmpty()\r\n      root ← q.dequeue()\r\n    else\r\n      root ← ø\r\n    end if\r\n  end while\r\nend BFS\r\n```\r\n\r\n## Javascript\r\n\r\nBFS can be implemented using a queue, and looping through it.\r\n\r\n```javascript\r\n// const airports = 'PHX BKK OKC JFK LAX MEX EZE HEL LOS LAP LIM'.split(' ');\r\n\r\n// const routes = [\r\n//     ['PHX', 'LAX'],\r\n//     ['PHX', 'JFK'],\r\n//     ['JFK', 'OKC'],\r\n//     ['JFK', 'HEL'],\r\n//     ['JFK', 'LOS'],\r\n//     ['MEX', 'LAX'],\r\n//     ['MEX', 'BKK'],\r\n//     ['MEX', 'LIM'],\r\n//     ['MEX', 'EZE'],\r\n//     ['LIM', 'BKK'],\r\n// ];\r\n\r\n// // The graph\r\n// const adjacencyList = new Map();\r\n\r\n// // Add node\r\n// function addNode(airport) {\r\n//     adjacencyList.set(airport, []);\r\n// }\r\n\r\n// // Add edge, undirected\r\n// function addEdge(origin, destination) {\r\n//     adjacencyList.get(origin).push(destination);\r\n//     adjacencyList.get(destination).push(origin);\r\n// }\r\n\r\n// // Create the Graph\r\n// airports.forEach(addNode);\r\n// routes.forEach(route => addEdge(...route))\r\n\r\nfunction bfs(start) {\r\n\r\n    const visited = new Set();\r\n    const queue = [start];\r\n\r\n    while (queue.length > 0) {\r\n        const airport = queue.shift(); // mutates the queue\r\n        const destinations = adjacencyList.get(airport);\r\n\r\n        for (const destination of destinations) {\r\n            if (destination === 'BKK')  {\r\n                console.log(`BFS found Bangkok!`)\r\n            }\r\n            if (!visited.has(destination)) {\r\n                visited.add(destination);\r\n                queue.push(destination);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nbfs('PHX')\r\n```\r\n\r\n## References\r\n\r\n- [Wikipedia](https://en.wikipedia.org/wiki/Breadth-first_search)\r\n- [Tree Traversals (Inorder, Preorder and Postorder)](https://www.geeksforgeeks.org/tree-traversals-inorder-preorder-and-postorder/)\r\n- [BFS vs DFS](https://www.geeksforgeeks.org/bfs-vs-dfs-binary-tree/)\r\n- https://fireship.io/courses/javascript/interview-graphs/\r\n",
      "html": "<h1 id=\"breadth-first-search-(bfs)\">Breadth-First Search (BFS) <a class=\"heading-anchor-permalink\" href=\"#breadth-first-search-(bfs)\">#</a></h1>\n<p>Breadth-first search (BFS) is an algorithm for traversing\nor searching tree or graph data structures. It starts at\nthe tree root (or some arbitrary node of a graph, sometimes\nreferred to as a ‘search key’) and explores the neighbor\nnodes first, before moving to the next level neighbors.</p>\n<p><img src=\"https://upload.wikimedia.org/wikipedia/commons/5/5d/Breadth-First-Search-Algorithm.gif\" alt=\"Algorithm Visualization\"></p>\n<h2 id=\"pseudocode\">Pseudocode <a class=\"heading-anchor-permalink\" href=\"#pseudocode\">#</a></h2>\n<pre><code class=\"language-text\">BFS(root)\n  Pre: root is the node of the BST\n  Post: the nodes in the BST have been visited in breadth first order\n  q ← queue\n  while root = ø\n    yield root.value\n    if root.left = ø\n      q.enqueue(root.left)\n    end if\n    if root.right = ø\n      q.enqueue(root.right)\n    end if\n    if !q.isEmpty()\n      root ← q.dequeue()\n    else\n      root ← ø\n    end if\n  end while\nend BFS\n</code></pre>\n<h2 id=\"javascript\">Javascript <a class=\"heading-anchor-permalink\" href=\"#javascript\">#</a></h2>\n<p>BFS can be implemented using a queue, and looping through it.</p>\n<pre><code class=\"language-javascript\">// const airports = 'PHX BKK OKC JFK LAX MEX EZE HEL LOS LAP LIM'.split(' ');\n\n// const routes = [\n//     ['PHX', 'LAX'],\n//     ['PHX', 'JFK'],\n//     ['JFK', 'OKC'],\n//     ['JFK', 'HEL'],\n//     ['JFK', 'LOS'],\n//     ['MEX', 'LAX'],\n//     ['MEX', 'BKK'],\n//     ['MEX', 'LIM'],\n//     ['MEX', 'EZE'],\n//     ['LIM', 'BKK'],\n// ];\n\n// // The graph\n// const adjacencyList = new Map();\n\n// // Add node\n// function addNode(airport) {\n//     adjacencyList.set(airport, []);\n// }\n\n// // Add edge, undirected\n// function addEdge(origin, destination) {\n//     adjacencyList.get(origin).push(destination);\n//     adjacencyList.get(destination).push(origin);\n// }\n\n// // Create the Graph\n// airports.forEach(addNode);\n// routes.forEach(route =&gt; addEdge(...route))\n\nfunction bfs(start) {\n\n    const visited = new Set();\n    const queue = [start];\n\n    while (queue.length &gt; 0) {\n        const airport = queue.shift(); // mutates the queue\n        const destinations = adjacencyList.get(airport);\n\n        for (const destination of destinations) {\n            if (destination === 'BKK')  {\n                console.log(`BFS found Bangkok!`)\n            }\n            if (!visited.has(destination)) {\n                visited.add(destination);\n                queue.push(destination);\n            }\n        }\n    }\n}\n\nbfs('PHX')\n</code></pre>\n<h2 id=\"references\">References <a class=\"heading-anchor-permalink\" href=\"#references\">#</a></h2>\n<ul>\n<li><a href=\"https://en.wikipedia.org/wiki/Breadth-first_search\">Wikipedia</a></li>\n<li><a href=\"https://www.geeksforgeeks.org/tree-traversals-inorder-preorder-and-postorder/\">Tree Traversals (Inorder, Preorder and Postorder)</a></li>\n<li><a href=\"https://www.geeksforgeeks.org/bfs-vs-dfs-binary-tree/\">BFS vs DFS</a></li>\n<li><a href=\"https://fireship.io/courses/javascript/interview-graphs/\">https://fireship.io/courses/javascript/interview-graphs/</a></li>\n</ul>\n",
      "id": 3
    },
    {
      "path": "algorithms/3-depth-first-search.md",
      "url": "algorithms/3-depth-first-search.html",
      "content": "# Depth-First Search (DFS)\r\n\r\nDepth-first search (DFS) is an algorithm for traversing or \r\nsearching tree or graph data structures. One starts at \r\nthe root (selecting some arbitrary node as the root in \r\nthe case of a graph) and explores as far as possible \r\nalong each branch before backtracking.\r\n\r\n![Algorithm Visualization](https://upload.wikimedia.org/wikipedia/commons/7/7f/Depth-First-Search.gif)\r\n\r\n## Javascript\r\n\r\nDFS can be implemented as a recursive function that traverses paths from root to leaf.\r\n\r\n```javascript\r\n// const airports = 'PHX BKK OKC JFK LAX MEX EZE HEL LOS LAP LIM'.split(' ');\r\n\r\n// const routes = [\r\n//     ['PHX', 'LAX'],\r\n//     ['PHX', 'JFK'],\r\n//     ['JFK', 'OKC'],\r\n//     ['JFK', 'HEL'],\r\n//     ['JFK', 'LOS'],\r\n//     ['MEX', 'LAX'],\r\n//     ['MEX', 'BKK'],\r\n//     ['MEX', 'LIM'],\r\n//     ['MEX', 'EZE'],\r\n//     ['LIM', 'BKK'],\r\n// ];\r\n\r\n// // The graph\r\n// const adjacencyList = new Map();\r\n\r\n// // Add node\r\n// function addNode(airport) {\r\n//     adjacencyList.set(airport, []);\r\n// }\r\n\r\n// // Add edge, undirected\r\n// function addEdge(origin, destination) {\r\n//     adjacencyList.get(origin).push(destination);\r\n//     adjacencyList.get(destination).push(origin);\r\n// }\r\n\r\n// // Create the Graph\r\n// airports.forEach(addNode);\r\n// routes.forEach(route => addEdge(...route))\r\n\r\nfunction dfs(start, visited = new Set()) {\r\n    visited.add(start);\r\n    const destinations = adjacencyList.get(start);\r\n\r\n    for (const destination of destinations) {\r\n        if (destination === 'BKK') { \r\n            console.log(`DFS found Bangkok`)\r\n            return;\r\n        }\r\n        if (!visited.has(destination)) {\r\n            dfs(destination, visited);\r\n        }\r\n    }\r\n}\r\n\r\ndfs('PHX')\r\n```\r\n\r\n## References\r\n\r\n- [Wikipedia](https://en.wikipedia.org/wiki/Depth-first_search)\r\n- [Tree Traversals (Inorder, Preorder and Postorder)](https://www.geeksforgeeks.org/tree-traversals-inorder-preorder-and-postorder/)\r\n- [BFS vs DFS](https://www.geeksforgeeks.org/bfs-vs-dfs-binary-tree/)\r\n- https://fireship.io/courses/javascript/interview-graphs/\r\n",
      "html": "<h1 id=\"depth-first-search-(dfs)\">Depth-First Search (DFS) <a class=\"heading-anchor-permalink\" href=\"#depth-first-search-(dfs)\">#</a></h1>\n<p>Depth-first search (DFS) is an algorithm for traversing or\nsearching tree or graph data structures. One starts at\nthe root (selecting some arbitrary node as the root in\nthe case of a graph) and explores as far as possible\nalong each branch before backtracking.</p>\n<p><img src=\"https://upload.wikimedia.org/wikipedia/commons/7/7f/Depth-First-Search.gif\" alt=\"Algorithm Visualization\"></p>\n<h2 id=\"javascript\">Javascript <a class=\"heading-anchor-permalink\" href=\"#javascript\">#</a></h2>\n<p>DFS can be implemented as a recursive function that traverses paths from root to leaf.</p>\n<pre><code class=\"language-javascript\">// const airports = 'PHX BKK OKC JFK LAX MEX EZE HEL LOS LAP LIM'.split(' ');\n\n// const routes = [\n//     ['PHX', 'LAX'],\n//     ['PHX', 'JFK'],\n//     ['JFK', 'OKC'],\n//     ['JFK', 'HEL'],\n//     ['JFK', 'LOS'],\n//     ['MEX', 'LAX'],\n//     ['MEX', 'BKK'],\n//     ['MEX', 'LIM'],\n//     ['MEX', 'EZE'],\n//     ['LIM', 'BKK'],\n// ];\n\n// // The graph\n// const adjacencyList = new Map();\n\n// // Add node\n// function addNode(airport) {\n//     adjacencyList.set(airport, []);\n// }\n\n// // Add edge, undirected\n// function addEdge(origin, destination) {\n//     adjacencyList.get(origin).push(destination);\n//     adjacencyList.get(destination).push(origin);\n// }\n\n// // Create the Graph\n// airports.forEach(addNode);\n// routes.forEach(route =&gt; addEdge(...route))\n\nfunction dfs(start, visited = new Set()) {\n    visited.add(start);\n    const destinations = adjacencyList.get(start);\n\n    for (const destination of destinations) {\n        if (destination === 'BKK') { \n            console.log(`DFS found Bangkok`)\n            return;\n        }\n        if (!visited.has(destination)) {\n            dfs(destination, visited);\n        }\n    }\n}\n\ndfs('PHX')\n</code></pre>\n<h2 id=\"references\">References <a class=\"heading-anchor-permalink\" href=\"#references\">#</a></h2>\n<ul>\n<li><a href=\"https://en.wikipedia.org/wiki/Depth-first_search\">Wikipedia</a></li>\n<li><a href=\"https://www.geeksforgeeks.org/tree-traversals-inorder-preorder-and-postorder/\">Tree Traversals (Inorder, Preorder and Postorder)</a></li>\n<li><a href=\"https://www.geeksforgeeks.org/bfs-vs-dfs-binary-tree/\">BFS vs DFS</a></li>\n<li><a href=\"https://fireship.io/courses/javascript/interview-graphs/\">https://fireship.io/courses/javascript/interview-graphs/</a></li>\n</ul>\n",
      "id": 4
    },
    {
      "path": "algorithms/4-dijkstras-algo.md",
      "url": "algorithms/4-dijkstras-algo.html",
      "content": "# Dijkstra's Algorithm\r\n\r\nDijkstra's algorithm is an algorithm for finding the shortest \r\npaths between nodes in a graph, which may represent, for example, \r\nroad networks. \r\n\r\nThe algorithm exists in many variants; Dijkstra's original variant \r\nfound the shortest path between two nodes, but a more common \r\nvariant fixes a single node as the \"source\" node and finds \r\nshortest paths from the source to all other nodes in the graph, \r\nproducing a shortest-path tree.\r\n\r\n![Dijkstra](https://upload.wikimedia.org/wikipedia/commons/5/57/Dijkstra_Animation.gif)\r\n\r\nDijkstra's algorithm to find the shortest path between `a` and `b`.\r\nIt picks the unvisited vertex with the lowest distance, \r\ncalculates the distance through it to each unvisited neighbor, \r\nand updates the neighbor's distance if smaller. Mark visited\r\n(set to red) when done with neighbors.\r\n\r\n## References\r\n\r\n- [Wikipedia](https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm)\r\n- [On YouTube by Nathaniel Fan](https://www.youtube.com/watch?v=gdmfOwyQlcI&list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8)\r\n- [On YouTube by Tushar Roy](https://www.youtube.com/watch?v=lAXZGERcDf4&list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8)\r\n",
      "html": "<h1 id=\"dijkstra%E2%80%99s-algorithm\">Dijkstra’s Algorithm <a class=\"heading-anchor-permalink\" href=\"#dijkstra%E2%80%99s-algorithm\">#</a></h1>\n<p>Dijkstra’s algorithm is an algorithm for finding the shortest\npaths between nodes in a graph, which may represent, for example,\nroad networks.</p>\n<p>The algorithm exists in many variants; Dijkstra’s original variant\nfound the shortest path between two nodes, but a more common\nvariant fixes a single node as the “source” node and finds\nshortest paths from the source to all other nodes in the graph,\nproducing a shortest-path tree.</p>\n<p><img src=\"https://upload.wikimedia.org/wikipedia/commons/5/57/Dijkstra_Animation.gif\" alt=\"Dijkstra\"></p>\n<p>Dijkstra’s algorithm to find the shortest path between <code>a</code> and <code>b</code>.\nIt picks the unvisited vertex with the lowest distance,\ncalculates the distance through it to each unvisited neighbor,\nand updates the neighbor’s distance if smaller. Mark visited\n(set to red) when done with neighbors.</p>\n<h2 id=\"references\">References <a class=\"heading-anchor-permalink\" href=\"#references\">#</a></h2>\n<ul>\n<li><a href=\"https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm\">Wikipedia</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=gdmfOwyQlcI&amp;list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8\">On YouTube by Nathaniel Fan</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=lAXZGERcDf4&amp;list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8\">On YouTube by Tushar Roy</a></li>\n</ul>\n",
      "id": 5
    },
    {
      "path": "algorithms/5-mergesort.md",
      "url": "algorithms/5-mergesort.html",
      "content": "# Merge Sort\r\n\r\nIn computer science, merge sort (also commonly spelled \r\nmergesort) is an efficient, general-purpose, \r\ncomparison-based sorting algorithm. Most implementations \r\nproduce a stable sort, which means that the implementation \r\npreserves the input order of equal elements in the sorted \r\noutput. Mergesort is a divide and conquer algorithm that \r\nwas invented by John von Neumann in 1945.\r\n\r\nAn example of merge sort. First divide the list into \r\nthe smallest unit (1 element), then compare each \r\nelement with the adjacent list to sort and merge the \r\ntwo adjacent lists. Finally all the elements are sorted \r\nand merged.\r\n\r\n![Merge Sort](https://upload.wikimedia.org/wikipedia/commons/c/cc/Merge-sort-example-300px.gif)\r\n\r\nA recursive merge sort algorithm used to sort an array of 7 \r\ninteger values. These are the steps a human would take to \r\nemulate merge sort (top-down).\r\n\r\n![Merge Sort](https://upload.wikimedia.org/wikipedia/commons/e/e6/Merge_sort_algorithm_diagram.svg)\r\n\r\n## The Efficiency of Merge Sort\r\n\r\nThe worst-case time complexity of Merge Sort is O(nlogn), same as that for best case time complexity for Quick Sort. When it comes to speed, Merge Sort is one of the fastest sorting algorithms out there.\r\n\r\nUnlike Quick Sort, Merge Sort is not an in-place sorting algorithm, meaning it takes extra space other than the input array. This is because we are using auxiliary (helper) arrays to store the sub-arrays. The space complexity of the merge sort is O(n).\r\n\r\nAnother advantage of Merge Sort is that it lends itself very well to multi-threading, since each respective half and be sorted on its own. Another common way of reducing the runtime of Merge Sort is to stop when we get to relatively small subarrays (~7) and using Insertion Sort to sort them.\r\n\r\n## Javascript\r\n\r\n```javascript\r\nconst unsortedArr = [31, 27, 28, 42, 13, 8, 11, 30, 17, 41, 15, 43, 1, 36, 9, 16, 20, 35, 48, 37, 7, 26, 34, 21, 22, 6, 29, 32, 49, 10, 12, 19, 24, 38, 5, 14, 44, 40, 3, 50, 46, 25, 18, 33, 47, 4, 45, 39, 23, 2];\r\n\r\nconst merge = (arr1, arr2) => {\r\n  let sorted = [];\r\n\r\n  while (arr1.length && arr2.length) {\r\n    if (arr1[0] < arr2[0]) sorted.push(arr1.shift());\r\n    else sorted.push(arr2.shift());\r\n  };\r\n\r\n  return sorted.concat(arr1.slice().concat(arr2.slice()));\r\n};\r\n\r\nconst mergeSort = arr => {\r\n  if (arr.length <= 1) return arr;\r\n  let mid = Math.floor(arr.length / 2),\r\n      left = mergeSort(arr.slice(0, mid)),\r\n      right = mergeSort(arr.slice(mid));\r\n\r\n  return merge(left, right); \r\n};\r\n\r\nmergeSort(unsortedArr);\r\n```\r\n\r\n## Complexity\r\n\r\n| Name                  | Best            | Average             | Worst               | Memory    | Stable    | Comments  |\r\n| --------------------- | :-------------: | :-----------------: | :-----------------: | :-------: | :-------: | :-------- |\r\n| **Merge sort**        | n&nbsp;log(n)   | n&nbsp;log(n)       | n&nbsp;log(n)       | n         | Yes       |           |\r\n\r\n## References\r\n\r\n- [Wikipedia](https://en.wikipedia.org/wiki/Merge_sort)\r\n- [YouTube](https://www.youtube.com/watch?v=KF2j-9iSf4Q&index=27&list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8)\r\n",
      "html": "<h1 id=\"merge-sort\">Merge Sort <a class=\"heading-anchor-permalink\" href=\"#merge-sort\">#</a></h1>\n<p>In computer science, merge sort (also commonly spelled\nmergesort) is an efficient, general-purpose,\ncomparison-based sorting algorithm. Most implementations\nproduce a stable sort, which means that the implementation\npreserves the input order of equal elements in the sorted\noutput. Mergesort is a divide and conquer algorithm that\nwas invented by John von Neumann in 1945.</p>\n<p>An example of merge sort. First divide the list into\nthe smallest unit (1 element), then compare each\nelement with the adjacent list to sort and merge the\ntwo adjacent lists. Finally all the elements are sorted\nand merged.</p>\n<p><img src=\"https://upload.wikimedia.org/wikipedia/commons/c/cc/Merge-sort-example-300px.gif\" alt=\"Merge Sort\"></p>\n<p>A recursive merge sort algorithm used to sort an array of 7\ninteger values. These are the steps a human would take to\nemulate merge sort (top-down).</p>\n<p><img src=\"https://upload.wikimedia.org/wikipedia/commons/e/e6/Merge_sort_algorithm_diagram.svg\" alt=\"Merge Sort\"></p>\n<h2 id=\"the-efficiency-of-merge-sort\">The Efficiency of Merge Sort <a class=\"heading-anchor-permalink\" href=\"#the-efficiency-of-merge-sort\">#</a></h2>\n<p>The worst-case time complexity of Merge Sort is O(nlogn), same as that for best case time complexity for Quick Sort. When it comes to speed, Merge Sort is one of the fastest sorting algorithms out there.</p>\n<p>Unlike Quick Sort, Merge Sort is not an in-place sorting algorithm, meaning it takes extra space other than the input array. This is because we are using auxiliary (helper) arrays to store the sub-arrays. The space complexity of the merge sort is O(n).</p>\n<p>Another advantage of Merge Sort is that it lends itself very well to multi-threading, since each respective half and be sorted on its own. Another common way of reducing the runtime of Merge Sort is to stop when we get to relatively small subarrays (~7) and using Insertion Sort to sort them.</p>\n<h2 id=\"javascript\">Javascript <a class=\"heading-anchor-permalink\" href=\"#javascript\">#</a></h2>\n<pre><code class=\"language-javascript\">const unsortedArr = [31, 27, 28, 42, 13, 8, 11, 30, 17, 41, 15, 43, 1, 36, 9, 16, 20, 35, 48, 37, 7, 26, 34, 21, 22, 6, 29, 32, 49, 10, 12, 19, 24, 38, 5, 14, 44, 40, 3, 50, 46, 25, 18, 33, 47, 4, 45, 39, 23, 2];\n\nconst merge = (arr1, arr2) =&gt; {\n  let sorted = [];\n\n  while (arr1.length &amp;&amp; arr2.length) {\n    if (arr1[0] &lt; arr2[0]) sorted.push(arr1.shift());\n    else sorted.push(arr2.shift());\n  };\n\n  return sorted.concat(arr1.slice().concat(arr2.slice()));\n};\n\nconst mergeSort = arr =&gt; {\n  if (arr.length &lt;= 1) return arr;\n  let mid = Math.floor(arr.length / 2),\n      left = mergeSort(arr.slice(0, mid)),\n      right = mergeSort(arr.slice(mid));\n\n  return merge(left, right); \n};\n\nmergeSort(unsortedArr);\n</code></pre>\n<h2 id=\"complexity\">Complexity <a class=\"heading-anchor-permalink\" href=\"#complexity\">#</a></h2>\n<table>\n<thead>\n<tr>\n<th>Name</th>\n<th style=\"text-align:center\">Best</th>\n<th style=\"text-align:center\">Average</th>\n<th style=\"text-align:center\">Worst</th>\n<th style=\"text-align:center\">Memory</th>\n<th style=\"text-align:center\">Stable</th>\n<th style=\"text-align:left\">Comments</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>Merge sort</strong></td>\n<td style=\"text-align:center\">n log(n)</td>\n<td style=\"text-align:center\">n log(n)</td>\n<td style=\"text-align:center\">n log(n)</td>\n<td style=\"text-align:center\">n</td>\n<td style=\"text-align:center\">Yes</td>\n<td style=\"text-align:left\"></td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"references\">References <a class=\"heading-anchor-permalink\" href=\"#references\">#</a></h2>\n<ul>\n<li><a href=\"https://en.wikipedia.org/wiki/Merge_sort\">Wikipedia</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=KF2j-9iSf4Q&amp;index=27&amp;list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8\">YouTube</a></li>\n</ul>\n",
      "id": 6
    },
    {
      "path": "algorithms/6-quicksort.md",
      "url": "algorithms/6-quicksort.html",
      "content": "# Quicksort\r\n\r\nQuicksort is a divide and conquer algorithm.\r\nQuicksort first divides a large array into two smaller \r\nsub-arrays: the low elements and the high elements.\r\nQuicksort can then recursively sort the sub-arrays\r\n\r\nThe steps are:\r\n\r\n1. Pick an element, called a pivot, from the array.\r\n2. Partitioning: reorder the array so that all elements with \r\nvalues less than the pivot come before the pivot, while all \r\nelements with values greater than the pivot come after it \r\n(equal values can go either way). After this partitioning, \r\nthe pivot is in its final position. This is called the \r\npartition operation.\r\n3. Recursively apply the above steps to the sub-array of \r\nelements with smaller values and separately to the \r\nsub-array of elements with greater values.\r\n\r\nAnimated visualization of the quicksort algorithm.\r\nThe horizontal lines are pivot values.\r\n\r\n![Quicksort](https://upload.wikimedia.org/wikipedia/commons/6/6a/Sorting_quicksort_anim.gif)\r\n\r\nOne problem of working with merge sorts is that they need to create and store so many arrays in memory with mostly the redundant data. If we’re limited on memory, we can resort to a quick sort to run it “in place”, meaning the changes and results all happen directly with what’s being sorted, thus saving on memory.\r\n\r\n## Javascript\r\n\r\n```javascript\r\nconst unsortedArr = [31, 27, 28, 42, 13, 8, 11, 30, 17, 41, 15, 43, 1, 36, 9, 16, 20, 35, 48, 37, 7, 26, 34, 21, 22, 6, 29, 32, 49, 10, 12, 19, 24, 38, 5, 14, 44, 40, 3, 50, 46, 25, 18, 33, 47, 4, 45, 39, 23, 2];\r\n\r\nconst pivot = (arr, start = 0, end = arr.length + 1) => {\r\n  const swap = (list, a, b) => [list[a], list[b]] = [list[b], list[a]];\r\n\r\n  let pivot = arr[start],\r\n      pointer = start;\r\n\r\n  for (let i = start; i < arr.length; i++) {\r\n    if (arr[i] < pivot  ) {\r\n      pointer++;\r\n      swap(arr, pointer, i);\r\n    }\r\n  };\r\n  swap(arr, start, pointer);\r\n\r\n  return pointer;\r\n}\r\n\r\nconst quickSort = (arr, start = 0, end = arr.length) => {\r\n  let pivotIndex = pivot(arr, start, end);\r\n\r\n  if (start >= end) return arr;\r\n  quickSort(arr, start, pivotIndex);\r\n  quickSort(arr, pivotIndex + 1, end);\r\n\r\n  return arr;\r\n};\r\n\r\nquickSort(unsortedArr);\r\n```\r\n\r\n## Complexity\r\n\r\n| Name                  | Best            | Average             | Worst               | Memory    | Stable    | Comments  |\r\n| --------------------- | :-------------: | :-----------------: | :-----------------: | :-------: | :-------: | :-------- |\r\n| **Quick sort**        | n&nbsp;log(n)   | n&nbsp;log(n)       | n<sup>2</sup>       | log(n)    | No        |  Quicksort is usually done in-place with O(log(n)) stack space |\r\n\r\n## References\r\n\r\n- [Wikipedia](https://en.wikipedia.org/wiki/Quicksort)\r\n- [YouTube](https://www.youtube.com/watch?v=SLauY6PpjW4&index=28&list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8)\r\n",
      "html": "<h1 id=\"quicksort\">Quicksort <a class=\"heading-anchor-permalink\" href=\"#quicksort\">#</a></h1>\n<p>Quicksort is a divide and conquer algorithm.\nQuicksort first divides a large array into two smaller\nsub-arrays: the low elements and the high elements.\nQuicksort can then recursively sort the sub-arrays</p>\n<p>The steps are:</p>\n<ol>\n<li>Pick an element, called a pivot, from the array.</li>\n<li>Partitioning: reorder the array so that all elements with\nvalues less than the pivot come before the pivot, while all\nelements with values greater than the pivot come after it\n(equal values can go either way). After this partitioning,\nthe pivot is in its final position. This is called the\npartition operation.</li>\n<li>Recursively apply the above steps to the sub-array of\nelements with smaller values and separately to the\nsub-array of elements with greater values.</li>\n</ol>\n<p>Animated visualization of the quicksort algorithm.\nThe horizontal lines are pivot values.</p>\n<p><img src=\"https://upload.wikimedia.org/wikipedia/commons/6/6a/Sorting_quicksort_anim.gif\" alt=\"Quicksort\"></p>\n<p>One problem of working with merge sorts is that they need to create and store so many arrays in memory with mostly the redundant data. If we’re limited on memory, we can resort to a quick sort to run it “in place”, meaning the changes and results all happen directly with what’s being sorted, thus saving on memory.</p>\n<h2 id=\"javascript\">Javascript <a class=\"heading-anchor-permalink\" href=\"#javascript\">#</a></h2>\n<pre><code class=\"language-javascript\">const unsortedArr = [31, 27, 28, 42, 13, 8, 11, 30, 17, 41, 15, 43, 1, 36, 9, 16, 20, 35, 48, 37, 7, 26, 34, 21, 22, 6, 29, 32, 49, 10, 12, 19, 24, 38, 5, 14, 44, 40, 3, 50, 46, 25, 18, 33, 47, 4, 45, 39, 23, 2];\n\nconst pivot = (arr, start = 0, end = arr.length + 1) =&gt; {\n  const swap = (list, a, b) =&gt; [list[a], list[b]] = [list[b], list[a]];\n\n  let pivot = arr[start],\n      pointer = start;\n\n  for (let i = start; i &lt; arr.length; i++) {\n    if (arr[i] &lt; pivot  ) {\n      pointer++;\n      swap(arr, pointer, i);\n    }\n  };\n  swap(arr, start, pointer);\n\n  return pointer;\n}\n\nconst quickSort = (arr, start = 0, end = arr.length) =&gt; {\n  let pivotIndex = pivot(arr, start, end);\n\n  if (start &gt;= end) return arr;\n  quickSort(arr, start, pivotIndex);\n  quickSort(arr, pivotIndex + 1, end);\n\n  return arr;\n};\n\nquickSort(unsortedArr);\n</code></pre>\n<h2 id=\"complexity\">Complexity <a class=\"heading-anchor-permalink\" href=\"#complexity\">#</a></h2>\n<table>\n<thead>\n<tr>\n<th>Name</th>\n<th style=\"text-align:center\">Best</th>\n<th style=\"text-align:center\">Average</th>\n<th style=\"text-align:center\">Worst</th>\n<th style=\"text-align:center\">Memory</th>\n<th style=\"text-align:center\">Stable</th>\n<th style=\"text-align:left\">Comments</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>Quick sort</strong></td>\n<td style=\"text-align:center\">n log(n)</td>\n<td style=\"text-align:center\">n log(n)</td>\n<td style=\"text-align:center\">n<sup>2</sup></td>\n<td style=\"text-align:center\">log(n)</td>\n<td style=\"text-align:center\">No</td>\n<td style=\"text-align:left\">Quicksort is usually done in-place with O(log(n)) stack space</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"references\">References <a class=\"heading-anchor-permalink\" href=\"#references\">#</a></h2>\n<ul>\n<li><a href=\"https://en.wikipedia.org/wiki/Quicksort\">Wikipedia</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=SLauY6PpjW4&amp;index=28&amp;list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8\">YouTube</a></li>\n</ul>\n",
      "id": 7
    },
    {
      "path": "algorithms/7-heapsort.md",
      "url": "algorithms/7-heapsort.html",
      "content": "# Heapsort\r\n\r\n> Heap Sort is an in-place, non-stable, comparison-based sorting algorithm.\r\n\r\nThe heapsort algorithm can be divided into two parts.\r\n\r\nIn the first step, a heap is built out of the data (see Binary heap § Building a heap). The heap is often placed in an array with the layout of a complete binary tree. The complete binary tree maps the binary tree structure into the array indices; each array index represents a node; the index of the node's parent, left child branch, or right child branch are simple expressions. For a zero-based array, the root node is stored at index 0; if i is the index of the current node, then\r\n\r\n```\r\n  iParent(i)     = floor((i-1) / 2) where floor functions map a real number to the largest leading integer.\r\n  iLeftChild(i)  = 2*i + 1\r\n  iRightChild(i) = 2*i + 2\r\n```\r\n\r\nIn the second step, a sorted array is created by repeatedly removing the largest element from the heap (the root of the heap), and inserting it into the array. The heap is updated after each removal to maintain the heap property. Once all objects have been removed from the heap, the result is a sorted array.\r\n\r\nHeapsort can be performed in place. The array can be split into two parts, the sorted array and the heap. The storage of heaps as arrays is diagrammed here. The heap's invariant is preserved after each extraction, so the only cost is that of extraction.\r\n\r\n## Javascript\r\n\r\n### Mapping a Heap to an Array\r\n\r\nWhat we have defined and depicted as a heap up until this point is merely a diagram, a collection of circles and lines. To use this structure in a JavaScript-based computer program, we need to rework it into an array or a list.\r\n\r\nLuckily, this is a fairly straightforward operation that mimics the way we build the heap in the first place. We read and shift the elements off of the heap into an array in the same order we have placed them into the heap: from left to right and level by level.\r\n \r\n```javascript\r\nclass MaxHeap{\r\n    constructor(){\r\n        this.heap = [];\r\n    }\r\n\r\n    parentIndex(index){\r\n        return Math.floor((index-1)/2);\r\n    }\r\n\r\n    leftChildIndex(index){\r\n        return (2*index + 1);\r\n    }\r\n\r\n    rightChildIndex(index){\r\n        return (2*index + 2);\r\n    }\r\n\r\n    swap(a, b) {\r\n        let temp = this.heap[a];\r\n        this.heap[a] = this.heap[b];\r\n        this.heap[b] = temp;\r\n    }\r\n\r\n    insert(item) {\r\n        this.heap.push(item);\r\n        var index = this.heap.length - 1;\r\n        var parent = this.parentIndex(index);\r\n        while(this.heap[parent] && this.heap[parent] < this.heap[index]) {\r\n            this.swap(parent, index);\r\n            index = this.parentIndex(index);\r\n            parent = this.parentIndex(index);\r\n        }\r\n    }\r\n\r\n    delete() {\r\n      var item = this.heap.shift();\r\n      this.heap.unshift(this.heap.pop());\r\n      var index = 0;\r\n      var leftChild = this.leftChildIndex(index);\r\n      var rightChild = this.rightChildIndex(index);\r\n      while(this.heap[leftChild] && this.heap[leftChild] > this.heap[index] || this.heap[rightChild] > this.heap[index]){\r\n          var max = leftChild;\r\n          if(this.heap[rightChild] && this.heap[rightChild] > this.heap[max]){\r\n              max = rightChild\r\n          }\r\n          this.swap(max, index);\r\n          index = max;\r\n          leftChild = this.leftChildIndex(max);\r\n          rightChild = this.rightChildIndex(max);\r\n      }\r\n      return item;\r\n  }\r\n}\r\n\r\nconst heapSort = (arr) => {\r\n    var sorted = [];\r\n    var heap1 = new MaxHeap();\r\n    \r\n    for(let i=0; i<arr.length; i++){\r\n        heap1.insert(arr[i]);\r\n    }\r\n    \r\n    for(let i=0; i<arr.length; i++){\r\n        sorted.push(heap1.delete());\r\n    }\r\n    return sorted;\r\n}\r\n```\r\n",
      "html": "<h1 id=\"heapsort\">Heapsort <a class=\"heading-anchor-permalink\" href=\"#heapsort\">#</a></h1>\n<blockquote>\n<p>Heap Sort is an in-place, non-stable, comparison-based sorting algorithm.</p>\n</blockquote>\n<p>The heapsort algorithm can be divided into two parts.</p>\n<p>In the first step, a heap is built out of the data (see Binary heap § Building a heap). The heap is often placed in an array with the layout of a complete binary tree. The complete binary tree maps the binary tree structure into the array indices; each array index represents a node; the index of the node’s parent, left child branch, or right child branch are simple expressions. For a zero-based array, the root node is stored at index 0; if i is the index of the current node, then</p>\n<pre><code>  iParent(i)     = floor((i-1) / 2) where floor functions map a real number to the largest leading integer.\n  iLeftChild(i)  = 2*i + 1\n  iRightChild(i) = 2*i + 2\n</code></pre>\n<p>In the second step, a sorted array is created by repeatedly removing the largest element from the heap (the root of the heap), and inserting it into the array. The heap is updated after each removal to maintain the heap property. Once all objects have been removed from the heap, the result is a sorted array.</p>\n<p>Heapsort can be performed in place. The array can be split into two parts, the sorted array and the heap. The storage of heaps as arrays is diagrammed here. The heap’s invariant is preserved after each extraction, so the only cost is that of extraction.</p>\n<h2 id=\"javascript\">Javascript <a class=\"heading-anchor-permalink\" href=\"#javascript\">#</a></h2>\n<h3 id=\"mapping-a-heap-to-an-array\">Mapping a Heap to an Array <a class=\"heading-anchor-permalink\" href=\"#mapping-a-heap-to-an-array\">#</a></h3>\n<p>What we have defined and depicted as a heap up until this point is merely a diagram, a collection of circles and lines. To use this structure in a JavaScript-based computer program, we need to rework it into an array or a list.</p>\n<p>Luckily, this is a fairly straightforward operation that mimics the way we build the heap in the first place. We read and shift the elements off of the heap into an array in the same order we have placed them into the heap: from left to right and level by level.</p>\n<pre><code class=\"language-javascript\">class MaxHeap{\n    constructor(){\n        this.heap = [];\n    }\n\n    parentIndex(index){\n        return Math.floor((index-1)/2);\n    }\n\n    leftChildIndex(index){\n        return (2*index + 1);\n    }\n\n    rightChildIndex(index){\n        return (2*index + 2);\n    }\n\n    swap(a, b) {\n        let temp = this.heap[a];\n        this.heap[a] = this.heap[b];\n        this.heap[b] = temp;\n    }\n\n    insert(item) {\n        this.heap.push(item);\n        var index = this.heap.length - 1;\n        var parent = this.parentIndex(index);\n        while(this.heap[parent] &amp;&amp; this.heap[parent] &lt; this.heap[index]) {\n            this.swap(parent, index);\n            index = this.parentIndex(index);\n            parent = this.parentIndex(index);\n        }\n    }\n\n    delete() {\n      var item = this.heap.shift();\n      this.heap.unshift(this.heap.pop());\n      var index = 0;\n      var leftChild = this.leftChildIndex(index);\n      var rightChild = this.rightChildIndex(index);\n      while(this.heap[leftChild] &amp;&amp; this.heap[leftChild] &gt; this.heap[index] || this.heap[rightChild] &gt; this.heap[index]){\n          var max = leftChild;\n          if(this.heap[rightChild] &amp;&amp; this.heap[rightChild] &gt; this.heap[max]){\n              max = rightChild\n          }\n          this.swap(max, index);\n          index = max;\n          leftChild = this.leftChildIndex(max);\n          rightChild = this.rightChildIndex(max);\n      }\n      return item;\n  }\n}\n\nconst heapSort = (arr) =&gt; {\n    var sorted = [];\n    var heap1 = new MaxHeap();\n    \n    for(let i=0; i&lt;arr.length; i++){\n        heap1.insert(arr[i]);\n    }\n    \n    for(let i=0; i&lt;arr.length; i++){\n        sorted.push(heap1.delete());\n    }\n    return sorted;\n}\n</code></pre>\n",
      "id": 8
    },
    {
      "path": "graphs-and-trees/1-binary-search-tree.md",
      "url": "graphs-and-trees/1-binary-search-tree.html",
      "content": "# Binary Search Tree\r\n\r\nIn computer science, **binary search trees** (BST), sometimes called \r\nordered or sorted binary trees, are a particular type of container: \r\ndata structures that store \"items\" (such as numbers, names etc.) \r\nin memory. They allow fast lookup, addition and removal of \r\nitems, and can be used to implement either dynamic sets of \r\nitems, or lookup tables that allow finding an item by its key \r\n(e.g., finding the phone number of a person by name).\r\n\r\nBinary search trees keep their keys in sorted order, so that lookup \r\nand other operations can use the principle of binary search: \r\nwhen looking for a key in a tree (or a place to insert a new key), \r\nthey traverse the tree from root to leaf, making comparisons to \r\nthe operations to skip about half of the tree, so that each \r\nlookup, insertion or deletion takes time proportional to the \r\nlogarithm of the number of items stored in the tree. This is \r\nmuch better than the linear time required to find items by key \r\nin an (unsorted) array, but slower than the corresponding \r\noperations on hash tables.\r\n\r\nA binary search tree of size 9 and depth 3, with 8 at the root.\r\nThe leaves are not drawn.\r\n\r\n![Binary Search Tree](https://upload.wikimedia.org/wikipedia/commons/d/da/Binary_search_tree.svg)\r\n\r\n## Typescript\r\n\r\n```typescript\r\nclass TreeNode {\r\n    data: number;\r\n    left: TreeNode;\r\n    right: TreeNode;\r\n\r\n    constructor(data: number, left: TreeNode = null, right: TreeNode = null) {\r\n        this.data = data;\r\n        this.left = left;\r\n        this.right = right;\r\n    }\r\n}\r\n\r\nclass BinarySearchTree {\r\n    root: TreeNode;\r\n    \r\n    constructor() {\r\n        this.root = null;\r\n    }\r\n    \r\n    insert(data: number) {\r\n        const searchTree = (node: TreeNode) => {\r\n            if (data < node.data && node.left) {\r\n                searchTree(node.left);\r\n            } else if (data < node.data) {\r\n                node.left = new TreeNode(data);\r\n            } else if (data > node.data && node.right) {\r\n                searchTree(node.right);\r\n            } else if (data > node.data) {\r\n                node.right = new TreeNode(data);\r\n            }\r\n        }\r\n\r\n        if (this.root === null) {\r\n            this.root = new TreeNode(data);\r\n        } else {\r\n            const node = this.root;\r\n            searchTree(node);\r\n        }\r\n    }\r\n    \r\n    getDepth(): number {\r\n        if (this.root === null) {\r\n            return 0;\r\n        }\r\n        \r\n        const traverseForDepth = (node: TreeNode, depth: number = 0): number => {\r\n            if(node.left === null && node.right === null) {\r\n                return depth;\r\n            } else if(node.left && node.right) {\r\n                const leftRes = traverseForDepth(node.left, depth + 1);\r\n                const rightRes = traverseForDepth(node.right, depth + 1);\r\n                return leftRes > rightRes ? leftRes : rightRes;\r\n            } else if(node.left && node.right === null) {\r\n                return traverseForDepth(node.left, depth + 1);\r\n            } else if(node.left === null && node.right) {\r\n                return traverseForDepth(node.right, depth + 1);\r\n            } \r\n        }\r\n        \r\n        return traverseForDepth(this.root, 0);\r\n    }\r\n}\r\n```\r\n\r\n## Pseudocode for Basic Operations\r\n\r\n### Insertion\r\n\r\n```text\r\ninsert(value)\r\n  Pre: value has passed custom type checks for type T\r\n  Post: value has been placed in the correct location in the tree\r\n  if root = ø\r\n    root ← node(value)\r\n  else\r\n    insertNode(root, value)\r\n  end if\r\nend insert\r\n```\r\n    \r\n```text\r\ninsertNode(current, value)\r\n  Pre: current is the node to start from\r\n  Post: value has been placed in the correct location in the tree\r\n  if value < current.value\r\n    if current.left = ø\r\n      current.left ← node(value)\r\n    else\r\n      InsertNode(current.left, value)\r\n    end if\r\n  else\r\n    if current.right = ø\r\n      current.right ← node(value)\r\n    else\r\n      InsertNode(current.right, value)\r\n    end if\r\n  end if\r\nend insertNode\r\n```\r\n\r\n### Searching\r\n\r\n```text\r\ncontains(root, value)\r\n  Pre: root is the root node of the tree, value is what we would like to locate\r\n  Post: value is either located or not\r\n  if root = ø\r\n    return false\r\n  end if\r\n  if root.value = value\r\n    return true\r\n  else if value < root.value\r\n    return contains(root.left, value)\r\n  else\r\n    return contains(root.right, value)\r\n  end if\r\nend contains\r\n```\r\n    \r\n     \r\n### Deletion\r\n\r\n```text\r\nremove(value)\r\n  Pre: value is the value of the node to remove, root is the node of the BST\r\n      count is the number of items in the BST\r\n  Post: node with value is removed if found in which case yields true, otherwise false\r\n  nodeToRemove ← findNode(value)\r\n  if nodeToRemove = ø\r\n    return false\r\n  end if\r\n  parent ← findParent(value)\r\n  if count = 1\r\n    root ← ø\r\n  else if nodeToRemove.left = ø and nodeToRemove.right = ø\r\n    if nodeToRemove.value < parent.value\r\n      parent.left ←  nodeToRemove.right\r\n    else\r\n      parent.right ← nodeToRemove.right\r\n    end if\r\n  else if nodeToRemove.left != ø and nodeToRemove.right != ø\r\n    next ← nodeToRemove.right\r\n    while next.left != ø\r\n      next ← next.left\r\n    end while\r\n    if next != nodeToRemove.right\r\n      remove(next.value)\r\n      nodeToRemove.value ← next.value\r\n    else\r\n      nodeToRemove.value ← next.value\r\n      nodeToRemove.right ← nodeToRemove.right.right\r\n    end if\r\n  else\r\n    if nodeToRemove.left = ø\r\n      next ← nodeToRemove.right\r\n    else\r\n      next ← nodeToRemove.left\r\n    end if\r\n    if root = nodeToRemove\r\n      root = next\r\n    else if parent.left = nodeToRemove\r\n      parent.left = next\r\n    else if parent.right = nodeToRemove\r\n      parent.right = next\r\n    end if\r\n  end if\r\n  count ← count - 1\r\n  return true\r\nend remove\r\n```\r\n\r\n### Find Parent of Node\r\n\r\n```text\r\nfindParent(value, root)\r\n  Pre: value is the value of the node we want to find the parent of\r\n       root is the root node of the BST and is != ø\r\n  Post: a reference to the prent node of value if found; otherwise ø\r\n  if value = root.value\r\n    return ø\r\n  end if\r\n  if value < root.value\r\n    if root.left = ø\r\n      return ø\r\n    else if root.left.value = value\r\n      return root\r\n    else\r\n      return findParent(value, root.left)\r\n    end if\r\n  else\r\n    if root.right = ø\r\n      return ø\r\n    else if root.right.value = value\r\n      return root\r\n    else\r\n      return findParent(value, root.right)\r\n    end if\r\n  end if\r\nend findParent\r\n```\r\n\r\n### Find Node\r\n\r\n```text\r\nfindNode(root, value)\r\n  Pre: value is the value of the node we want to find the parent of\r\n       root is the root node of the BST\r\n  Post: a reference to the node of value if found; otherwise ø\r\n  if root = ø\r\n    return ø\r\n  end if\r\n  if root.value = value\r\n    return root\r\n  else if value < root.value\r\n    return findNode(root.left, value)\r\n  else\r\n    return findNode(root.right, value)\r\n  end if\r\nend findNode\r\n```\r\n    \r\n### Find Minimum\r\n\r\n```text\r\nfindMin(root)\r\n  Pre: root is the root node of the BST\r\n    root = ø\r\n  Post: the smallest value in the BST is located\r\n  if root.left = ø\r\n    return root.value\r\n  end if\r\n  findMin(root.left)\r\nend findMin\r\n```\r\n    \r\n### Find Maximum\r\n\r\n```text\r\nfindMax(root)\r\n  Pre: root is the root node of the BST\r\n    root = ø\r\n  Post: the largest value in the BST is located\r\n  if root.right = ø\r\n    return root.value\r\n  end if\r\n  findMax(root.right)\r\nend findMax\r\n```\r\n    \r\n### Traversal\r\n\r\n#### InOrder Traversal\r\n\r\n```text\r\ninorder(root)\r\n  Pre: root is the root node of the BST\r\n  Post: the nodes in the BST have been visited in inorder\r\n  if root = ø\r\n    inorder(root.left)\r\n    yield root.value\r\n    inorder(root.right)\r\n  end if\r\nend inorder\r\n```\r\n\r\n#### PreOrder Traversal\r\n\r\n```text\r\npreorder(root)\r\n  Pre: root is the root node of the BST\r\n  Post: the nodes in the BST have been visited in preorder\r\n  if root = ø\r\n    yield root.value\r\n    preorder(root.left)\r\n    preorder(root.right)\r\n  end if\r\nend preorder\r\n```\r\n   \r\n#### PostOrder Traversal\r\n\r\n```text\r\npostorder(root)\r\n  Pre: root is the root node of the BST\r\n  Post: the nodes in the BST have been visited in postorder\r\n  if root = ø\r\n    postorder(root.left)\r\n    postorder(root.right)\r\n    yield root.value\r\n  end if\r\nend postorder\r\n```\r\n     \r\n## Complexities\r\n\r\n### Time Complexity\r\n\r\n| Access    | Search    | Insertion | Deletion  |\r\n| :-------: | :-------: | :-------: | :-------: |\r\n| O(log(n)) | O(log(n)) | O(log(n)) | O(log(n)) |\r\n\r\n### Space Complexity\r\n\r\nO(n)\r\n\r\n## References\r\n\r\n- [Wikipedia](https://en.wikipedia.org/wiki/Binary_search_tree)\r\n- [Inserting to BST on YouTube](https://www.youtube.com/watch?v=wcIRPqTR3Kc&list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8&index=9&t=0s)\r\n- [BST Interactive Visualisations](https://www.cs.usfca.edu/~galles/visualization/BST.html)\r\n",
      "html": "<h1 id=\"binary-search-tree\">Binary Search Tree <a class=\"heading-anchor-permalink\" href=\"#binary-search-tree\">#</a></h1>\n<p>In computer science, <strong>binary search trees</strong> (BST), sometimes called\nordered or sorted binary trees, are a particular type of container:\ndata structures that store “items” (such as numbers, names etc.)\nin memory. They allow fast lookup, addition and removal of\nitems, and can be used to implement either dynamic sets of\nitems, or lookup tables that allow finding an item by its key\n(e.g., finding the phone number of a person by name).</p>\n<p>Binary search trees keep their keys in sorted order, so that lookup\nand other operations can use the principle of binary search:\nwhen looking for a key in a tree (or a place to insert a new key),\nthey traverse the tree from root to leaf, making comparisons to\nthe operations to skip about half of the tree, so that each\nlookup, insertion or deletion takes time proportional to the\nlogarithm of the number of items stored in the tree. This is\nmuch better than the linear time required to find items by key\nin an (unsorted) array, but slower than the corresponding\noperations on hash tables.</p>\n<p>A binary search tree of size 9 and depth 3, with 8 at the root.\nThe leaves are not drawn.</p>\n<p><img src=\"https://upload.wikimedia.org/wikipedia/commons/d/da/Binary_search_tree.svg\" alt=\"Binary Search Tree\"></p>\n<h2 id=\"typescript\">Typescript <a class=\"heading-anchor-permalink\" href=\"#typescript\">#</a></h2>\n<pre><code class=\"language-typescript\">class TreeNode {\n    data: number;\n    left: TreeNode;\n    right: TreeNode;\n\n    constructor(data: number, left: TreeNode = null, right: TreeNode = null) {\n        this.data = data;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nclass BinarySearchTree {\n    root: TreeNode;\n    \n    constructor() {\n        this.root = null;\n    }\n    \n    insert(data: number) {\n        const searchTree = (node: TreeNode) =&gt; {\n            if (data &lt; node.data &amp;&amp; node.left) {\n                searchTree(node.left);\n            } else if (data &lt; node.data) {\n                node.left = new TreeNode(data);\n            } else if (data &gt; node.data &amp;&amp; node.right) {\n                searchTree(node.right);\n            } else if (data &gt; node.data) {\n                node.right = new TreeNode(data);\n            }\n        }\n\n        if (this.root === null) {\n            this.root = new TreeNode(data);\n        } else {\n            const node = this.root;\n            searchTree(node);\n        }\n    }\n    \n    getDepth(): number {\n        if (this.root === null) {\n            return 0;\n        }\n        \n        const traverseForDepth = (node: TreeNode, depth: number = 0): number =&gt; {\n            if(node.left === null &amp;&amp; node.right === null) {\n                return depth;\n            } else if(node.left &amp;&amp; node.right) {\n                const leftRes = traverseForDepth(node.left, depth + 1);\n                const rightRes = traverseForDepth(node.right, depth + 1);\n                return leftRes &gt; rightRes ? leftRes : rightRes;\n            } else if(node.left &amp;&amp; node.right === null) {\n                return traverseForDepth(node.left, depth + 1);\n            } else if(node.left === null &amp;&amp; node.right) {\n                return traverseForDepth(node.right, depth + 1);\n            } \n        }\n        \n        return traverseForDepth(this.root, 0);\n    }\n}\n</code></pre>\n<h2 id=\"pseudocode-for-basic-operations\">Pseudocode for Basic Operations <a class=\"heading-anchor-permalink\" href=\"#pseudocode-for-basic-operations\">#</a></h2>\n<h3 id=\"insertion\">Insertion <a class=\"heading-anchor-permalink\" href=\"#insertion\">#</a></h3>\n<pre><code class=\"language-text\">insert(value)\n  Pre: value has passed custom type checks for type T\n  Post: value has been placed in the correct location in the tree\n  if root = ø\n    root ← node(value)\n  else\n    insertNode(root, value)\n  end if\nend insert\n</code></pre>\n<pre><code class=\"language-text\">insertNode(current, value)\n  Pre: current is the node to start from\n  Post: value has been placed in the correct location in the tree\n  if value &lt; current.value\n    if current.left = ø\n      current.left ← node(value)\n    else\n      InsertNode(current.left, value)\n    end if\n  else\n    if current.right = ø\n      current.right ← node(value)\n    else\n      InsertNode(current.right, value)\n    end if\n  end if\nend insertNode\n</code></pre>\n<h3 id=\"searching\">Searching <a class=\"heading-anchor-permalink\" href=\"#searching\">#</a></h3>\n<pre><code class=\"language-text\">contains(root, value)\n  Pre: root is the root node of the tree, value is what we would like to locate\n  Post: value is either located or not\n  if root = ø\n    return false\n  end if\n  if root.value = value\n    return true\n  else if value &lt; root.value\n    return contains(root.left, value)\n  else\n    return contains(root.right, value)\n  end if\nend contains\n</code></pre>\n<h3 id=\"deletion\">Deletion <a class=\"heading-anchor-permalink\" href=\"#deletion\">#</a></h3>\n<pre><code class=\"language-text\">remove(value)\n  Pre: value is the value of the node to remove, root is the node of the BST\n      count is the number of items in the BST\n  Post: node with value is removed if found in which case yields true, otherwise false\n  nodeToRemove ← findNode(value)\n  if nodeToRemove = ø\n    return false\n  end if\n  parent ← findParent(value)\n  if count = 1\n    root ← ø\n  else if nodeToRemove.left = ø and nodeToRemove.right = ø\n    if nodeToRemove.value &lt; parent.value\n      parent.left ←  nodeToRemove.right\n    else\n      parent.right ← nodeToRemove.right\n    end if\n  else if nodeToRemove.left != ø and nodeToRemove.right != ø\n    next ← nodeToRemove.right\n    while next.left != ø\n      next ← next.left\n    end while\n    if next != nodeToRemove.right\n      remove(next.value)\n      nodeToRemove.value ← next.value\n    else\n      nodeToRemove.value ← next.value\n      nodeToRemove.right ← nodeToRemove.right.right\n    end if\n  else\n    if nodeToRemove.left = ø\n      next ← nodeToRemove.right\n    else\n      next ← nodeToRemove.left\n    end if\n    if root = nodeToRemove\n      root = next\n    else if parent.left = nodeToRemove\n      parent.left = next\n    else if parent.right = nodeToRemove\n      parent.right = next\n    end if\n  end if\n  count ← count - 1\n  return true\nend remove\n</code></pre>\n<h3 id=\"find-parent-of-node\">Find Parent of Node <a class=\"heading-anchor-permalink\" href=\"#find-parent-of-node\">#</a></h3>\n<pre><code class=\"language-text\">findParent(value, root)\n  Pre: value is the value of the node we want to find the parent of\n       root is the root node of the BST and is != ø\n  Post: a reference to the prent node of value if found; otherwise ø\n  if value = root.value\n    return ø\n  end if\n  if value &lt; root.value\n    if root.left = ø\n      return ø\n    else if root.left.value = value\n      return root\n    else\n      return findParent(value, root.left)\n    end if\n  else\n    if root.right = ø\n      return ø\n    else if root.right.value = value\n      return root\n    else\n      return findParent(value, root.right)\n    end if\n  end if\nend findParent\n</code></pre>\n<h3 id=\"find-node\">Find Node <a class=\"heading-anchor-permalink\" href=\"#find-node\">#</a></h3>\n<pre><code class=\"language-text\">findNode(root, value)\n  Pre: value is the value of the node we want to find the parent of\n       root is the root node of the BST\n  Post: a reference to the node of value if found; otherwise ø\n  if root = ø\n    return ø\n  end if\n  if root.value = value\n    return root\n  else if value &lt; root.value\n    return findNode(root.left, value)\n  else\n    return findNode(root.right, value)\n  end if\nend findNode\n</code></pre>\n<h3 id=\"find-minimum\">Find Minimum <a class=\"heading-anchor-permalink\" href=\"#find-minimum\">#</a></h3>\n<pre><code class=\"language-text\">findMin(root)\n  Pre: root is the root node of the BST\n    root = ø\n  Post: the smallest value in the BST is located\n  if root.left = ø\n    return root.value\n  end if\n  findMin(root.left)\nend findMin\n</code></pre>\n<h3 id=\"find-maximum\">Find Maximum <a class=\"heading-anchor-permalink\" href=\"#find-maximum\">#</a></h3>\n<pre><code class=\"language-text\">findMax(root)\n  Pre: root is the root node of the BST\n    root = ø\n  Post: the largest value in the BST is located\n  if root.right = ø\n    return root.value\n  end if\n  findMax(root.right)\nend findMax\n</code></pre>\n<h3 id=\"traversal\">Traversal <a class=\"heading-anchor-permalink\" href=\"#traversal\">#</a></h3>\n<h4 id=\"inorder-traversal\">InOrder Traversal <a class=\"heading-anchor-permalink\" href=\"#inorder-traversal\">#</a></h4>\n<pre><code class=\"language-text\">inorder(root)\n  Pre: root is the root node of the BST\n  Post: the nodes in the BST have been visited in inorder\n  if root = ø\n    inorder(root.left)\n    yield root.value\n    inorder(root.right)\n  end if\nend inorder\n</code></pre>\n<h4 id=\"preorder-traversal\">PreOrder Traversal <a class=\"heading-anchor-permalink\" href=\"#preorder-traversal\">#</a></h4>\n<pre><code class=\"language-text\">preorder(root)\n  Pre: root is the root node of the BST\n  Post: the nodes in the BST have been visited in preorder\n  if root = ø\n    yield root.value\n    preorder(root.left)\n    preorder(root.right)\n  end if\nend preorder\n</code></pre>\n<h4 id=\"postorder-traversal\">PostOrder Traversal <a class=\"heading-anchor-permalink\" href=\"#postorder-traversal\">#</a></h4>\n<pre><code class=\"language-text\">postorder(root)\n  Pre: root is the root node of the BST\n  Post: the nodes in the BST have been visited in postorder\n  if root = ø\n    postorder(root.left)\n    postorder(root.right)\n    yield root.value\n  end if\nend postorder\n</code></pre>\n<h2 id=\"complexities\">Complexities <a class=\"heading-anchor-permalink\" href=\"#complexities\">#</a></h2>\n<h3 id=\"time-complexity\">Time Complexity <a class=\"heading-anchor-permalink\" href=\"#time-complexity\">#</a></h3>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">Access</th>\n<th style=\"text-align:center\">Search</th>\n<th style=\"text-align:center\">Insertion</th>\n<th style=\"text-align:center\">Deletion</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">O(log(n))</td>\n<td style=\"text-align:center\">O(log(n))</td>\n<td style=\"text-align:center\">O(log(n))</td>\n<td style=\"text-align:center\">O(log(n))</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"space-complexity\">Space Complexity <a class=\"heading-anchor-permalink\" href=\"#space-complexity\">#</a></h3>\n<p>O(n)</p>\n<h2 id=\"references\">References <a class=\"heading-anchor-permalink\" href=\"#references\">#</a></h2>\n<ul>\n<li><a href=\"https://en.wikipedia.org/wiki/Binary_search_tree\">Wikipedia</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=wcIRPqTR3Kc&amp;list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8&amp;index=9&amp;t=0s\">Inserting to BST on YouTube</a></li>\n<li><a href=\"https://www.cs.usfca.edu/~galles/visualization/BST.html\">BST Interactive Visualisations</a></li>\n</ul>\n",
      "id": 9
    },
    {
      "path": "graphs-and-trees/graph.md",
      "url": "graphs-and-trees/graph.html",
      "content": "# Graph\r\n\r\nIn computer science, a **graph** is an abstract data type \r\nthat is meant to implement the undirected graph and \r\ndirected graph concepts from mathematics, specifically\r\nthe field of graph theory\r\n\r\nA graph data structure consists of a finite (and possibly \r\nmutable) set of vertices or nodes or points, together \r\nwith a set of unordered pairs of these vertices for an \r\nundirected graph or a set of ordered pairs for a \r\ndirected graph. These pairs are known as edges, arcs, \r\nor lines for an undirected graph and as arrows, \r\ndirected edges, directed arcs, or directed lines \r\nfor a directed graph. The vertices may be part of \r\nthe graph structure, or may be external entities \r\nrepresented by integer indices or references.\r\n\r\n![Graph](https://www.tutorialspoint.com/data_structures_algorithms/images/graph.jpg)\r\n\r\n## Javascript\r\n\r\nSee [BFS](/algorithms/2-breadth-first-search.html) and [DFS](/algorithms/3-depth-first-search.html) for this implementation's usage.\r\n\r\n```javascript\r\n// DATA\r\nconst airports = 'PHX BKK OKC JFK LAX MEX EZE HEL LOS LAP LIM'.split(' ');\r\n\r\nconst routes = [\r\n    ['PHX', 'LAX'],\r\n    ['PHX', 'JFK'],\r\n    ['JFK', 'OKC'],\r\n    ['JFK', 'HEL'],\r\n    ['JFK', 'LOS'],\r\n    ['MEX', 'LAX'],\r\n    ['MEX', 'BKK'],\r\n    ['MEX', 'LIM'],\r\n    ['MEX', 'EZE'],\r\n    ['LIM', 'BKK'],\r\n];\r\n\r\n\r\n// The graph\r\nconst adjacencyList = new Map();\r\n\r\n// Add node\r\nfunction addNode(airport) {\r\n    adjacencyList.set(airport, []);\r\n}\r\n\r\n// Add edge, undirected\r\nfunction addEdge(origin, destination) {\r\n    adjacencyList.get(origin).push(destination);\r\n    adjacencyList.get(destination).push(origin);\r\n}\r\n\r\n// Create the Graph\r\nairports.forEach(addNode);\r\nroutes.forEach(route => addEdge(...route))\r\n```\r\n\r\n## References\r\n\r\n- [Wikipedia](https://en.wikipedia.org/wiki/Graph_(abstract_data_type))\r\n- [Introduction to Graphs on YouTube](https://www.youtube.com/watch?v=gXgEDyodOJU&index=9&list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8)\r\n- [Graphs representation on YouTube](https://www.youtube.com/watch?v=k1wraWzqtvQ&index=10&list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8)\r\n",
      "html": "<h1 id=\"graph\">Graph <a class=\"heading-anchor-permalink\" href=\"#graph\">#</a></h1>\n<p>In computer science, a <strong>graph</strong> is an abstract data type\nthat is meant to implement the undirected graph and\ndirected graph concepts from mathematics, specifically\nthe field of graph theory</p>\n<p>A graph data structure consists of a finite (and possibly\nmutable) set of vertices or nodes or points, together\nwith a set of unordered pairs of these vertices for an\nundirected graph or a set of ordered pairs for a\ndirected graph. These pairs are known as edges, arcs,\nor lines for an undirected graph and as arrows,\ndirected edges, directed arcs, or directed lines\nfor a directed graph. The vertices may be part of\nthe graph structure, or may be external entities\nrepresented by integer indices or references.</p>\n<p><img src=\"https://www.tutorialspoint.com/data_structures_algorithms/images/graph.jpg\" alt=\"Graph\"></p>\n<h2 id=\"javascript\">Javascript <a class=\"heading-anchor-permalink\" href=\"#javascript\">#</a></h2>\n<p>See <a href=\"/algorithms/2-breadth-first-search.html\">BFS</a> and <a href=\"/algorithms/3-depth-first-search.html\">DFS</a> for this implementation’s usage.</p>\n<pre><code class=\"language-javascript\">// DATA\nconst airports = 'PHX BKK OKC JFK LAX MEX EZE HEL LOS LAP LIM'.split(' ');\n\nconst routes = [\n    ['PHX', 'LAX'],\n    ['PHX', 'JFK'],\n    ['JFK', 'OKC'],\n    ['JFK', 'HEL'],\n    ['JFK', 'LOS'],\n    ['MEX', 'LAX'],\n    ['MEX', 'BKK'],\n    ['MEX', 'LIM'],\n    ['MEX', 'EZE'],\n    ['LIM', 'BKK'],\n];\n\n\n// The graph\nconst adjacencyList = new Map();\n\n// Add node\nfunction addNode(airport) {\n    adjacencyList.set(airport, []);\n}\n\n// Add edge, undirected\nfunction addEdge(origin, destination) {\n    adjacencyList.get(origin).push(destination);\n    adjacencyList.get(destination).push(origin);\n}\n\n// Create the Graph\nairports.forEach(addNode);\nroutes.forEach(route =&gt; addEdge(...route))\n</code></pre>\n<h2 id=\"references\">References <a class=\"heading-anchor-permalink\" href=\"#references\">#</a></h2>\n<ul>\n<li><a href=\"https://en.wikipedia.org/wiki/Graph_(abstract_data_type)\">Wikipedia</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=gXgEDyodOJU&amp;index=9&amp;list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8\">Introduction to Graphs on YouTube</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=k1wraWzqtvQ&amp;index=10&amp;list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8\">Graphs representation on YouTube</a></li>\n</ul>\n",
      "id": 10
    },
    {
      "path": "interview/1-example-questions.md",
      "url": "interview/1-example-questions.html",
      "content": "# Example Questions\r\n\r\n## Service for interviews?\r\n\r\nhttps://www.interviewbit.com/\r\n\r\n## 50+ questions from HackerNoon\r\n\r\nhttps://hackernoon.com/50-data-structure-and-algorithms-interview-questions-for-programmers-b4b1ac61f5b0\r\n\r\nIDK how much trust to put in these, but they seem like the right kind of brain-teaser BS.\r\n\r\n### Arrays\r\n\r\n1. How do you find the missing number in a given integer array of 1 to 100? (solution)\r\n1. How do you find the duplicate number on a given integer array? (solution)\r\n1. How do you find the largest and smallest number in an unsorted integer array? (solution)\r\n1. How do you find all pairs of an integer array whose sum is equal to a given number? (solution)\r\n1. How do you find duplicate numbers in an array if it contains multiple duplicates? (solution)\r\n1. How are duplicates removed from a given array in Java? (solution)\r\n1. How is an integer array sorted in place using the quicksort algorithm? (solution)\r\n1. How do you remove duplicates from an array in place? (solution)\r\n1. How do you reverse an array in place in Java? (solution)\r\n1. How are duplicates removed from an array without using any library? (solution)\r\n\r\n### Linked Lists\r\n\r\n1. How do you find the middle element of a singly linked list in one pass? (solution)\r\n1. How do you check if a given linked list contains a cycle? How do you find the starting node of the cycle? (solution)\r\n1. How do you reverse a linked list? (solution)\r\n1. How do you reverse a singly linked list without recursion? (solution)\r\n1. How are duplicate nodes removed in an unsorted linked list? (solution)\r\n1. How do you find the length of a singly linked list? (solution)\r\n1. How do you find the third node from the end in a singly linked list? (solution)\r\n1. How do you find the sum of two linked lists using Stack? (solution)\r\n\r\n### Strings\r\n\r\n1. How do you print duplicate characters from a string? (solution)\r\n1. How do you check if two strings are anagrams of each other? (solution)\r\n1. How do you print the first non-repeated character from a string? (solution)\r\n1. How can a given string be reversed using recursion? (solution)\r\n1. How do you check if a string contains only digits? (solution)\r\n1. How are duplicate characters found in a string? (solution)\r\n1. How do you count a number of vowels and consonants in a given string? (solution)\r\n1. How do you count the occurrence of a given character in a string? (solution)\r\n1. How do you find all permutations of a string? (solution)\r\n1. How do you reverse words in a given sentence without using any library method? (solution)\r\n1. How do you check if two strings are a rotation of each other? (solution)\r\n1. How do you check if a given string is a palindrome? (solution)\r\n\r\n### Binary Trees\r\n\r\n1. How is a binary search tree implemented? (solution)\r\n1. How do you perform preorder traversal in a given binary tree? (solution)\r\n1. How do you traverse a given binary tree in preorder without recursion? (solution)\r\n1. How do you perform an inorder traversal in a given binary tree? (solution)\r\n1. How do you print all nodes of a given binary tree using inorder traversal without recursion? (solution)\r\n1. How do you implement a postorder traversal algorithm? (solution)\r\n1. How do you traverse a binary tree in postorder traversal without recursion? (solution)\r\n1. How are all leaves of a binary search tree printed? (solution)\r\n1. How do you count a number of leaf nodes in a given binary tree? (solution)\r\n1. How do you perform a binary search in a given array? (solution)\r\n\r\n### Misc\r\n\r\n1. How is a bubble sort algorithm implemented? (solution)\r\n1. How is an iterative quicksort algorithm implemented? (solution)\r\n1. How do you implement an insertion sort algorithm? (solution)\r\n1. How is a merge sort algorithm implemented? (solution)\r\n1. How do you implement a bucket sort algorithm? (solution)\r\n1. How do you implement a counting sort algorithm? (solution)\r\n1. How is a radix sort algorithm implemented? (solution)\r\n1. How do you swap two numbers without using the third variable? (solution)\r\n1. How do you check if two rectangles overlap with each other? (solution)\r\n1. How do you design a vending machine? (solution)\r\n",
      "html": "<h1 id=\"example-questions\">Example Questions <a class=\"heading-anchor-permalink\" href=\"#example-questions\">#</a></h1>\n<h2 id=\"service-for-interviews%3F\">Service for interviews? <a class=\"heading-anchor-permalink\" href=\"#service-for-interviews%3F\">#</a></h2>\n<p><a href=\"https://www.interviewbit.com/\">https://www.interviewbit.com/</a></p>\n<h2 id=\"50%2B-questions-from-hackernoon\">50+ questions from HackerNoon <a class=\"heading-anchor-permalink\" href=\"#50%2B-questions-from-hackernoon\">#</a></h2>\n<p><a href=\"https://hackernoon.com/50-data-structure-and-algorithms-interview-questions-for-programmers-b4b1ac61f5b0\">https://hackernoon.com/50-data-structure-and-algorithms-interview-questions-for-programmers-b4b1ac61f5b0</a></p>\n<p>IDK how much trust to put in these, but they seem like the right kind of brain-teaser BS.</p>\n<h3 id=\"arrays\">Arrays <a class=\"heading-anchor-permalink\" href=\"#arrays\">#</a></h3>\n<ol>\n<li>How do you find the missing number in a given integer array of 1 to 100? (solution)</li>\n<li>How do you find the duplicate number on a given integer array? (solution)</li>\n<li>How do you find the largest and smallest number in an unsorted integer array? (solution)</li>\n<li>How do you find all pairs of an integer array whose sum is equal to a given number? (solution)</li>\n<li>How do you find duplicate numbers in an array if it contains multiple duplicates? (solution)</li>\n<li>How are duplicates removed from a given array in Java? (solution)</li>\n<li>How is an integer array sorted in place using the quicksort algorithm? (solution)</li>\n<li>How do you remove duplicates from an array in place? (solution)</li>\n<li>How do you reverse an array in place in Java? (solution)</li>\n<li>How are duplicates removed from an array without using any library? (solution)</li>\n</ol>\n<h3 id=\"linked-lists\">Linked Lists <a class=\"heading-anchor-permalink\" href=\"#linked-lists\">#</a></h3>\n<ol>\n<li>How do you find the middle element of a singly linked list in one pass? (solution)</li>\n<li>How do you check if a given linked list contains a cycle? How do you find the starting node of the cycle? (solution)</li>\n<li>How do you reverse a linked list? (solution)</li>\n<li>How do you reverse a singly linked list without recursion? (solution)</li>\n<li>How are duplicate nodes removed in an unsorted linked list? (solution)</li>\n<li>How do you find the length of a singly linked list? (solution)</li>\n<li>How do you find the third node from the end in a singly linked list? (solution)</li>\n<li>How do you find the sum of two linked lists using Stack? (solution)</li>\n</ol>\n<h3 id=\"strings\">Strings <a class=\"heading-anchor-permalink\" href=\"#strings\">#</a></h3>\n<ol>\n<li>How do you print duplicate characters from a string? (solution)</li>\n<li>How do you check if two strings are anagrams of each other? (solution)</li>\n<li>How do you print the first non-repeated character from a string? (solution)</li>\n<li>How can a given string be reversed using recursion? (solution)</li>\n<li>How do you check if a string contains only digits? (solution)</li>\n<li>How are duplicate characters found in a string? (solution)</li>\n<li>How do you count a number of vowels and consonants in a given string? (solution)</li>\n<li>How do you count the occurrence of a given character in a string? (solution)</li>\n<li>How do you find all permutations of a string? (solution)</li>\n<li>How do you reverse words in a given sentence without using any library method? (solution)</li>\n<li>How do you check if two strings are a rotation of each other? (solution)</li>\n<li>How do you check if a given string is a palindrome? (solution)</li>\n</ol>\n<h3 id=\"binary-trees\">Binary Trees <a class=\"heading-anchor-permalink\" href=\"#binary-trees\">#</a></h3>\n<ol>\n<li>How is a binary search tree implemented? (solution)</li>\n<li>How do you perform preorder traversal in a given binary tree? (solution)</li>\n<li>How do you traverse a given binary tree in preorder without recursion? (solution)</li>\n<li>How do you perform an inorder traversal in a given binary tree? (solution)</li>\n<li>How do you print all nodes of a given binary tree using inorder traversal without recursion? (solution)</li>\n<li>How do you implement a postorder traversal algorithm? (solution)</li>\n<li>How do you traverse a binary tree in postorder traversal without recursion? (solution)</li>\n<li>How are all leaves of a binary search tree printed? (solution)</li>\n<li>How do you count a number of leaf nodes in a given binary tree? (solution)</li>\n<li>How do you perform a binary search in a given array? (solution)</li>\n</ol>\n<h3 id=\"misc\">Misc <a class=\"heading-anchor-permalink\" href=\"#misc\">#</a></h3>\n<ol>\n<li>How is a bubble sort algorithm implemented? (solution)</li>\n<li>How is an iterative quicksort algorithm implemented? (solution)</li>\n<li>How do you implement an insertion sort algorithm? (solution)</li>\n<li>How is a merge sort algorithm implemented? (solution)</li>\n<li>How do you implement a bucket sort algorithm? (solution)</li>\n<li>How do you implement a counting sort algorithm? (solution)</li>\n<li>How is a radix sort algorithm implemented? (solution)</li>\n<li>How do you swap two numbers without using the third variable? (solution)</li>\n<li>How do you check if two rectangles overlap with each other? (solution)</li>\n<li>How do you design a vending machine? (solution)</li>\n</ol>\n",
      "id": 11
    },
    {
      "path": "javascript/array.md",
      "url": "javascript/array.html",
      "content": "# Arrays\r\n\r\nThe Array object, as with arrays in other programming languages, enables storing a collection of multiple items under a single variable name, and has members for performing common array operations.\r\n\r\n## Description\r\n\r\nIn JavaScript, arrays aren't primitives but are instead Array objects with the following core characteristics:\r\n\r\n- JavaScript arrays are resizable and can contain a mix of different data types. (When those characteristics are undesirable, use typed arrays instead.)\r\n- JavaScript arrays are not associative arrays and so, array elements cannot be accessed using strings as indexes, but must be accessed using integers as indexes.\r\n- JavaScript arrays are zero-indexed: the first element of an array is at index 0, the second is at index 1, and so on — and the last element is at the value of the array's length property minus 1.\r\n- JavaScript array-copy operations create shallow copies. _(All standard built-in copy operations with any JavaScript objects create shallow copies, rather than deep copies)._\r\n\r\n## Array.map()\r\n\r\nThe map() method creates a new array populated with the results of calling a provided function on every element in the calling array.\r\n\r\n### Return value\r\n\r\nA new array with each element being the result of the callback function.\r\n\r\n```javascript\r\nconst array1 = [1, 4, 9, 16];\r\nconst map1 = array1.map(x => x * 2);\r\nconsole.log(map1);\r\n// expected output: Array [2, 8, 18, 32]\r\n\r\n////// FUNCTION SIGNATURES\r\n\r\n// Arrow function\r\nmap((element) => { /* ... */ })\r\nmap((element, index) => { /* ... */ })\r\nmap((element, index, array) => { /* ... */ })\r\n\r\n// Callback function\r\nmap(callbackFn)\r\nmap(callbackFn, thisArg)\r\n\r\n// Inline callback function\r\nmap(function(element) { /* ... */ })\r\nmap(function(element, index) { /* ... */ })\r\nmap(function(element, index, array){ /* ... */ })\r\nmap(function(element, index, array) { /* ... */ }, thisArg)\r\n```\r\n\r\n&nbsp;\r\n\r\n## Array.reduce()\r\n\r\nThe reduce() method executes a user-supplied \"reducer\" callback function on each element of the array, in order, passing in the return value from the calculation on the preceding element. The final result of running the reducer across all elements of the array is a single value.\r\n\r\nThe first time that the callback is run there is no \"return value of the previous calculation\". If supplied, an initial value may be used in its place. Otherwise the array element at index 0 is used as the initial value and iteration starts from the next element (index 1 instead of index 0).\r\n\r\n### Return value\r\n\r\nThe value that results from running the \"reducer\" callback function to completion over the entire array.\r\n\r\n### Edge cases\r\n\r\nIf the array only has one element (regardless of position) and no initialValue is provided, or if initialValue is provided but the array is empty, the solo value will be returned without calling callbackFn.\r\n\r\nIf initialValue is provided and the array is not empty, then the reduce method will always invoke the callback function starting at index 0.\r\n\r\nIf initialValue is not provided then the reduce method will act differently for arrays with length larger than 1, equal to 1 and 0, as shown in the following example:\r\n\r\n```javascript\r\n////// EXAMPLE 1\r\nconst array1 = [1, 2, 3, 4];\r\n\r\n// 0 + 1 + 2 + 3 + 4\r\nconst initialValue = 0;\r\nconst sumWithInitial = array1.reduce(\r\n  (previousValue, currentValue) => previousValue + currentValue,\r\n  initialValue\r\n);\r\nconsole.log(sumWithInitial);\r\n// expected output: 10\r\n\r\n////// EXAMPLE 2 (without initial value)\r\nconst otherArray = [15, 16, 17, 18, 19];\r\n\r\nfunction reducer(previous, current, index, otherArray) {\r\n  const returns = previous + current;\r\n  console.log(`prev: ${previous}, current: ${current}, idx: ${index}, returns: ${returns}`);\r\n  return returns;\r\n}\r\n\r\notherArray.reduce(reducer);\r\n\r\n////// FUNCTION SIGNATURES\r\n\r\n// Arrow function\r\nreduce((previousValue, currentValue) => { /* ... */ } )\r\nreduce((previousValue, currentValue, currentIndex) => { /* ... */ } )\r\nreduce((previousValue, currentValue, currentIndex, array) => { /* ... */ } )\r\nreduce((previousValue, currentValue, currentIndex, array) => { /* ... */ }, initialValue)\r\n\r\n// Callback function\r\nreduce(callbackFn)\r\nreduce(callbackFn, initialValue)\r\n\r\n// Inline callback function\r\nreduce(function(previousValue, currentValue) { /* ... */ })\r\nreduce(function(previousValue, currentValue, currentIndex) { /* ... */ })\r\nreduce(function(previousValue, currentValue, currentIndex, array) { /* ... */ })\r\nreduce(function(previousValue, currentValue, currentIndex, array) { /* ... */ }, initialValue)\r\n```\r\n\r\n&nbsp;\r\n\r\n## Array.filter()\r\n\r\nThe filter() method creates a new array with all elements that pass the test implemented by the provided function.\r\n\r\n### Return value\r\n\r\nA new array with the elements that pass the test. If no elements pass the test, an empty array will be returned.\r\n\r\n```javascript\r\nconst words = ['spray', 'limit', 'elite', 'exuberant', 'destruction', 'present'];\r\nconst result = words.filter(word => word.length > 6);\r\nconsole.log(result);\r\n// expected output: Array [\"exuberant\", \"destruction\", \"present\"]\r\n\r\n////// FUNCTION SIGNATURES\r\n\r\n// Arrow function\r\nfilter((element) => { /* ... */ } )\r\nfilter((element, index) => { /* ... */ } )\r\nfilter((element, index, array) => { /* ... */ } )\r\n\r\n// Callback function\r\nfilter(callbackFn)\r\nfilter(callbackFn, thisArg)\r\n\r\n// Inline callback function\r\nfilter(function(element) { /* ... */ })\r\nfilter(function(element, index) { /* ... */ })\r\nfilter(function(element, index, array){ /* ... */ })\r\nfilter(function(element, index, array) { /* ... */ }, thisArg)\r\n\r\n```\r\n\r\n&nbsp;\r\n\r\n## Array.sort()\r\n\r\nThe sort() method sorts the elements of an array in place and returns the sorted array. The default sort order is ascending, built upon converting the elements into strings, then comparing their sequences of UTF-16 code units values.\r\n\r\n### Return value\r\n\r\nThe sorted array. Note that the array is sorted in place, and no copy is made.\r\n\r\n```javascript\r\nconst months = ['March', 'Jan', 'Feb', 'Dec'];\r\nmonths.sort();\r\nconsole.log(months);\r\n// expected output: Array [\"Dec\", \"Feb\", \"Jan\", \"March\"]\r\n\r\nconst array1 = [1, 30, 4, 21, 100000];\r\narray1.sort();\r\nconsole.log(array1);\r\n// expected output: Array [1, 100000, 21, 30, 4]\r\n\r\n////// FUNCTION SIGNATURES\r\n\r\n// Functionless\r\nsort()\r\n\r\n// Arrow function\r\nsort((a, b) => { /* ... */ } )\r\n\r\n// Compare function\r\nsort(compareFn)\r\n\r\n// Inline compare function\r\nsort(function compareFn(a, b) { /* ... */ })\r\n```\r\n\r\n### Sorting order\r\n\r\n`compareFunction(a, b)` return value --> sort order\r\n\r\n- `< 0` --> sort a before b  \r\n- `> 0`\t--> sort b before a  \r\n- `=== 0` --> keep original order of a and b\r\n\r\n\r\n```javascript\r\nfunction compare(a, b) {\r\n  if (a is less than b by some ordering criterion) {\r\n    return -1;\r\n  }\r\n  if (a is greater than b by the ordering criterion) {\r\n    return 1;\r\n  }\r\n  // a must be equal to b\r\n  return 0;\r\n}\r\n```\r\n\r\n&nbsp;\r\n\r\n## Array.find() and Array.findIndex()\r\n\r\nThe find() method returns the first element in the provided array that satisfies the provided testing function. If no values satisfy the testing function, undefined is returned.\r\n\r\nThe findIndex() method returns the index of the first element in the array that satisfies the provided testing function. Otherwise, it returns -1, indicating that no element passed the test.\r\n\r\n### Return values\r\n\r\n`Array.find()` -- The first element in the array that satisfies the provided testing function. Otherwise, undefined is returned.\r\n\r\n`Array.findIndex()` -- The index of the first element in the array that passes the test. Otherwise, -1.  \r\n_Note: if the index of the first element in the array that passes the test is 0, the return value of `findIndex()` will be interpreted as Falsy in conditional statements._\r\n\r\n\r\n```javascript\r\nconst array1 = [5, 12, 8, 130, 44];\r\n\r\nconst found = array1.find(element => element > 10);\r\nconsole.log(found);\r\n// expected output: 12\r\n\r\nconst isLargeNumber = (element) => element > 13;\r\nconsole.log(array1.findIndex(isLargeNumber));\r\n// expected output: 3\r\n\r\n////// FUNCTION SIGNATURES\r\n\r\n// Arrow function\r\nfind((element) => { /* ... */ } )\r\nfind((element, index) => { /* ... */ } )\r\nfind((element, index, array) => { /* ... */ } )\r\n\r\n// Callback function\r\nfind(callbackFn)\r\nfind(callbackFn, thisArg)\r\n\r\n// Inline callback function\r\nfind(function(element) { /* ... */ })\r\nfind(function(element, index) { /* ... */ })\r\nfind(function(element, index, array){ /* ... */ })\r\nfind(function(element, index, array) { /* ... */ }, thisArg)\r\n\r\n// Arrow function\r\nfindIndex((element) => { /* ... */ } )\r\nfindIndex((element, index) => { /* ... */ } )\r\nfindIndex((element, index, array) => { /* ... */ } )\r\n\r\n// Callback function\r\nfindIndex(callbackFn)\r\nfindIndex(callbackFn, thisArg)\r\n\r\n// Inline callback function\r\nfindIndex(function(element) { /* ... */ })\r\nfindIndex(function(element, index) { /* ... */ })\r\nfindIndex(function(element, index, array){ /* ... */ })\r\nfindIndex(function(element, index, array) { /* ... */ }, thisArg)\r\n```\r\n\r\n&nbsp;\r\n\r\n## Array.every()\r\n\r\nThe every() method tests whether all elements in the array pass the test implemented by the provided function. It returns a Boolean value.\r\n\r\n### Return value\r\n\r\n`true` if the callbackFn function returns a truthy value for every array element. Otherwise, `false`.\r\n\r\n```javascript\r\nconst isBelowThreshold = (currentValue) => currentValue < 40;\r\nconst array1 = [1, 30, 39, 29, 10, 13];\r\n\r\nconsole.log(array1.every(isBelowThreshold));\r\n// expected output: true\r\n\r\n////// FUNCTION SIGNATURES\r\n\r\n// Arrow function\r\nevery((element) => { /* ... */ } )\r\nevery((element, index) => { /* ... */ } )\r\nevery((element, index, array) => { /* ... */ } )\r\n\r\n// Callback function\r\nevery(callbackFn)\r\nevery(callbackFn, thisArg)\r\n\r\n// Inline callback function\r\nevery(function(element) { /* ... */ })\r\nevery(function(element, index) { /* ... */ })\r\nevery(function(element, index, array){ /* ... */ })\r\nevery(function(element, index, array) { /* ... */ }, thisArg)\r\n```\r\n\r\n&nbsp;\r\n\r\n## References\r\n\r\nMDN -- https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array\r\n",
      "html": "<h1 id=\"arrays\">Arrays <a class=\"heading-anchor-permalink\" href=\"#arrays\">#</a></h1>\n<p>The Array object, as with arrays in other programming languages, enables storing a collection of multiple items under a single variable name, and has members for performing common array operations.</p>\n<h2 id=\"description\">Description <a class=\"heading-anchor-permalink\" href=\"#description\">#</a></h2>\n<p>In JavaScript, arrays aren’t primitives but are instead Array objects with the following core characteristics:</p>\n<ul>\n<li>JavaScript arrays are resizable and can contain a mix of different data types. (When those characteristics are undesirable, use typed arrays instead.)</li>\n<li>JavaScript arrays are not associative arrays and so, array elements cannot be accessed using strings as indexes, but must be accessed using integers as indexes.</li>\n<li>JavaScript arrays are zero-indexed: the first element of an array is at index 0, the second is at index 1, and so on — and the last element is at the value of the array’s length property minus 1.</li>\n<li>JavaScript array-copy operations create shallow copies. <em>(All standard built-in copy operations with any JavaScript objects create shallow copies, rather than deep copies).</em></li>\n</ul>\n<h2 id=\"array.map()\">Array.map() <a class=\"heading-anchor-permalink\" href=\"#array.map()\">#</a></h2>\n<p>The map() method creates a new array populated with the results of calling a provided function on every element in the calling array.</p>\n<h3 id=\"return-value\">Return value <a class=\"heading-anchor-permalink\" href=\"#return-value\">#</a></h3>\n<p>A new array with each element being the result of the callback function.</p>\n<pre><code class=\"language-javascript\">const array1 = [1, 4, 9, 16];\nconst map1 = array1.map(x =&gt; x * 2);\nconsole.log(map1);\n// expected output: Array [2, 8, 18, 32]\n\n////// FUNCTION SIGNATURES\n\n// Arrow function\nmap((element) =&gt; { /* ... */ })\nmap((element, index) =&gt; { /* ... */ })\nmap((element, index, array) =&gt; { /* ... */ })\n\n// Callback function\nmap(callbackFn)\nmap(callbackFn, thisArg)\n\n// Inline callback function\nmap(function(element) { /* ... */ })\nmap(function(element, index) { /* ... */ })\nmap(function(element, index, array){ /* ... */ })\nmap(function(element, index, array) { /* ... */ }, thisArg)\n</code></pre>\n<p> </p>\n<h2 id=\"array.reduce()\">Array.reduce() <a class=\"heading-anchor-permalink\" href=\"#array.reduce()\">#</a></h2>\n<p>The reduce() method executes a user-supplied “reducer” callback function on each element of the array, in order, passing in the return value from the calculation on the preceding element. The final result of running the reducer across all elements of the array is a single value.</p>\n<p>The first time that the callback is run there is no “return value of the previous calculation”. If supplied, an initial value may be used in its place. Otherwise the array element at index 0 is used as the initial value and iteration starts from the next element (index 1 instead of index 0).</p>\n<h3 id=\"return-value-2\">Return value <a class=\"heading-anchor-permalink\" href=\"#return-value-2\">#</a></h3>\n<p>The value that results from running the “reducer” callback function to completion over the entire array.</p>\n<h3 id=\"edge-cases\">Edge cases <a class=\"heading-anchor-permalink\" href=\"#edge-cases\">#</a></h3>\n<p>If the array only has one element (regardless of position) and no initialValue is provided, or if initialValue is provided but the array is empty, the solo value will be returned without calling callbackFn.</p>\n<p>If initialValue is provided and the array is not empty, then the reduce method will always invoke the callback function starting at index 0.</p>\n<p>If initialValue is not provided then the reduce method will act differently for arrays with length larger than 1, equal to 1 and 0, as shown in the following example:</p>\n<pre><code class=\"language-javascript\">////// EXAMPLE 1\nconst array1 = [1, 2, 3, 4];\n\n// 0 + 1 + 2 + 3 + 4\nconst initialValue = 0;\nconst sumWithInitial = array1.reduce(\n  (previousValue, currentValue) =&gt; previousValue + currentValue,\n  initialValue\n);\nconsole.log(sumWithInitial);\n// expected output: 10\n\n////// EXAMPLE 2 (without initial value)\nconst otherArray = [15, 16, 17, 18, 19];\n\nfunction reducer(previous, current, index, otherArray) {\n  const returns = previous + current;\n  console.log(`prev: ${previous}, current: ${current}, idx: ${index}, returns: ${returns}`);\n  return returns;\n}\n\notherArray.reduce(reducer);\n\n////// FUNCTION SIGNATURES\n\n// Arrow function\nreduce((previousValue, currentValue) =&gt; { /* ... */ } )\nreduce((previousValue, currentValue, currentIndex) =&gt; { /* ... */ } )\nreduce((previousValue, currentValue, currentIndex, array) =&gt; { /* ... */ } )\nreduce((previousValue, currentValue, currentIndex, array) =&gt; { /* ... */ }, initialValue)\n\n// Callback function\nreduce(callbackFn)\nreduce(callbackFn, initialValue)\n\n// Inline callback function\nreduce(function(previousValue, currentValue) { /* ... */ })\nreduce(function(previousValue, currentValue, currentIndex) { /* ... */ })\nreduce(function(previousValue, currentValue, currentIndex, array) { /* ... */ })\nreduce(function(previousValue, currentValue, currentIndex, array) { /* ... */ }, initialValue)\n</code></pre>\n<p> </p>\n<h2 id=\"array.filter()\">Array.filter() <a class=\"heading-anchor-permalink\" href=\"#array.filter()\">#</a></h2>\n<p>The filter() method creates a new array with all elements that pass the test implemented by the provided function.</p>\n<h3 id=\"return-value-3\">Return value <a class=\"heading-anchor-permalink\" href=\"#return-value-3\">#</a></h3>\n<p>A new array with the elements that pass the test. If no elements pass the test, an empty array will be returned.</p>\n<pre><code class=\"language-javascript\">const words = ['spray', 'limit', 'elite', 'exuberant', 'destruction', 'present'];\nconst result = words.filter(word =&gt; word.length &gt; 6);\nconsole.log(result);\n// expected output: Array [&quot;exuberant&quot;, &quot;destruction&quot;, &quot;present&quot;]\n\n////// FUNCTION SIGNATURES\n\n// Arrow function\nfilter((element) =&gt; { /* ... */ } )\nfilter((element, index) =&gt; { /* ... */ } )\nfilter((element, index, array) =&gt; { /* ... */ } )\n\n// Callback function\nfilter(callbackFn)\nfilter(callbackFn, thisArg)\n\n// Inline callback function\nfilter(function(element) { /* ... */ })\nfilter(function(element, index) { /* ... */ })\nfilter(function(element, index, array){ /* ... */ })\nfilter(function(element, index, array) { /* ... */ }, thisArg)\n\n</code></pre>\n<p> </p>\n<h2 id=\"array.sort()\">Array.sort() <a class=\"heading-anchor-permalink\" href=\"#array.sort()\">#</a></h2>\n<p>The sort() method sorts the elements of an array in place and returns the sorted array. The default sort order is ascending, built upon converting the elements into strings, then comparing their sequences of UTF-16 code units values.</p>\n<h3 id=\"return-value-4\">Return value <a class=\"heading-anchor-permalink\" href=\"#return-value-4\">#</a></h3>\n<p>The sorted array. Note that the array is sorted in place, and no copy is made.</p>\n<pre><code class=\"language-javascript\">const months = ['March', 'Jan', 'Feb', 'Dec'];\nmonths.sort();\nconsole.log(months);\n// expected output: Array [&quot;Dec&quot;, &quot;Feb&quot;, &quot;Jan&quot;, &quot;March&quot;]\n\nconst array1 = [1, 30, 4, 21, 100000];\narray1.sort();\nconsole.log(array1);\n// expected output: Array [1, 100000, 21, 30, 4]\n\n////// FUNCTION SIGNATURES\n\n// Functionless\nsort()\n\n// Arrow function\nsort((a, b) =&gt; { /* ... */ } )\n\n// Compare function\nsort(compareFn)\n\n// Inline compare function\nsort(function compareFn(a, b) { /* ... */ })\n</code></pre>\n<h3 id=\"sorting-order\">Sorting order <a class=\"heading-anchor-permalink\" href=\"#sorting-order\">#</a></h3>\n<p><code>compareFunction(a, b)</code> return value --&gt; sort order</p>\n<ul>\n<li><code>&lt; 0</code> --&gt; sort a before b</li>\n<li><code>&gt; 0</code>\t--&gt; sort b before a</li>\n<li><code>=== 0</code> --&gt; keep original order of a and b</li>\n</ul>\n<pre><code class=\"language-javascript\">function compare(a, b) {\n  if (a is less than b by some ordering criterion) {\n    return -1;\n  }\n  if (a is greater than b by the ordering criterion) {\n    return 1;\n  }\n  // a must be equal to b\n  return 0;\n}\n</code></pre>\n<p> </p>\n<h2 id=\"array.find()-and-array.findindex()\">Array.find() and Array.findIndex() <a class=\"heading-anchor-permalink\" href=\"#array.find()-and-array.findindex()\">#</a></h2>\n<p>The find() method returns the first element in the provided array that satisfies the provided testing function. If no values satisfy the testing function, undefined is returned.</p>\n<p>The findIndex() method returns the index of the first element in the array that satisfies the provided testing function. Otherwise, it returns -1, indicating that no element passed the test.</p>\n<h3 id=\"return-values\">Return values <a class=\"heading-anchor-permalink\" href=\"#return-values\">#</a></h3>\n<p><code>Array.find()</code> – The first element in the array that satisfies the provided testing function. Otherwise, undefined is returned.</p>\n<p><code>Array.findIndex()</code> – The index of the first element in the array that passes the test. Otherwise, -1.<br>\n<em>Note: if the index of the first element in the array that passes the test is 0, the return value of <code>findIndex()</code> will be interpreted as Falsy in conditional statements.</em></p>\n<pre><code class=\"language-javascript\">const array1 = [5, 12, 8, 130, 44];\n\nconst found = array1.find(element =&gt; element &gt; 10);\nconsole.log(found);\n// expected output: 12\n\nconst isLargeNumber = (element) =&gt; element &gt; 13;\nconsole.log(array1.findIndex(isLargeNumber));\n// expected output: 3\n\n////// FUNCTION SIGNATURES\n\n// Arrow function\nfind((element) =&gt; { /* ... */ } )\nfind((element, index) =&gt; { /* ... */ } )\nfind((element, index, array) =&gt; { /* ... */ } )\n\n// Callback function\nfind(callbackFn)\nfind(callbackFn, thisArg)\n\n// Inline callback function\nfind(function(element) { /* ... */ })\nfind(function(element, index) { /* ... */ })\nfind(function(element, index, array){ /* ... */ })\nfind(function(element, index, array) { /* ... */ }, thisArg)\n\n// Arrow function\nfindIndex((element) =&gt; { /* ... */ } )\nfindIndex((element, index) =&gt; { /* ... */ } )\nfindIndex((element, index, array) =&gt; { /* ... */ } )\n\n// Callback function\nfindIndex(callbackFn)\nfindIndex(callbackFn, thisArg)\n\n// Inline callback function\nfindIndex(function(element) { /* ... */ })\nfindIndex(function(element, index) { /* ... */ })\nfindIndex(function(element, index, array){ /* ... */ })\nfindIndex(function(element, index, array) { /* ... */ }, thisArg)\n</code></pre>\n<p> </p>\n<h2 id=\"array.every()\">Array.every() <a class=\"heading-anchor-permalink\" href=\"#array.every()\">#</a></h2>\n<p>The every() method tests whether all elements in the array pass the test implemented by the provided function. It returns a Boolean value.</p>\n<h3 id=\"return-value-5\">Return value <a class=\"heading-anchor-permalink\" href=\"#return-value-5\">#</a></h3>\n<p><code>true</code> if the callbackFn function returns a truthy value for every array element. Otherwise, <code>false</code>.</p>\n<pre><code class=\"language-javascript\">const isBelowThreshold = (currentValue) =&gt; currentValue &lt; 40;\nconst array1 = [1, 30, 39, 29, 10, 13];\n\nconsole.log(array1.every(isBelowThreshold));\n// expected output: true\n\n////// FUNCTION SIGNATURES\n\n// Arrow function\nevery((element) =&gt; { /* ... */ } )\nevery((element, index) =&gt; { /* ... */ } )\nevery((element, index, array) =&gt; { /* ... */ } )\n\n// Callback function\nevery(callbackFn)\nevery(callbackFn, thisArg)\n\n// Inline callback function\nevery(function(element) { /* ... */ })\nevery(function(element, index) { /* ... */ })\nevery(function(element, index, array){ /* ... */ })\nevery(function(element, index, array) { /* ... */ }, thisArg)\n</code></pre>\n<p> </p>\n<h2 id=\"references\">References <a class=\"heading-anchor-permalink\" href=\"#references\">#</a></h2>\n<p>MDN – <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array\">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array</a></p>\n",
      "id": 12
    },
    {
      "path": "javascript/concurrency-and-event-loop.md",
      "url": "javascript/concurrency-and-event-loop.html",
      "content": "# Concurrency Model and Event Loop\r\n\r\n## JS Runtime\r\n\r\nJavaScript has a runtime model based on an event loop, which is responsible for executing the code, collecting and processing events, and executing queued sub-tasks. This model is quite different from models in other languages like C and Java.\r\n\r\n### Stack\r\n\r\nFunction calls form a stack of frames.\r\n\r\n```javascript\r\nfunction foo(b) {\r\n  let a = 10\r\n  return a + b + 11\r\n}\r\n\r\nfunction bar(x) {\r\n  let y = 3\r\n  return foo(x * y)\r\n}\r\n\r\nconst baz = bar(7) // assigns 42 to baz\r\n```\r\n\r\nOrder of operations:\r\n\r\n1. When calling bar, a first frame is created containing references to bar's arguments and local variables.\r\n1. When bar calls foo, a second frame is created and pushed on top of the first one, containing references to foo's arguments and local variables.\r\n1. When foo returns, the top frame element is popped out of the stack (leaving only bar's call frame).\r\n1. When bar returns, the stack is empty.\r\nNote that the arguments and local variables may continue to exist, as they are stored outside the stack — so they can be accessed by any nested functions long after their outer function has returned.\r\n\r\n### Heap\r\n\r\nObjects are allocated in a heap which is just a name to denote a large (mostly unstructured) region of memory.\r\n\r\n### Queue\r\n\r\nA JavaScript runtime uses a message queue, which is a list of messages to be processed. Each message has an associated function that gets called to handle the message.\r\n\r\nAt some point during the event loop, the runtime starts handling the messages on the queue, starting with the oldest one. To do so, the message is removed from the queue and its corresponding function is called with the message as an input parameter. As always, calling a function creates a new stack frame for that function's use.\r\n\r\nThe processing of functions continues until the stack is once again empty. Then, the event loop will process the next message in the queue (if there is one).\r\n\r\n## Runtime queues\r\n\r\n### Tasks Queue\r\n\r\nA task is any JavaScript code which is scheduled to be run by the standard mechanisms such as initially starting to run a program, an event callback being run, or an interval or timeout being fired. These all get scheduled on the task queue.\r\n\r\nTasks get added to the task queue when:\r\n\r\n- A new JavaScript program or subprogram is executed (such as from a console, or by running the code in a `<script>` element) directly.\r\n- An event fires, adding the event's callback function to the task queue.\r\n- A timeout or interval created with `setTimeout()` or `setInterval()` is reached, causing the corresponding callback to be added to the task queue.\r\n\r\nThe event loop driving your code handles these tasks one after another, in the order in which they were enqueued. The oldest runnable task in the task queue will be executed during a single iteration of the event loop. After that, microtasks will be executed until the microtask queue is empty, and then the browser may choose to update rendering. Then the browser moves on to the next iteration of event loop.\r\n\r\n### Animation Callback Queue\r\n\r\nQueue of `requestAnimationFrame()` callbacks.\r\n\r\n### Microtasks Queue\r\n\r\nAt first the difference between microtasks and tasks seems minor. And they are similar; both are made up of JavaScript code which gets placed on a queue and run at an appropriate time. However, whereas the event loop runs only the tasks present on the queue when the iteration began, one after another, it handles the microtask queue very differently.\r\n\r\nThere are two key differences.\r\n\r\nFirst, each time a task exits, the event loop checks to see if the task is returning control to other JavaScript code. If not, it runs all of the microtasks in the microtask queue. The microtask queue is, then, processed multiple times per iteration of the event loop, including after handling events and other callbacks.\r\n\r\nSecond, if a microtask adds more microtasks to the queue by calling `queueMicrotask()`, those newly-added microtasks execute before the next task is run. That's because the event loop will keep calling microtasks until there are none left in the queue, even if more keep getting added.\r\n\r\n_Warning: Since microtasks can themselves enqueue more microtasks, and the event loop continues processing microtasks until the queue is empty, there's a real risk of getting the event loop endlessly processing microtasks. Be cautious with how you go about recursively adding microtasks._\r\n\r\nJavaScript promises and the Mutation Observer API both use the microtask queue to run their callbacks, but there are other times when the ability to defer work until the current event loop pass is wrapping up. In order to allow microtasks to be used by third-party libraries, frameworks, and polyfills, the `queueMicrotask()` method is exposed on the `Window` and `Worker` interfaces.\r\n\r\n## Resources\r\n\r\nMDN: The event loop -- https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop\r\n\r\nMDN: Microtasks (guide) -- https://developer.mozilla.org/en-US/docs/Web/API/HTML_DOM_API/Microtask_guide\r\n\r\nMDN: Microtasks (in depth) -- https://developer.mozilla.org/en-US/docs/Web/API/HTML_DOM_API/Microtask_guide/In_depth\r\n\r\n**Jake Archibald: In The Loop - JSConf.Asia -- https://www.youtube.com/watch?v=cCOL7MC4Pl0**\r\n\r\nWhat the heck is the event loop anyway? | Philip Roberts | JSConf EU -- https://www.youtube.com/watch?v=8aGhZQkoFbQ\r\n\r\nExploration of requestAnimationFrame execution mechanism -- https://segmentfault.com/a/1190000040945949/en\r\n",
      "html": "<h1 id=\"concurrency-model-and-event-loop\">Concurrency Model and Event Loop <a class=\"heading-anchor-permalink\" href=\"#concurrency-model-and-event-loop\">#</a></h1>\n<h2 id=\"js-runtime\">JS Runtime <a class=\"heading-anchor-permalink\" href=\"#js-runtime\">#</a></h2>\n<p>JavaScript has a runtime model based on an event loop, which is responsible for executing the code, collecting and processing events, and executing queued sub-tasks. This model is quite different from models in other languages like C and Java.</p>\n<h3 id=\"stack\">Stack <a class=\"heading-anchor-permalink\" href=\"#stack\">#</a></h3>\n<p>Function calls form a stack of frames.</p>\n<pre><code class=\"language-javascript\">function foo(b) {\n  let a = 10\n  return a + b + 11\n}\n\nfunction bar(x) {\n  let y = 3\n  return foo(x * y)\n}\n\nconst baz = bar(7) // assigns 42 to baz\n</code></pre>\n<p>Order of operations:</p>\n<ol>\n<li>When calling bar, a first frame is created containing references to bar’s arguments and local variables.</li>\n<li>When bar calls foo, a second frame is created and pushed on top of the first one, containing references to foo’s arguments and local variables.</li>\n<li>When foo returns, the top frame element is popped out of the stack (leaving only bar’s call frame).</li>\n<li>When bar returns, the stack is empty.\nNote that the arguments and local variables may continue to exist, as they are stored outside the stack — so they can be accessed by any nested functions long after their outer function has returned.</li>\n</ol>\n<h3 id=\"heap\">Heap <a class=\"heading-anchor-permalink\" href=\"#heap\">#</a></h3>\n<p>Objects are allocated in a heap which is just a name to denote a large (mostly unstructured) region of memory.</p>\n<h3 id=\"queue\">Queue <a class=\"heading-anchor-permalink\" href=\"#queue\">#</a></h3>\n<p>A JavaScript runtime uses a message queue, which is a list of messages to be processed. Each message has an associated function that gets called to handle the message.</p>\n<p>At some point during the event loop, the runtime starts handling the messages on the queue, starting with the oldest one. To do so, the message is removed from the queue and its corresponding function is called with the message as an input parameter. As always, calling a function creates a new stack frame for that function’s use.</p>\n<p>The processing of functions continues until the stack is once again empty. Then, the event loop will process the next message in the queue (if there is one).</p>\n<h2 id=\"runtime-queues\">Runtime queues <a class=\"heading-anchor-permalink\" href=\"#runtime-queues\">#</a></h2>\n<h3 id=\"tasks-queue\">Tasks Queue <a class=\"heading-anchor-permalink\" href=\"#tasks-queue\">#</a></h3>\n<p>A task is any JavaScript code which is scheduled to be run by the standard mechanisms such as initially starting to run a program, an event callback being run, or an interval or timeout being fired. These all get scheduled on the task queue.</p>\n<p>Tasks get added to the task queue when:</p>\n<ul>\n<li>A new JavaScript program or subprogram is executed (such as from a console, or by running the code in a <code>&lt;script&gt;</code> element) directly.</li>\n<li>An event fires, adding the event’s callback function to the task queue.</li>\n<li>A timeout or interval created with <code>setTimeout()</code> or <code>setInterval()</code> is reached, causing the corresponding callback to be added to the task queue.</li>\n</ul>\n<p>The event loop driving your code handles these tasks one after another, in the order in which they were enqueued. The oldest runnable task in the task queue will be executed during a single iteration of the event loop. After that, microtasks will be executed until the microtask queue is empty, and then the browser may choose to update rendering. Then the browser moves on to the next iteration of event loop.</p>\n<h3 id=\"animation-callback-queue\">Animation Callback Queue <a class=\"heading-anchor-permalink\" href=\"#animation-callback-queue\">#</a></h3>\n<p>Queue of <code>requestAnimationFrame()</code> callbacks.</p>\n<h3 id=\"microtasks-queue\">Microtasks Queue <a class=\"heading-anchor-permalink\" href=\"#microtasks-queue\">#</a></h3>\n<p>At first the difference between microtasks and tasks seems minor. And they are similar; both are made up of JavaScript code which gets placed on a queue and run at an appropriate time. However, whereas the event loop runs only the tasks present on the queue when the iteration began, one after another, it handles the microtask queue very differently.</p>\n<p>There are two key differences.</p>\n<p>First, each time a task exits, the event loop checks to see if the task is returning control to other JavaScript code. If not, it runs all of the microtasks in the microtask queue. The microtask queue is, then, processed multiple times per iteration of the event loop, including after handling events and other callbacks.</p>\n<p>Second, if a microtask adds more microtasks to the queue by calling <code>queueMicrotask()</code>, those newly-added microtasks execute before the next task is run. That’s because the event loop will keep calling microtasks until there are none left in the queue, even if more keep getting added.</p>\n<p><em>Warning: Since microtasks can themselves enqueue more microtasks, and the event loop continues processing microtasks until the queue is empty, there’s a real risk of getting the event loop endlessly processing microtasks. Be cautious with how you go about recursively adding microtasks.</em></p>\n<p>JavaScript promises and the Mutation Observer API both use the microtask queue to run their callbacks, but there are other times when the ability to defer work until the current event loop pass is wrapping up. In order to allow microtasks to be used by third-party libraries, frameworks, and polyfills, the <code>queueMicrotask()</code> method is exposed on the <code>Window</code> and <code>Worker</code> interfaces.</p>\n<h2 id=\"resources\">Resources <a class=\"heading-anchor-permalink\" href=\"#resources\">#</a></h2>\n<p>MDN: The event loop – <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop\">https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop</a></p>\n<p>MDN: Microtasks (guide) – <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/HTML_DOM_API/Microtask_guide\">https://developer.mozilla.org/en-US/docs/Web/API/HTML_DOM_API/Microtask_guide</a></p>\n<p>MDN: Microtasks (in depth) – <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/HTML_DOM_API/Microtask_guide/In_depth\">https://developer.mozilla.org/en-US/docs/Web/API/HTML_DOM_API/Microtask_guide/In_depth</a></p>\n<p><strong>Jake Archibald: In The Loop - <a href=\"http://JSConf.Asia\">JSConf.Asia</a> – <a href=\"https://www.youtube.com/watch?v=cCOL7MC4Pl0\">https://www.youtube.com/watch?v=cCOL7MC4Pl0</a></strong></p>\n<p>What the heck is the event loop anyway? | Philip Roberts | JSConf EU – <a href=\"https://www.youtube.com/watch?v=8aGhZQkoFbQ\">https://www.youtube.com/watch?v=8aGhZQkoFbQ</a></p>\n<p>Exploration of requestAnimationFrame execution mechanism – <a href=\"https://segmentfault.com/a/1190000040945949/en\">https://segmentfault.com/a/1190000040945949/en</a></p>\n",
      "id": 13
    },
    {
      "path": "javascript/editions.md",
      "url": "javascript/editions.html",
      "content": "# Javascript Editions\r\n\r\n## ES1\r\n\r\nJune 1997\r\n\r\n## ES2\r\n\r\nJune 1998\r\n\r\n## ES3\r\n\r\nDec. 1999\r\n\r\n## ES4\r\n\r\nAbandoned\r\n\r\n## ES5\r\n\r\nDecember 2009: Nearly 10 years later, ES5 was released in 2009. It would then take almost six years for the next version of ECMAScript to be released.\r\n\r\n## ES6 / ES2015\r\n\r\nJune 2015: Perhaps the cause for all of your confusion begins here. You see, ES6 and ES2015 are the same thing.\r\n\r\nES6 was the popularized name prior to release. However, the committee that oversees ECMAScript specifications made the decision to move to annual updates. With this change, the edition was renamed to ES 2015 to reflect the year of release. Subsequent releases will therefor also be named according to the year they are released.\r\n\r\n## ES2016 (ES7)\r\n\r\nJune 2016: Seventh edition of ECMAScript.\r\n\r\n## ES2017 (ES8)\r\n\r\nJune 2017: Eighth edition of ECMAScript.\r\n\r\n## ES.Next\r\n\r\nYou may have also seen ES.Next used online. This term is dynamic and references the next version of ECMAScript coming out.\r\n\r\n## Why?\r\n\r\nEach release brings updates and new features to the language.\r\n\r\n## Key Takeaways\r\n\r\n- An update to ECMAscript can be expected annually.\r\n- Initial Editions of ECMAScript are named numerically, increasing by 1: ES1, ES2, ES3, ES4, ES5\r\n- New editions (starting with 2015) will be named ES followed by the year of release: ES2015, ES2016, ES2017\r\n- ECMAScript is a standard. JavaScript is the most popular implementation of that standard. Other implementations include: SpiderMonkey, V8, and ActionScript.\r\n\r\n&nbsp;\r\n\r\n## References\r\n\r\nJavaScript — WTF is ES6, ES8, ES 2017, ECMAScript… ?: https://codeburst.io/javascript-wtf-is-es6-es8-es-2017-ecmascript-dca859e4821c\r\n",
      "html": "<h1 id=\"javascript-editions\">Javascript Editions <a class=\"heading-anchor-permalink\" href=\"#javascript-editions\">#</a></h1>\n<h2 id=\"es1\">ES1 <a class=\"heading-anchor-permalink\" href=\"#es1\">#</a></h2>\n<p>June 1997</p>\n<h2 id=\"es2\">ES2 <a class=\"heading-anchor-permalink\" href=\"#es2\">#</a></h2>\n<p>June 1998</p>\n<h2 id=\"es3\">ES3 <a class=\"heading-anchor-permalink\" href=\"#es3\">#</a></h2>\n<p>Dec. 1999</p>\n<h2 id=\"es4\">ES4 <a class=\"heading-anchor-permalink\" href=\"#es4\">#</a></h2>\n<p>Abandoned</p>\n<h2 id=\"es5\">ES5 <a class=\"heading-anchor-permalink\" href=\"#es5\">#</a></h2>\n<p>December 2009: Nearly 10 years later, ES5 was released in 2009. It would then take almost six years for the next version of ECMAScript to be released.</p>\n<h2 id=\"es6-%2F-es2015\">ES6 / ES2015 <a class=\"heading-anchor-permalink\" href=\"#es6-%2F-es2015\">#</a></h2>\n<p>June 2015: Perhaps the cause for all of your confusion begins here. You see, ES6 and ES2015 are the same thing.</p>\n<p>ES6 was the popularized name prior to release. However, the committee that oversees ECMAScript specifications made the decision to move to annual updates. With this change, the edition was renamed to ES 2015 to reflect the year of release. Subsequent releases will therefor also be named according to the year they are released.</p>\n<h2 id=\"es2016-(es7)\">ES2016 (ES7) <a class=\"heading-anchor-permalink\" href=\"#es2016-(es7)\">#</a></h2>\n<p>June 2016: Seventh edition of ECMAScript.</p>\n<h2 id=\"es2017-(es8)\">ES2017 (ES8) <a class=\"heading-anchor-permalink\" href=\"#es2017-(es8)\">#</a></h2>\n<p>June 2017: Eighth edition of ECMAScript.</p>\n<h2 id=\"es.next\">ES.Next <a class=\"heading-anchor-permalink\" href=\"#es.next\">#</a></h2>\n<p>You may have also seen ES.Next used online. This term is dynamic and references the next version of ECMAScript coming out.</p>\n<h2 id=\"why%3F\">Why? <a class=\"heading-anchor-permalink\" href=\"#why%3F\">#</a></h2>\n<p>Each release brings updates and new features to the language.</p>\n<h2 id=\"key-takeaways\">Key Takeaways <a class=\"heading-anchor-permalink\" href=\"#key-takeaways\">#</a></h2>\n<ul>\n<li>An update to ECMAscript can be expected annually.</li>\n<li>Initial Editions of ECMAScript are named numerically, increasing by 1: ES1, ES2, ES3, ES4, ES5</li>\n<li>New editions (starting with 2015) will be named ES followed by the year of release: ES2015, ES2016, ES2017</li>\n<li>ECMAScript is a standard. JavaScript is the most popular implementation of that standard. Other implementations include: SpiderMonkey, V8, and ActionScript.</li>\n</ul>\n<p> </p>\n<h2 id=\"references\">References <a class=\"heading-anchor-permalink\" href=\"#references\">#</a></h2>\n<p>JavaScript — WTF is ES6, ES8, ES 2017, ECMAScript… ?: <a href=\"https://codeburst.io/javascript-wtf-is-es6-es8-es-2017-ecmascript-dca859e4821c\">https://codeburst.io/javascript-wtf-is-es6-es8-es-2017-ecmascript-dca859e4821c</a></p>\n",
      "id": 14
    },
    {
      "path": "javascript/iteration.md",
      "url": "javascript/iteration.html",
      "content": "# Iteration\r\n\r\n...\r\n\r\n## Loops\r\n\r\n### for\r\n\r\nThe for statement creates a loop that consists of three optional expressions, enclosed in parentheses and separated by semicolons, followed by a statement (usually a block statement) to be executed in the loop.\r\n\r\n```javascript\r\nlet str = '';\r\n\r\nfor (let i = 0; i < 9; i++) {\r\n  str = str + i;\r\n}\r\n\r\nconsole.log(str);\r\n// expected output: \"012345678\"\r\n```\r\n\r\n### for...in\r\n\r\nThe for...in statement iterates over all enumerable properties of an object that are keyed by strings (ignoring ones keyed by Symbols), including inherited enumerable properties.\r\n\r\n```javascript\r\nconst object = { a: 1, b: 2, c: 3 };\r\n\r\nfor (const property in object) {\r\n  console.log(`${property}: ${object[property]}`);\r\n}\r\n\r\n// expected output:\r\n// \"a: 1\"\r\n// \"b: 2\"\r\n// \"c: 3\"\r\n```\r\n\r\n### for...of\r\n\r\nThe for...of statement creates a loop iterating over iterable objects, including: built-in String, Array, array-like objects (e.g., arguments or NodeList), TypedArray, Map, Set, and user-defined iterables. It invokes a custom iteration hook with statements to be executed for the value of each distinct property of the object.\r\n\r\n```javascript\r\nconst array1 = ['a', 'b', 'c'];\r\n\r\nfor (const element of array1) {\r\n  console.log(element);\r\n}\r\n\r\n// expected output: \"a\"\r\n// expected output: \"b\"\r\n// expected output: \"c\"\r\n```\r\n\r\n### for await...of\r\n\r\nThe for await...of statement creates a loop iterating over async iterable objects as well as on sync iterables, including: built-in String, Array, Array-like objects (e.g., arguments or NodeList), TypedArray, Map, Set, and user-defined async/sync iterables. It invokes a custom iteration hook with statements to be executed for the value of each distinct property of the object. This statement can only be used inside an async function.\r\n\r\nSince the return values of async generator functions conform to the async iterable protocol, they can be looped using for await...of.\r\n\r\n```javascript\r\nasync function* asyncGenerator() {\r\n  let i = 0;\r\n  while (i < 3) {\r\n    yield i++;\r\n  }\r\n}\r\n\r\n(async () => {\r\n  for await (const num of asyncGenerator()) {\r\n    console.log(num);\r\n  }\r\n})();\r\n// 0\r\n// 1\r\n// 2\r\n```\r\n\r\n### while\r\n\r\nThe while statement creates a loop that executes a specified statement as long as the test condition evaluates to true. The condition is evaluated before executing the statement.\r\n\r\n```javascript\r\nlet n = 0;\r\n\r\nwhile (n < 3) {\r\n  n++;\r\n}\r\n\r\nconsole.log(n);\r\n// expected output: 3\r\n```\r\n\r\n### do...while\r\n\r\nThe do...while statement creates a loop that executes a specified statement until the test condition evaluates to false. The condition is evaluated after executing the statement, resulting in the specified statement executing at least once.\r\n\r\n```javascript\r\nlet result = '';\r\nlet i = 0;\r\n\r\ndo {\r\n  i = i + 1;\r\n  result = result + i;\r\n} while (i < 5);\r\n\r\nconsole.log(result);\r\n// expected result: \"12345\"\r\n```\r\n\r\n&nbsp;\r\n\r\n## Iteration protocols\r\n\r\nAs a couple of additions to ECMAScript 2015, Iteration protocols aren't new built-ins or syntax, but protocols. These protocols can be implemented by any object by following some conventions.\r\n\r\nThere are two protocols: The **iterable** protocol and the **iterator** protocol.\r\n\r\n### The iterable protocol\r\n\r\nThe iterable protocol allows JavaScript objects to define or customize their iteration behavior, such as what values are looped over in a `for...of` construct.\r\n\r\nIn order to be iterable, an object must implement the @@iterator method, meaning that the object (or one of the objects up its prototype chain) must have a property with a `@@iterator` key which is available via constant `Symbol.iterator`\r\n\r\nWhenever an object needs to be iterated (such as at the beginning of a `for...of` loop), its `@@iterator` method is called with no arguments, and the returned iterator is used to obtain the values to be iterated.\r\n\r\nThis function can be an ordinary function, or it can be a generator function, so that when invoked, an iterator object is returned. Inside of this generator function, each entry can be provided by using `yield`.\r\n\r\n`String`, `Array`, `TypedArray`, `Map`, `Set`, and `Intl.Segments` are all built-in iterables, because each of their prototype objects implements an `@@iterator` method. In addition, the `arguments` object and some DOM collection types such as `NodeList` are also iterables.\r\n\r\n`String`'s default iterator returns the string's code points one by one:\r\n\r\n```javascript\r\nconst someString = 'hi';\r\nconsole.log(typeof someString[Symbol.iterator]); // \"function\"\r\n\r\nconst iterator = someString[Symbol.iterator]();\r\nconsole.log(iterator + ''); // \"[object String Iterator]\"\r\n\r\nconsole.log(iterator.next()); // { value: \"h\", done: false }\r\nconsole.log(iterator.next()); // { value: \"i\", done: false }\r\nconsole.log(iterator.next()); // { value: undefined, done: true }\r\n```\r\n\r\n### The iterator protocol\r\n\r\nThe iterator protocol defines a standard way to produce a sequence of values (either finite or infinite), and potentially a return value when all values have been generated.\r\n\r\nAn object is an iterator when it implements a `next()` method with the following semantics:\r\n\r\n_A function, with either zero arguments or one argument, that returns an object with at least the following two properties. If the `next()` method is called with one argument, that argument will be available to the `next()` method being invoked._\r\n\r\n- `done` -- _Has the value false if the iterator was able to produce the next value in the sequence. (This is equivalent to not specifying the done property altogether.)_\r\nHas the value true if the iterator has completed its sequence. In this case, value optionally specifies the return value of the iterator.\r\n- `value` -- _Any JavaScript value returned by the iterator. Can be omitted when done is true._\r\n\r\n_The `next()` method must always return an object with appropriate properties including done and value. If a non-object value gets returned (such as false or undefined), a `TypeError` (`\"iterator.next() returned a non-object value\"`) will be thrown._\r\n\r\nNOTE: It is not possible to know reflectively whether a particular object implements the iterator protocol. However, it is easy to create an object that satisfies both the iterator and iterable protocols (as shown in the example below).\r\n\r\nDoing so allows an iterator to be consumed by the various syntaxes expecting iterables. Thus, it is seldom useful to implement the Iterator Protocol without also implementing Iterable.\r\n\r\n```javascript\r\n// Satisfies both the Iterator protocol and Iterable\r\nconst myIterator = {\r\n    next: function() {\r\n        // ...\r\n    },\r\n    [Symbol.iterator]: function() { return this; }\r\n};\r\n```\r\n\r\nHowever, when possible, it's better for `iterable[Symbol.iterator]` to return different iterators that always start from the beginning, like `Set.prototype[@@iterator]()` does.\r\n\r\n&nbsp;\r\n\r\n## Iterators\r\n\r\nIn JavaScript an iterator is an object which defines a sequence and potentially a return value upon its termination.\r\n\r\nSpecifically, an iterator is any object which implements the Iterator protocol by having a next() method that returns an object with two properties:\r\n\r\n- `value` -- The next value in the iteration sequence.\r\n- `done` -- This is true if the last value in the sequence has already been consumed. If value is present alongside done, it is the iterator's return value.\r\n\r\nOnce created, an iterator object can be iterated explicitly by repeatedly calling next(). Iterating over an iterator is said to consume the iterator, because it is generally only possible to do once. After a terminating value has been yielded additional calls to next() should continue to return {done: true}.\r\n\r\nThe most common iterator in JavaScript is the Array iterator, which returns each value in the associated array in sequence.\r\n\r\nHere is an example. It allows creation of a simple range iterator which defines a sequence of integers from start (inclusive) to end (exclusive) spaced step apart. Its final return value is the size of the sequence it created, tracked by the variable iterationCount.\r\n\r\n```javascript\r\n// creating an iterator\r\nfunction makeRangeIterator(start = 0, end = Infinity, step = 1) {\r\n    let nextIndex = start;\r\n    let iterationCount = 0;\r\n\r\n    const rangeIterator = {\r\n       next() {\r\n           let result;\r\n           if (nextIndex < end) {\r\n               result = { value: nextIndex, done: false }\r\n               nextIndex += step;\r\n               iterationCount++;\r\n               return result;\r\n           }\r\n           return { value: iterationCount, done: true }\r\n       }\r\n    };\r\n    return rangeIterator;\r\n}\r\nconst it = makeRangeIterator(1, 10, 2);\r\n\r\n// using the iterator\r\nlet result = it.next();\r\nwhile (!result.done) {\r\n console.log(result.value); // 1 3 5 7 9\r\n result = it.next();\r\n}\r\n\r\nconsole.log(\"Iterated over sequence of size: \", result.value);\r\n// [5 numbers returned, that took interval in between: 0 to 10]\r\n```\r\n\r\n```javascript\r\n```\r\n\r\n&nbsp;\r\n\r\n## Generator functions\r\n\r\nWhile custom iterators are a useful tool, their creation requires careful programming due to the need to explicitly maintain their internal state. Generator functions provide a powerful alternative: they allow you to define an iterative algorithm by writing a single function whose execution is not continuous. Generator functions are written using the function* syntax.\r\n\r\nWhen called, generator functions do not initially execute their code. Instead, they return a special type of iterator, called a Generator. When a value is consumed by calling the generator's next method, the Generator function executes until it encounters the yield keyword.\r\n\r\nThe function can be called as many times as desired, and returns a new Generator each time. Each Generator may only be iterated once.\r\n\r\nWe can now adapt the example from above. The behavior of this code is identical, but the implementation is much easier to write and read.\r\n\r\n```javascript\r\nfunction* makeRangeIterator(start = 0, end = 100, step = 1) {\r\n    let iterationCount = 0;\r\n    for (let i = start; i < end; i += step) {\r\n        iterationCount++;\r\n        yield i;\r\n    }\r\n    return iterationCount;\r\n}\r\n```\r\n\r\n### Advanced generators\r\n\r\nGenerators compute their `yield`ed values on demand, which allows them to efficiently represent sequences that are expensive to compute (or even infinite sequences, as demonstrated above).\r\n\r\nThe `next()` method also accepts a value, which can be used to modify the internal state of the generator. A value passed to `next()` will be received by `yield` .\r\n\r\n> Note: A value passed to the first invocation of `next()` is always ignored.\r\n\r\nHere is the fibonacci generator using `next(x)` to restart the sequence:\r\n\r\n```javascript\r\nfunction* fibonacci() {\r\n  let current = 0;\r\n  let next = 1;\r\n  while (true) {\r\n    const reset = yield current;\r\n    [current, next] = [next, next + current];\r\n    if (reset) {\r\n      current = 0;\r\n      next = 1;\r\n    }\r\n  }\r\n}\r\n\r\nconst sequence = fibonacci();\r\nconsole.log(sequence.next().value);     // 0\r\nconsole.log(sequence.next().value);     // 1\r\nconsole.log(sequence.next().value);     // 1\r\nconsole.log(sequence.next().value);     // 2\r\nconsole.log(sequence.next().value);     // 3\r\nconsole.log(sequence.next().value);     // 5\r\nconsole.log(sequence.next().value);     // 8\r\nconsole.log(sequence.next(true).value); // 0\r\nconsole.log(sequence.next().value);     // 1\r\nconsole.log(sequence.next().value);     // 1\r\nconsole.log(sequence.next().value);     // 2\r\n```\r\n\r\nYou can force a generator to throw an exception by calling its `throw()` method and passing the exception value it should throw. This exception will be thrown from the current suspended context of the generator, as if the `yield` that is currently suspended were instead a `throw value` statement.\r\n\r\nIf the exception is not caught from within the generator, it will propagate up through the call to `throw()`, and subsequent calls to `next()` will result in the done property being true.\r\n\r\nGenerators have a `return(value)` method that returns the given value and finishes the generator itself.\r\n\r\n&nbsp;\r\n\r\n## References\r\n\r\nMDN: Statements and declarations (Iterations) -- https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements#iterations\r\n\r\nMDN: Iteration protocols -- https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols\r\n\r\nMDN: Iterators and generators -- https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_generators\r\n",
      "html": "<h1 id=\"iteration\">Iteration <a class=\"heading-anchor-permalink\" href=\"#iteration\">#</a></h1>\n<p>…</p>\n<h2 id=\"loops\">Loops <a class=\"heading-anchor-permalink\" href=\"#loops\">#</a></h2>\n<h3 id=\"for\">for <a class=\"heading-anchor-permalink\" href=\"#for\">#</a></h3>\n<p>The for statement creates a loop that consists of three optional expressions, enclosed in parentheses and separated by semicolons, followed by a statement (usually a block statement) to be executed in the loop.</p>\n<pre><code class=\"language-javascript\">let str = '';\n\nfor (let i = 0; i &lt; 9; i++) {\n  str = str + i;\n}\n\nconsole.log(str);\n// expected output: &quot;012345678&quot;\n</code></pre>\n<h3 id=\"for%E2%80%A6in\">for…in <a class=\"heading-anchor-permalink\" href=\"#for%E2%80%A6in\">#</a></h3>\n<p>The for…in statement iterates over all enumerable properties of an object that are keyed by strings (ignoring ones keyed by Symbols), including inherited enumerable properties.</p>\n<pre><code class=\"language-javascript\">const object = { a: 1, b: 2, c: 3 };\n\nfor (const property in object) {\n  console.log(`${property}: ${object[property]}`);\n}\n\n// expected output:\n// &quot;a: 1&quot;\n// &quot;b: 2&quot;\n// &quot;c: 3&quot;\n</code></pre>\n<h3 id=\"for%E2%80%A6of\">for…of <a class=\"heading-anchor-permalink\" href=\"#for%E2%80%A6of\">#</a></h3>\n<p>The for…of statement creates a loop iterating over iterable objects, including: built-in String, Array, array-like objects (e.g., arguments or NodeList), TypedArray, Map, Set, and user-defined iterables. It invokes a custom iteration hook with statements to be executed for the value of each distinct property of the object.</p>\n<pre><code class=\"language-javascript\">const array1 = ['a', 'b', 'c'];\n\nfor (const element of array1) {\n  console.log(element);\n}\n\n// expected output: &quot;a&quot;\n// expected output: &quot;b&quot;\n// expected output: &quot;c&quot;\n</code></pre>\n<h3 id=\"for-await%E2%80%A6of\">for await…of <a class=\"heading-anchor-permalink\" href=\"#for-await%E2%80%A6of\">#</a></h3>\n<p>The for await…of statement creates a loop iterating over async iterable objects as well as on sync iterables, including: built-in String, Array, Array-like objects (e.g., arguments or NodeList), TypedArray, Map, Set, and user-defined async/sync iterables. It invokes a custom iteration hook with statements to be executed for the value of each distinct property of the object. This statement can only be used inside an async function.</p>\n<p>Since the return values of async generator functions conform to the async iterable protocol, they can be looped using for await…of.</p>\n<pre><code class=\"language-javascript\">async function* asyncGenerator() {\n  let i = 0;\n  while (i &lt; 3) {\n    yield i++;\n  }\n}\n\n(async () =&gt; {\n  for await (const num of asyncGenerator()) {\n    console.log(num);\n  }\n})();\n// 0\n// 1\n// 2\n</code></pre>\n<h3 id=\"while\">while <a class=\"heading-anchor-permalink\" href=\"#while\">#</a></h3>\n<p>The while statement creates a loop that executes a specified statement as long as the test condition evaluates to true. The condition is evaluated before executing the statement.</p>\n<pre><code class=\"language-javascript\">let n = 0;\n\nwhile (n &lt; 3) {\n  n++;\n}\n\nconsole.log(n);\n// expected output: 3\n</code></pre>\n<h3 id=\"do%E2%80%A6while\">do…while <a class=\"heading-anchor-permalink\" href=\"#do%E2%80%A6while\">#</a></h3>\n<p>The do…while statement creates a loop that executes a specified statement until the test condition evaluates to false. The condition is evaluated after executing the statement, resulting in the specified statement executing at least once.</p>\n<pre><code class=\"language-javascript\">let result = '';\nlet i = 0;\n\ndo {\n  i = i + 1;\n  result = result + i;\n} while (i &lt; 5);\n\nconsole.log(result);\n// expected result: &quot;12345&quot;\n</code></pre>\n<p> </p>\n<h2 id=\"iteration-protocols\">Iteration protocols <a class=\"heading-anchor-permalink\" href=\"#iteration-protocols\">#</a></h2>\n<p>As a couple of additions to ECMAScript 2015, Iteration protocols aren’t new built-ins or syntax, but protocols. These protocols can be implemented by any object by following some conventions.</p>\n<p>There are two protocols: The <strong>iterable</strong> protocol and the <strong>iterator</strong> protocol.</p>\n<h3 id=\"the-iterable-protocol\">The iterable protocol <a class=\"heading-anchor-permalink\" href=\"#the-iterable-protocol\">#</a></h3>\n<p>The iterable protocol allows JavaScript objects to define or customize their iteration behavior, such as what values are looped over in a <code>for...of</code> construct.</p>\n<p>In order to be iterable, an object must implement the @@iterator method, meaning that the object (or one of the objects up its prototype chain) must have a property with a <code>@@iterator</code> key which is available via constant <code>Symbol.iterator</code></p>\n<p>Whenever an object needs to be iterated (such as at the beginning of a <code>for...of</code> loop), its <code>@@iterator</code> method is called with no arguments, and the returned iterator is used to obtain the values to be iterated.</p>\n<p>This function can be an ordinary function, or it can be a generator function, so that when invoked, an iterator object is returned. Inside of this generator function, each entry can be provided by using <code>yield</code>.</p>\n<p><code>String</code>, <code>Array</code>, <code>TypedArray</code>, <code>Map</code>, <code>Set</code>, and <code>Intl.Segments</code> are all built-in iterables, because each of their prototype objects implements an <code>@@iterator</code> method. In addition, the <code>arguments</code> object and some DOM collection types such as <code>NodeList</code> are also iterables.</p>\n<p><code>String</code>'s default iterator returns the string’s code points one by one:</p>\n<pre><code class=\"language-javascript\">const someString = 'hi';\nconsole.log(typeof someString[Symbol.iterator]); // &quot;function&quot;\n\nconst iterator = someString[Symbol.iterator]();\nconsole.log(iterator + ''); // &quot;[object String Iterator]&quot;\n\nconsole.log(iterator.next()); // { value: &quot;h&quot;, done: false }\nconsole.log(iterator.next()); // { value: &quot;i&quot;, done: false }\nconsole.log(iterator.next()); // { value: undefined, done: true }\n</code></pre>\n<h3 id=\"the-iterator-protocol\">The iterator protocol <a class=\"heading-anchor-permalink\" href=\"#the-iterator-protocol\">#</a></h3>\n<p>The iterator protocol defines a standard way to produce a sequence of values (either finite or infinite), and potentially a return value when all values have been generated.</p>\n<p>An object is an iterator when it implements a <code>next()</code> method with the following semantics:</p>\n<p><em>A function, with either zero arguments or one argument, that returns an object with at least the following two properties. If the <code>next()</code> method is called with one argument, that argument will be available to the <code>next()</code> method being invoked.</em></p>\n<ul>\n<li><code>done</code> – <em>Has the value false if the iterator was able to produce the next value in the sequence. (This is equivalent to not specifying the done property altogether.)</em>\nHas the value true if the iterator has completed its sequence. In this case, value optionally specifies the return value of the iterator.</li>\n<li><code>value</code> – <em>Any JavaScript value returned by the iterator. Can be omitted when done is true.</em></li>\n</ul>\n<p><em>The <code>next()</code> method must always return an object with appropriate properties including done and value. If a non-object value gets returned (such as false or undefined), a <code>TypeError</code> (<code>&quot;iterator.next() returned a non-object value&quot;</code>) will be thrown.</em></p>\n<p>NOTE: It is not possible to know reflectively whether a particular object implements the iterator protocol. However, it is easy to create an object that satisfies both the iterator and iterable protocols (as shown in the example below).</p>\n<p>Doing so allows an iterator to be consumed by the various syntaxes expecting iterables. Thus, it is seldom useful to implement the Iterator Protocol without also implementing Iterable.</p>\n<pre><code class=\"language-javascript\">// Satisfies both the Iterator protocol and Iterable\nconst myIterator = {\n    next: function() {\n        // ...\n    },\n    [Symbol.iterator]: function() { return this; }\n};\n</code></pre>\n<p>However, when possible, it’s better for <code>iterable[Symbol.iterator]</code> to return different iterators that always start from the beginning, like <code>Set.prototype[@@iterator]()</code> does.</p>\n<p> </p>\n<h2 id=\"iterators\">Iterators <a class=\"heading-anchor-permalink\" href=\"#iterators\">#</a></h2>\n<p>In JavaScript an iterator is an object which defines a sequence and potentially a return value upon its termination.</p>\n<p>Specifically, an iterator is any object which implements the Iterator protocol by having a next() method that returns an object with two properties:</p>\n<ul>\n<li><code>value</code> – The next value in the iteration sequence.</li>\n<li><code>done</code> – This is true if the last value in the sequence has already been consumed. If value is present alongside done, it is the iterator’s return value.</li>\n</ul>\n<p>Once created, an iterator object can be iterated explicitly by repeatedly calling next(). Iterating over an iterator is said to consume the iterator, because it is generally only possible to do once. After a terminating value has been yielded additional calls to next() should continue to return {done: true}.</p>\n<p>The most common iterator in JavaScript is the Array iterator, which returns each value in the associated array in sequence.</p>\n<p>Here is an example. It allows creation of a simple range iterator which defines a sequence of integers from start (inclusive) to end (exclusive) spaced step apart. Its final return value is the size of the sequence it created, tracked by the variable iterationCount.</p>\n<pre><code class=\"language-javascript\">// creating an iterator\nfunction makeRangeIterator(start = 0, end = Infinity, step = 1) {\n    let nextIndex = start;\n    let iterationCount = 0;\n\n    const rangeIterator = {\n       next() {\n           let result;\n           if (nextIndex &lt; end) {\n               result = { value: nextIndex, done: false }\n               nextIndex += step;\n               iterationCount++;\n               return result;\n           }\n           return { value: iterationCount, done: true }\n       }\n    };\n    return rangeIterator;\n}\nconst it = makeRangeIterator(1, 10, 2);\n\n// using the iterator\nlet result = it.next();\nwhile (!result.done) {\n console.log(result.value); // 1 3 5 7 9\n result = it.next();\n}\n\nconsole.log(&quot;Iterated over sequence of size: &quot;, result.value);\n// [5 numbers returned, that took interval in between: 0 to 10]\n</code></pre>\n<pre><code class=\"language-javascript\"></code></pre>\n<p> </p>\n<h2 id=\"generator-functions\">Generator functions <a class=\"heading-anchor-permalink\" href=\"#generator-functions\">#</a></h2>\n<p>While custom iterators are a useful tool, their creation requires careful programming due to the need to explicitly maintain their internal state. Generator functions provide a powerful alternative: they allow you to define an iterative algorithm by writing a single function whose execution is not continuous. Generator functions are written using the function* syntax.</p>\n<p>When called, generator functions do not initially execute their code. Instead, they return a special type of iterator, called a Generator. When a value is consumed by calling the generator’s next method, the Generator function executes until it encounters the yield keyword.</p>\n<p>The function can be called as many times as desired, and returns a new Generator each time. Each Generator may only be iterated once.</p>\n<p>We can now adapt the example from above. The behavior of this code is identical, but the implementation is much easier to write and read.</p>\n<pre><code class=\"language-javascript\">function* makeRangeIterator(start = 0, end = 100, step = 1) {\n    let iterationCount = 0;\n    for (let i = start; i &lt; end; i += step) {\n        iterationCount++;\n        yield i;\n    }\n    return iterationCount;\n}\n</code></pre>\n<h3 id=\"advanced-generators\">Advanced generators <a class=\"heading-anchor-permalink\" href=\"#advanced-generators\">#</a></h3>\n<p>Generators compute their <code>yield</code>ed values on demand, which allows them to efficiently represent sequences that are expensive to compute (or even infinite sequences, as demonstrated above).</p>\n<p>The <code>next()</code> method also accepts a value, which can be used to modify the internal state of the generator. A value passed to <code>next()</code> will be received by <code>yield</code> .</p>\n<blockquote>\n<p>Note: A value passed to the first invocation of <code>next()</code> is always ignored.</p>\n</blockquote>\n<p>Here is the fibonacci generator using <code>next(x)</code> to restart the sequence:</p>\n<pre><code class=\"language-javascript\">function* fibonacci() {\n  let current = 0;\n  let next = 1;\n  while (true) {\n    const reset = yield current;\n    [current, next] = [next, next + current];\n    if (reset) {\n      current = 0;\n      next = 1;\n    }\n  }\n}\n\nconst sequence = fibonacci();\nconsole.log(sequence.next().value);     // 0\nconsole.log(sequence.next().value);     // 1\nconsole.log(sequence.next().value);     // 1\nconsole.log(sequence.next().value);     // 2\nconsole.log(sequence.next().value);     // 3\nconsole.log(sequence.next().value);     // 5\nconsole.log(sequence.next().value);     // 8\nconsole.log(sequence.next(true).value); // 0\nconsole.log(sequence.next().value);     // 1\nconsole.log(sequence.next().value);     // 1\nconsole.log(sequence.next().value);     // 2\n</code></pre>\n<p>You can force a generator to throw an exception by calling its <code>throw()</code> method and passing the exception value it should throw. This exception will be thrown from the current suspended context of the generator, as if the <code>yield</code> that is currently suspended were instead a <code>throw value</code> statement.</p>\n<p>If the exception is not caught from within the generator, it will propagate up through the call to <code>throw()</code>, and subsequent calls to <code>next()</code> will result in the done property being true.</p>\n<p>Generators have a <code>return(value)</code> method that returns the given value and finishes the generator itself.</p>\n<p> </p>\n<h2 id=\"references\">References <a class=\"heading-anchor-permalink\" href=\"#references\">#</a></h2>\n<p>MDN: Statements and declarations (Iterations) – <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements#iterations\">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements#iterations</a></p>\n<p>MDN: Iteration protocols – <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols\">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols</a></p>\n<p>MDN: Iterators and generators – <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_generators\">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_generators</a></p>\n",
      "id": 15
    },
    {
      "path": "javascript/map.md",
      "url": "javascript/map.html",
      "content": "# Map\r\n\r\nThe Map object holds key-value pairs and remembers the original insertion order of the keys. Any value (both objects and primitive values) may be used as either a key or a value.\r\n\r\n### Key equality\r\n\r\n- Key equality is based on the _sameValueZero_ algorithm.\r\n- NaN is considered the same as NaN (even though NaN !== NaN) and all other values are considered equal according to the semantics of the === operator.\r\n- In the current ECMAScript specification, -0 and +0 are considered equal, although this was not so in earlier drafts.\r\n\r\n```javascript\r\nconst map1 = new Map();\r\n\r\nmap1.set('a', 1);\r\nmap1.set('b', 2);\r\nmap1.set('c', 3);\r\n\r\nconsole.log(map1.get('a'));\r\n// expected output: 1\r\n\r\nmap1.set('a', 97);\r\n\r\nconsole.log(map1.get('a'));\r\n// expected output: 97\r\n\r\nconsole.log(map1.size);\r\n// expected output: 3\r\n\r\nmap1.delete('b');\r\n\r\nconsole.log(map1.size);\r\n// expected output: 2\r\n```\r\n\r\n## Map.set()\r\n\r\nThe set() method adds or updates an element with a specified key and a value to a Map object.\r\n\r\n### Return value\r\n\r\nThe Map object.\r\n\r\n```javascript\r\nconst map1 = new Map();\r\nmap1.set('bar', 'foo');\r\n\r\nconsole.log(map1.get('bar'));\r\n// expected output: \"foo\"\r\n\r\nconsole.log(map1.get('baz'));\r\n// expected output: undefined\r\n\r\n////// FUNCTION SIGNATURES\r\n\r\nset(key, value)\r\n```\r\n\r\n## Map.get()\r\n\r\nThe get() method returns a specified element from a Map object. If the value that is associated to the provided key is an object, then you will get a reference to that object and any change made to that object will effectively modify it inside the Map object.\r\n\r\n### Return value\r\n\r\nThe element associated with the specified key, or undefined if the key can't be found in the Map object.\r\n\r\n```javascript\r\nconst map1 = new Map();\r\nmap1.set('bar', 'foo');\r\n\r\nconsole.log(map1.get('bar'));\r\n// expected output: \"foo\"\r\n\r\nconsole.log(map1.get('baz'));\r\n// expected output: undefined\r\n\r\n////// FUNCTION SIGNATURES\r\n\r\nget(key)\r\n```\r\n\r\n## Map.has()\r\n\r\nThe has() method returns a boolean indicating whether an element with the specified key exists or not.\r\n\r\n### Return value\r\n\r\ntrue if an element with the specified key exists in the Map object; otherwise false.\r\n\r\n```javascript\r\nconst map1 = new Map();\r\nmap1.set('bar', 'foo');\r\n\r\nconsole.log(map1.has('bar'));\r\n// expected output: true\r\n\r\nconsole.log(map1.has('baz'));\r\n// expected output: false\r\n\r\n////// FUNCTION SIGNATURES\r\n\r\nhas(key)\r\n\r\n```\r\n\r\n## Map.delete()\r\n\r\nThe delete() method removes the specified element from a Map object by key.\r\n\r\n### Return value\r\n\r\ntrue if an element in the Map object existed and has been removed, or false if the element does not exist.\r\n\r\n```javascript\r\nconst map1 = new Map();\r\nmap1.set('bar', 'foo');\r\n\r\nconsole.log(map1.delete('bar'));\r\n// expected result: true\r\n// (true indicates successful removal)\r\n\r\nconsole.log(map1.has('bar'));\r\n// expected result: false\r\n\r\n////// FUNCTION SIGNATURES\r\n\r\ndelete(key)\r\n```\r\n\r\n## Map.clear()\r\n\r\nThe clear() method removes all elements from a Map object.\r\n\r\n### Return value\r\n\r\nundefined\r\n\r\n```javascript\r\nconst map1 = new Map();\r\n\r\nmap1.set('bar', 'baz');\r\nmap1.set(1, 'foo');\r\n\r\nconsole.log(map1.size);\r\n// expected output: 2\r\n\r\nmap1.clear();\r\n\r\nconsole.log(map1.size);\r\n// expected output: 0\r\n\r\n////// FUNCTION SIGNATURES\r\n\r\nclear()\r\n```\r\n\r\n## References\r\n\r\nMDN -- https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map\r\n",
      "html": "<h1 id=\"map\">Map <a class=\"heading-anchor-permalink\" href=\"#map\">#</a></h1>\n<p>The Map object holds key-value pairs and remembers the original insertion order of the keys. Any value (both objects and primitive values) may be used as either a key or a value.</p>\n<h3 id=\"key-equality\">Key equality <a class=\"heading-anchor-permalink\" href=\"#key-equality\">#</a></h3>\n<ul>\n<li>Key equality is based on the <em>sameValueZero</em> algorithm.</li>\n<li>NaN is considered the same as NaN (even though NaN !== NaN) and all other values are considered equal according to the semantics of the === operator.</li>\n<li>In the current ECMAScript specification, -0 and +0 are considered equal, although this was not so in earlier drafts.</li>\n</ul>\n<pre><code class=\"language-javascript\">const map1 = new Map();\n\nmap1.set('a', 1);\nmap1.set('b', 2);\nmap1.set('c', 3);\n\nconsole.log(map1.get('a'));\n// expected output: 1\n\nmap1.set('a', 97);\n\nconsole.log(map1.get('a'));\n// expected output: 97\n\nconsole.log(map1.size);\n// expected output: 3\n\nmap1.delete('b');\n\nconsole.log(map1.size);\n// expected output: 2\n</code></pre>\n<h2 id=\"map.set()\">Map.set() <a class=\"heading-anchor-permalink\" href=\"#map.set()\">#</a></h2>\n<p>The set() method adds or updates an element with a specified key and a value to a Map object.</p>\n<h3 id=\"return-value\">Return value <a class=\"heading-anchor-permalink\" href=\"#return-value\">#</a></h3>\n<p>The Map object.</p>\n<pre><code class=\"language-javascript\">const map1 = new Map();\nmap1.set('bar', 'foo');\n\nconsole.log(map1.get('bar'));\n// expected output: &quot;foo&quot;\n\nconsole.log(map1.get('baz'));\n// expected output: undefined\n\n////// FUNCTION SIGNATURES\n\nset(key, value)\n</code></pre>\n<h2 id=\"map.get()\">Map.get() <a class=\"heading-anchor-permalink\" href=\"#map.get()\">#</a></h2>\n<p>The get() method returns a specified element from a Map object. If the value that is associated to the provided key is an object, then you will get a reference to that object and any change made to that object will effectively modify it inside the Map object.</p>\n<h3 id=\"return-value-2\">Return value <a class=\"heading-anchor-permalink\" href=\"#return-value-2\">#</a></h3>\n<p>The element associated with the specified key, or undefined if the key can’t be found in the Map object.</p>\n<pre><code class=\"language-javascript\">const map1 = new Map();\nmap1.set('bar', 'foo');\n\nconsole.log(map1.get('bar'));\n// expected output: &quot;foo&quot;\n\nconsole.log(map1.get('baz'));\n// expected output: undefined\n\n////// FUNCTION SIGNATURES\n\nget(key)\n</code></pre>\n<h2 id=\"map.has()\">Map.has() <a class=\"heading-anchor-permalink\" href=\"#map.has()\">#</a></h2>\n<p>The has() method returns a boolean indicating whether an element with the specified key exists or not.</p>\n<h3 id=\"return-value-3\">Return value <a class=\"heading-anchor-permalink\" href=\"#return-value-3\">#</a></h3>\n<p>true if an element with the specified key exists in the Map object; otherwise false.</p>\n<pre><code class=\"language-javascript\">const map1 = new Map();\nmap1.set('bar', 'foo');\n\nconsole.log(map1.has('bar'));\n// expected output: true\n\nconsole.log(map1.has('baz'));\n// expected output: false\n\n////// FUNCTION SIGNATURES\n\nhas(key)\n\n</code></pre>\n<h2 id=\"map.delete()\">Map.delete() <a class=\"heading-anchor-permalink\" href=\"#map.delete()\">#</a></h2>\n<p>The delete() method removes the specified element from a Map object by key.</p>\n<h3 id=\"return-value-4\">Return value <a class=\"heading-anchor-permalink\" href=\"#return-value-4\">#</a></h3>\n<p>true if an element in the Map object existed and has been removed, or false if the element does not exist.</p>\n<pre><code class=\"language-javascript\">const map1 = new Map();\nmap1.set('bar', 'foo');\n\nconsole.log(map1.delete('bar'));\n// expected result: true\n// (true indicates successful removal)\n\nconsole.log(map1.has('bar'));\n// expected result: false\n\n////// FUNCTION SIGNATURES\n\ndelete(key)\n</code></pre>\n<h2 id=\"map.clear()\">Map.clear() <a class=\"heading-anchor-permalink\" href=\"#map.clear()\">#</a></h2>\n<p>The clear() method removes all elements from a Map object.</p>\n<h3 id=\"return-value-5\">Return value <a class=\"heading-anchor-permalink\" href=\"#return-value-5\">#</a></h3>\n<p>undefined</p>\n<pre><code class=\"language-javascript\">const map1 = new Map();\n\nmap1.set('bar', 'baz');\nmap1.set(1, 'foo');\n\nconsole.log(map1.size);\n// expected output: 2\n\nmap1.clear();\n\nconsole.log(map1.size);\n// expected output: 0\n\n////// FUNCTION SIGNATURES\n\nclear()\n</code></pre>\n<h2 id=\"references\">References <a class=\"heading-anchor-permalink\" href=\"#references\">#</a></h2>\n<p>MDN – <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map\">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map</a></p>\n",
      "id": 16
    },
    {
      "path": "javascript/modules.md",
      "url": "javascript/modules.html",
      "content": "# Modules\r\n\r\nBy default, Node.js treats JavaScript code as CommonJS modules. CommonJS modules are characterized by the require() statement for module imports and module.exports for module exports.\r\n\r\nFor example, this is a CommonJS module that exports two functions:\r\n\r\n```javascript\r\nmodule.exports.add = function(a, b) {\r\n        return a + b;\r\n} \r\n\r\nmodule.exports.subtract = function(a, b) {\r\n        return a - b;\r\n} \r\n```\r\n\r\nWe can also import the public functions into another Node.js script using `require()`, just as we do here:\r\n\r\n```javascript\r\nconst {add, subtract} = require('./util')\r\n\r\nconsole.log(add(5, 5)) // 10\r\nconsole.log(subtract(10, 5)) // 5\r\n```\r\n\r\nOn the other hand, library authors can also simply enable ES modules in a Node.js package by changing the file extensions from `.js` to `.mjs`.\r\n\r\nFor example, here’s a simple ES module (with an `.mjs` extension) exporting two functions for public use:\r\n\r\n```javascript\r\n// util.mjs\r\n\r\nexport function add(a, b) {\r\n        return a + b;\r\n}\r\n\r\nexport function subtract(a, b) {\r\n        return a - b;\r\n}\r\n```\r\n\r\nWe can then import both functions using the import statement:\r\n\r\n```javascript\r\n// app.mjs\r\n\r\nimport {add, subtract} from './util.mjs'\r\n\r\nconsole.log(add(5, 5)) // 10\r\nconsole.log(subtract(10, 5)) // 5\r\n```\r\n\r\nAnother way to enable ES modules in your project can be done by adding a `\"type: module\"` field inside the nearest `package.json` file (the same folder as the package you’re making):\r\n\r\n```json\r\n{\r\n  \"name\": \"my-library\",\r\n  \"version\": \"1.0.0\",\r\n  \"type\": \"module\",\r\n  // ...\r\n}\r\n```\r\n\r\nWith that inclusion, Node.js treats all files inside that package as ES modules, and you won’t have to change the file to `.mjs` extension.\r\n\r\nAlternatively, you can install and set up a transpiler like Babel to compile your ES module syntax down to CommonJS syntax. Projects like React and Vue support ES modules because they use Babel under the hood to compile the code.\r\n\r\n---\r\n\r\n## Using ES6 Modules in Browsers\r\n\r\nAt the time of writing, ES6 modules are supported in Chromium-based browsers (v63+), Safari 11+, and Edge 16+. Firefox support will arrive in version 60 (it’s behind an about:config flag in v58+).\r\n\r\nScripts which use modules must be loaded by setting a type=\"module\" attribute in the `<script>` tag. For example:\r\n\r\n```html\r\n<script type=\"module\" src=\"./main.js\"></script>\r\n```\r\n\r\nor inline:\r\n\r\n```html\r\n<script type=\"module\">\r\n  import { something } from './somewhere.js';\r\n  // ...\r\n</script>\r\n```\r\n\r\nModules are parsed once, regardless of how many times they’re referenced in the page or other modules.\r\n\r\n## Should You Use Modules in the Browser?\r\n\r\nBrowser support is growing, but it’s possibly a little premature to switch to ES6 modules. For the moment, it’s probably better to use a module bundler to create a script that works everywhere.\r\n\r\n\r\n\r\n&nbsp;\r\n\r\n## References\r\n\r\n- MDN - JavaScript modules: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules\r\n- Understanding ES6 Modules: https://www.sitepoint.com/understanding-es6-modules/\r\n- CommonJS vs. ES modules in Node.js: https://blog.logrocket.com/commonjs-vs-es-modules-node-js/\r\n- CommonJS vs. ES Modules: Modules and Imports in NodeJS: https://reflectoring.io/nodejs-modules-imports/\r\n",
      "html": "<h1 id=\"modules\">Modules <a class=\"heading-anchor-permalink\" href=\"#modules\">#</a></h1>\n<p>By default, Node.js treats JavaScript code as CommonJS modules. CommonJS modules are characterized by the require() statement for module imports and module.exports for module exports.</p>\n<p>For example, this is a CommonJS module that exports two functions:</p>\n<pre><code class=\"language-javascript\">module.exports.add = function(a, b) {\n        return a + b;\n} \n\nmodule.exports.subtract = function(a, b) {\n        return a - b;\n} \n</code></pre>\n<p>We can also import the public functions into another Node.js script using <code>require()</code>, just as we do here:</p>\n<pre><code class=\"language-javascript\">const {add, subtract} = require('./util')\n\nconsole.log(add(5, 5)) // 10\nconsole.log(subtract(10, 5)) // 5\n</code></pre>\n<p>On the other hand, library authors can also simply enable ES modules in a Node.js package by changing the file extensions from <code>.js</code> to <code>.mjs</code>.</p>\n<p>For example, here’s a simple ES module (with an <code>.mjs</code> extension) exporting two functions for public use:</p>\n<pre><code class=\"language-javascript\">// util.mjs\n\nexport function add(a, b) {\n        return a + b;\n}\n\nexport function subtract(a, b) {\n        return a - b;\n}\n</code></pre>\n<p>We can then import both functions using the import statement:</p>\n<pre><code class=\"language-javascript\">// app.mjs\n\nimport {add, subtract} from './util.mjs'\n\nconsole.log(add(5, 5)) // 10\nconsole.log(subtract(10, 5)) // 5\n</code></pre>\n<p>Another way to enable ES modules in your project can be done by adding a <code>&quot;type: module&quot;</code> field inside the nearest <code>package.json</code> file (the same folder as the package you’re making):</p>\n<pre><code class=\"language-json\">{\n  &quot;name&quot;: &quot;my-library&quot;,\n  &quot;version&quot;: &quot;1.0.0&quot;,\n  &quot;type&quot;: &quot;module&quot;,\n  // ...\n}\n</code></pre>\n<p>With that inclusion, Node.js treats all files inside that package as ES modules, and you won’t have to change the file to <code>.mjs</code> extension.</p>\n<p>Alternatively, you can install and set up a transpiler like Babel to compile your ES module syntax down to CommonJS syntax. Projects like React and Vue support ES modules because they use Babel under the hood to compile the code.</p>\n<hr>\n<h2 id=\"using-es6-modules-in-browsers\">Using ES6 Modules in Browsers <a class=\"heading-anchor-permalink\" href=\"#using-es6-modules-in-browsers\">#</a></h2>\n<p>At the time of writing, ES6 modules are supported in Chromium-based browsers (v63+), Safari 11+, and Edge 16+. Firefox support will arrive in version 60 (it’s behind an about:config flag in v58+).</p>\n<p>Scripts which use modules must be loaded by setting a type=“module” attribute in the <code>&lt;script&gt;</code> tag. For example:</p>\n<pre><code class=\"language-html\">&lt;script type=&quot;module&quot; src=&quot;./main.js&quot;&gt;&lt;/script&gt;\n</code></pre>\n<p>or inline:</p>\n<pre><code class=\"language-html\">&lt;script type=&quot;module&quot;&gt;\n  import { something } from './somewhere.js';\n  // ...\n&lt;/script&gt;\n</code></pre>\n<p>Modules are parsed once, regardless of how many times they’re referenced in the page or other modules.</p>\n<h2 id=\"should-you-use-modules-in-the-browser%3F\">Should You Use Modules in the Browser? <a class=\"heading-anchor-permalink\" href=\"#should-you-use-modules-in-the-browser%3F\">#</a></h2>\n<p>Browser support is growing, but it’s possibly a little premature to switch to ES6 modules. For the moment, it’s probably better to use a module bundler to create a script that works everywhere.</p>\n<p> </p>\n<h2 id=\"references\">References <a class=\"heading-anchor-permalink\" href=\"#references\">#</a></h2>\n<ul>\n<li>MDN - JavaScript modules: <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules\">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules</a></li>\n<li>Understanding ES6 Modules: <a href=\"https://www.sitepoint.com/understanding-es6-modules/\">https://www.sitepoint.com/understanding-es6-modules/</a></li>\n<li>CommonJS vs. ES modules in Node.js: <a href=\"https://blog.logrocket.com/commonjs-vs-es-modules-node-js/\">https://blog.logrocket.com/commonjs-vs-es-modules-node-js/</a></li>\n<li>CommonJS vs. ES Modules: Modules and Imports in NodeJS: <a href=\"https://reflectoring.io/nodejs-modules-imports/\">https://reflectoring.io/nodejs-modules-imports/</a></li>\n</ul>\n",
      "id": 17
    },
    {
      "path": "javascript/promises-async.md",
      "url": "javascript/promises-async.html",
      "content": "# Promises and Asynchronous Functions\r\n\r\n...\r\n\r\n## Promises\r\n\r\nThe Promise object represents the eventual completion (or failure) of an asynchronous operation and its resulting value.\r\n\r\nA Promise is a proxy for a value not necessarily known when the promise is created. It allows you to associate handlers with an asynchronous action's eventual success value or failure reason. This lets asynchronous methods return values like synchronous methods: instead of immediately returning the final value, the asynchronous method returns a promise to supply the value at some point in the future.\r\n\r\nA Promise is in one of these states:\r\n\r\n- pending: initial state, neither fulfilled nor rejected.\r\n- fulfilled: meaning that the operation was completed successfully.\r\n- rejected: meaning that the operation failed.\r\n\r\nA pending promise can either be _fulfilled_ with a value or _rejected_ with a reason (error). When either of these options happens, the associated handlers queued up by a promise's `then` method are called. If the promise has already been fulfilled or rejected when a corresponding handler is attached, the handler will be called, so there is no race condition between an asynchronous operation completing and its handlers being attached.\r\n\r\nJavaScript promises and the Mutation Observer API both use the microtask queue to run their callbacks.\r\n\r\n### Chained Promises\r\n\r\nThe methods `Promise.then()`, `Promise.catch()`, and `Promise.finally()` are used to associate further action with a promise that becomes settled.\r\n\r\nAs the `Promise.then()` and `Promise.catch()` methods return promises, they can be chained.\r\n\r\nThe `.then()` method takes up to two arguments; the first argument is a callback function for the resolved case of the promise, and the second argument is a callback function for the rejected case. Each `.then()` returns a newly generated promise object, which can optionally be used for chaining; for example:\r\n\r\n```javascript\r\nconst myPromise = new Promise((resolve, reject) => {\r\n  setTimeout(() => {\r\n    resolve('foo');\r\n  }, 300);\r\n});\r\n\r\nmyPromise\r\n  .then(handleResolvedA, handleRejectedA)\r\n  .then(handleResolvedB, handleRejectedB)\r\n  .then(handleResolvedC, handleRejectedC);\r\n```\r\n\r\nProcessing continues to the next link of the chain even when a .then() lacks a callback function that returns a Promise object. Therefore, a chain can safely omit every rejection callback function until the final .catch().\r\n\r\nHandling a rejected promise in each `.then()` has consequences further down the promise chain. Sometimes there is no choice, because an error must be handled immediately. In such cases we must throw an error of some type to maintain error state down the chain. On the other hand, in the absence of an immediate need, it is simpler to leave out error handling until a final `.catch()` statement. A `.catch()` is really just a `.then()` without a slot for a callback function for the case when the promise is resolved.\r\n\r\n```javascript\r\nmyPromise\r\n.then(handleResolvedA)\r\n.then(handleResolvedB)\r\n.then(handleResolvedC)\r\n.catch(handleRejectedAny);\r\n\r\n// or \r\n\r\npromise1\r\n.then(value => { return value + ' and bar'; })\r\n.then(value => { return value + ' and bar again'; })\r\n.then(value => { return value + ' and again'; })\r\n.then(value => { return value + ' and again'; })\r\n.then(value => { console.log(value) })\r\n.catch(err => { console.log(err) });\r\n```\r\n\r\nThe termination condition of a promise determines the \"settled\" state of the next promise in the chain. A \"resolved\" state indicates a successful completion of the promise, while a \"rejected\" state indicates a lack of success. The return value of each resolved promise in the chain is passed along to the next `.then()`, while the reason for rejection is passed along to the next rejection-handler function in the chain.\r\n\r\nThe promises of a chain are nested like Russian dolls, but get popped like the top of a stack. The first promise in the chain is most deeply nested and is the first to pop.\r\n\r\n```\r\n(promise D, (promise C, (promise B, (promise A) ) ) )\r\n```\r\n\r\nA promise can participate in more than one nesting. For the following code, the transition of promiseA into a \"settled\" state will cause both instances of `.then()` to be invoked.\r\n\r\n```javascript\r\nconst promiseA = new Promise(myExecutorFunc);\r\nconst promiseB = promiseA.then(handleFulfilled1, handleRejected1);\r\nconst promiseC = promiseA.then(handleFulfilled2, handleRejected2);\r\n```\r\n\r\n## Asynchronous Functions\r\n\r\nAn async function is a function declared with the async keyword, and the await keyword is permitted within it. The async and await keywords enable asynchronous, promise-based behavior to be written in a cleaner style, avoiding the need to explicitly configure promise chains.\r\n\r\nAsync functions can contain zero or more `await` expressions. Await expressions make promise-returning functions behave as though they're synchronous by suspending execution until the returned promise is fulfilled or rejected. The resolved value of the promise is treated as the return value of the await expression. Use of `async` and `await` enables the use of ordinary `try` / `catch` blocks around asynchronous code.\r\n\r\n> Note: The `await` keyword is only valid inside async functions within regular JavaScript code. If you use it outside of an async function's body, you will get a SyntaxError. `await` can be used on its own with JavaScript modules.\r\n\r\n```javascript\r\nfunction resolveAfter2Seconds() {\r\n  return new Promise(resolve => {\r\n    setTimeout(() => {\r\n      resolve('resolved');\r\n    }, 2000);\r\n  });\r\n}\r\n\r\nasync function asyncCall() {\r\n  console.log('calling');\r\n  const result = await resolveAfter2Seconds();\r\n  console.log(result);\r\n  // expected output: \"resolved\"\r\n}\r\n\r\nasyncCall();\r\n\r\n////// OR\r\n\r\nfunction resolveAfter2Seconds(x) {\r\n  return new Promise(resolve => {\r\n    setTimeout(() => {\r\n      resolve(x);\r\n    }, 2000);\r\n  });\r\n};\r\n\r\nconst add = async function(x) { // async function expression assigned to a variable\r\n  let a = await resolveAfter2Seconds(20);\r\n  let b = await resolveAfter2Seconds(30);\r\n  return x + a + b;\r\n};\r\n\r\nadd(10).then(v => {\r\n  console.log(v);  // prints 60 after 4 seconds.\r\n});\r\n\r\n(async function(x) { // async function expression used as an IIFE\r\n  let p_a = resolveAfter2Seconds(20);\r\n  let p_b = resolveAfter2Seconds(30);\r\n  return x + await p_a + await p_b;\r\n})(10).then(v => {\r\n  console.log(v);  // prints 60 after 2 seconds.\r\n});\r\n\r\n////// OR \r\n\r\nconst foo = async () => {\r\n  // do something\r\n}\r\n\r\nconst foo = async evt => {\r\n  // do something with evt\r\n}\r\n\r\nconst foo = async (evt, callback) => {\r\n  // do something with evt\r\n  // return response with callback\r\n}\r\n```\r\n\r\nAsync functions always return a promise. If the return value of an async function is not explicitly a promise, it will be implicitly wrapped in a promise.\r\n\r\nFor example, the following:\r\n\r\n```javascript\r\nasync function foo() {\r\n   return 1\r\n}\r\n```\r\n\r\n...is similar to:\r\n\r\n```javascript\r\nfunction foo() {\r\n   return Promise.resolve(1)\r\n}\r\n```\r\n\r\n> Note: Even though the return value of an async function behaves as if it's wrapped in a Promise.resolve, they are not equivalent. An async function will return a different reference, whereas Promise.resolve returns the same reference if the given value is a promise.\r\n\r\nThe body of an async function can be thought of as being split by zero or more await expressions. Top-level code, up to and including the first await expression (if there is one), is run synchronously. In this way, an async function without an await expression will run synchronously. If there is an await expression inside the function body, however, the async function will always complete asynchronously.\r\n\r\nFor example:\r\n\r\n```javascript\r\nasync function foo() {\r\n   await 1\r\n}\r\n```\r\n\r\n...is equivalent to:\r\n\r\n```javascript\r\nfunction foo() {\r\n   return Promise.resolve(1).then(() => undefined)\r\n}\r\n```\r\n\r\nCode after each await expression can be thought of as existing in a .then callback. In this way a promise chain is progressively constructed with each reentrant step through the function. The return value forms the final link in the chain.\r\n\r\n## References\r\n\r\nMDN: Promise -- https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise\r\n\r\nMDN: Promise guide -- https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises\r\n\r\nMDN: async function -- https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function\r\n\r\nIntro to Async Web Dev - Part 1: Callbacks: https://www.youtube.com/watch?v=ueOG5uk7zo8\r\n\r\nIntro to Async Web Dev - Part 2: Promises: https://www.youtube.com/watch?v=f8IPKdQS1Cs\r\n\r\nJavaScript Promise in 100 Seconds: https://www.youtube.com/watch?v=RvYYCGs45L4\r\n\r\n**The Async Await Episode I Promised: https://www.youtube.com/watch?v=vn3tm0quoqE**\r\n",
      "html": "<h1 id=\"promises-and-asynchronous-functions\">Promises and Asynchronous Functions <a class=\"heading-anchor-permalink\" href=\"#promises-and-asynchronous-functions\">#</a></h1>\n<p>…</p>\n<h2 id=\"promises\">Promises <a class=\"heading-anchor-permalink\" href=\"#promises\">#</a></h2>\n<p>The Promise object represents the eventual completion (or failure) of an asynchronous operation and its resulting value.</p>\n<p>A Promise is a proxy for a value not necessarily known when the promise is created. It allows you to associate handlers with an asynchronous action’s eventual success value or failure reason. This lets asynchronous methods return values like synchronous methods: instead of immediately returning the final value, the asynchronous method returns a promise to supply the value at some point in the future.</p>\n<p>A Promise is in one of these states:</p>\n<ul>\n<li>pending: initial state, neither fulfilled nor rejected.</li>\n<li>fulfilled: meaning that the operation was completed successfully.</li>\n<li>rejected: meaning that the operation failed.</li>\n</ul>\n<p>A pending promise can either be <em>fulfilled</em> with a value or <em>rejected</em> with a reason (error). When either of these options happens, the associated handlers queued up by a promise’s <code>then</code> method are called. If the promise has already been fulfilled or rejected when a corresponding handler is attached, the handler will be called, so there is no race condition between an asynchronous operation completing and its handlers being attached.</p>\n<p>JavaScript promises and the Mutation Observer API both use the microtask queue to run their callbacks.</p>\n<h3 id=\"chained-promises\">Chained Promises <a class=\"heading-anchor-permalink\" href=\"#chained-promises\">#</a></h3>\n<p>The methods <code>Promise.then()</code>, <code>Promise.catch()</code>, and <code>Promise.finally()</code> are used to associate further action with a promise that becomes settled.</p>\n<p>As the <code>Promise.then()</code> and <code>Promise.catch()</code> methods return promises, they can be chained.</p>\n<p>The <code>.then()</code> method takes up to two arguments; the first argument is a callback function for the resolved case of the promise, and the second argument is a callback function for the rejected case. Each <code>.then()</code> returns a newly generated promise object, which can optionally be used for chaining; for example:</p>\n<pre><code class=\"language-javascript\">const myPromise = new Promise((resolve, reject) =&gt; {\n  setTimeout(() =&gt; {\n    resolve('foo');\n  }, 300);\n});\n\nmyPromise\n  .then(handleResolvedA, handleRejectedA)\n  .then(handleResolvedB, handleRejectedB)\n  .then(handleResolvedC, handleRejectedC);\n</code></pre>\n<p>Processing continues to the next link of the chain even when a .then() lacks a callback function that returns a Promise object. Therefore, a chain can safely omit every rejection callback function until the final .catch().</p>\n<p>Handling a rejected promise in each <code>.then()</code> has consequences further down the promise chain. Sometimes there is no choice, because an error must be handled immediately. In such cases we must throw an error of some type to maintain error state down the chain. On the other hand, in the absence of an immediate need, it is simpler to leave out error handling until a final <code>.catch()</code> statement. A <code>.catch()</code> is really just a <code>.then()</code> without a slot for a callback function for the case when the promise is resolved.</p>\n<pre><code class=\"language-javascript\">myPromise\n.then(handleResolvedA)\n.then(handleResolvedB)\n.then(handleResolvedC)\n.catch(handleRejectedAny);\n\n// or \n\npromise1\n.then(value =&gt; { return value + ' and bar'; })\n.then(value =&gt; { return value + ' and bar again'; })\n.then(value =&gt; { return value + ' and again'; })\n.then(value =&gt; { return value + ' and again'; })\n.then(value =&gt; { console.log(value) })\n.catch(err =&gt; { console.log(err) });\n</code></pre>\n<p>The termination condition of a promise determines the “settled” state of the next promise in the chain. A “resolved” state indicates a successful completion of the promise, while a “rejected” state indicates a lack of success. The return value of each resolved promise in the chain is passed along to the next <code>.then()</code>, while the reason for rejection is passed along to the next rejection-handler function in the chain.</p>\n<p>The promises of a chain are nested like Russian dolls, but get popped like the top of a stack. The first promise in the chain is most deeply nested and is the first to pop.</p>\n<pre><code>(promise D, (promise C, (promise B, (promise A) ) ) )\n</code></pre>\n<p>A promise can participate in more than one nesting. For the following code, the transition of promiseA into a “settled” state will cause both instances of <code>.then()</code> to be invoked.</p>\n<pre><code class=\"language-javascript\">const promiseA = new Promise(myExecutorFunc);\nconst promiseB = promiseA.then(handleFulfilled1, handleRejected1);\nconst promiseC = promiseA.then(handleFulfilled2, handleRejected2);\n</code></pre>\n<h2 id=\"asynchronous-functions\">Asynchronous Functions <a class=\"heading-anchor-permalink\" href=\"#asynchronous-functions\">#</a></h2>\n<p>An async function is a function declared with the async keyword, and the await keyword is permitted within it. The async and await keywords enable asynchronous, promise-based behavior to be written in a cleaner style, avoiding the need to explicitly configure promise chains.</p>\n<p>Async functions can contain zero or more <code>await</code> expressions. Await expressions make promise-returning functions behave as though they’re synchronous by suspending execution until the returned promise is fulfilled or rejected. The resolved value of the promise is treated as the return value of the await expression. Use of <code>async</code> and <code>await</code> enables the use of ordinary <code>try</code> / <code>catch</code> blocks around asynchronous code.</p>\n<blockquote>\n<p>Note: The <code>await</code> keyword is only valid inside async functions within regular JavaScript code. If you use it outside of an async function’s body, you will get a SyntaxError. <code>await</code> can be used on its own with JavaScript modules.</p>\n</blockquote>\n<pre><code class=\"language-javascript\">function resolveAfter2Seconds() {\n  return new Promise(resolve =&gt; {\n    setTimeout(() =&gt; {\n      resolve('resolved');\n    }, 2000);\n  });\n}\n\nasync function asyncCall() {\n  console.log('calling');\n  const result = await resolveAfter2Seconds();\n  console.log(result);\n  // expected output: &quot;resolved&quot;\n}\n\nasyncCall();\n\n////// OR\n\nfunction resolveAfter2Seconds(x) {\n  return new Promise(resolve =&gt; {\n    setTimeout(() =&gt; {\n      resolve(x);\n    }, 2000);\n  });\n};\n\nconst add = async function(x) { // async function expression assigned to a variable\n  let a = await resolveAfter2Seconds(20);\n  let b = await resolveAfter2Seconds(30);\n  return x + a + b;\n};\n\nadd(10).then(v =&gt; {\n  console.log(v);  // prints 60 after 4 seconds.\n});\n\n(async function(x) { // async function expression used as an IIFE\n  let p_a = resolveAfter2Seconds(20);\n  let p_b = resolveAfter2Seconds(30);\n  return x + await p_a + await p_b;\n})(10).then(v =&gt; {\n  console.log(v);  // prints 60 after 2 seconds.\n});\n\n////// OR \n\nconst foo = async () =&gt; {\n  // do something\n}\n\nconst foo = async evt =&gt; {\n  // do something with evt\n}\n\nconst foo = async (evt, callback) =&gt; {\n  // do something with evt\n  // return response with callback\n}\n</code></pre>\n<p>Async functions always return a promise. If the return value of an async function is not explicitly a promise, it will be implicitly wrapped in a promise.</p>\n<p>For example, the following:</p>\n<pre><code class=\"language-javascript\">async function foo() {\n   return 1\n}\n</code></pre>\n<p>…is similar to:</p>\n<pre><code class=\"language-javascript\">function foo() {\n   return Promise.resolve(1)\n}\n</code></pre>\n<blockquote>\n<p>Note: Even though the return value of an async function behaves as if it’s wrapped in a Promise.resolve, they are not equivalent. An async function will return a different reference, whereas Promise.resolve returns the same reference if the given value is a promise.</p>\n</blockquote>\n<p>The body of an async function can be thought of as being split by zero or more await expressions. Top-level code, up to and including the first await expression (if there is one), is run synchronously. In this way, an async function without an await expression will run synchronously. If there is an await expression inside the function body, however, the async function will always complete asynchronously.</p>\n<p>For example:</p>\n<pre><code class=\"language-javascript\">async function foo() {\n   await 1\n}\n</code></pre>\n<p>…is equivalent to:</p>\n<pre><code class=\"language-javascript\">function foo() {\n   return Promise.resolve(1).then(() =&gt; undefined)\n}\n</code></pre>\n<p>Code after each await expression can be thought of as existing in a .then callback. In this way a promise chain is progressively constructed with each reentrant step through the function. The return value forms the final link in the chain.</p>\n<h2 id=\"references\">References <a class=\"heading-anchor-permalink\" href=\"#references\">#</a></h2>\n<p>MDN: Promise – <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise\">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise</a></p>\n<p>MDN: Promise guide – <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises\">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises</a></p>\n<p>MDN: async function – <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function\">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function</a></p>\n<p>Intro to Async Web Dev - Part 1: Callbacks: <a href=\"https://www.youtube.com/watch?v=ueOG5uk7zo8\">https://www.youtube.com/watch?v=ueOG5uk7zo8</a></p>\n<p>Intro to Async Web Dev - Part 2: Promises: <a href=\"https://www.youtube.com/watch?v=f8IPKdQS1Cs\">https://www.youtube.com/watch?v=f8IPKdQS1Cs</a></p>\n<p>JavaScript Promise in 100 Seconds: <a href=\"https://www.youtube.com/watch?v=RvYYCGs45L4\">https://www.youtube.com/watch?v=RvYYCGs45L4</a></p>\n<p><strong>The Async Await Episode I Promised: <a href=\"https://www.youtube.com/watch?v=vn3tm0quoqE\">https://www.youtube.com/watch?v=vn3tm0quoqE</a></strong></p>\n",
      "id": 18
    },
    {
      "path": "javascript/set.md",
      "url": "javascript/set.html",
      "content": "# Set\r\n\r\nThe Set object lets you store unique values of any type, whether primitive values or object references.\r\n\r\nSet objects are collections of values. You can iterate through the elements of a set in insertion order. A value in the Set may only occur once; it is unique in the Set's collection.\r\n\r\n## Value equality\r\n\r\nBecause each value in the Set has to be unique, the value equality will be checked. In an earlier version of ECMAScript specification, this was not based on the same algorithm as the one used in the === operator. Specifically, for Sets, +0 (which is strictly equal to -0) and -0 were different values. However, this was changed in the ECMAScript 2015 specification.\r\n\r\nNaN and undefined can also be stored in a Set. All NaN values are equated (i.e. NaN is considered the same as NaN, even though NaN !== NaN).\r\n\r\n```javascript\r\nconst mySet1 = new Set()\r\n\r\nmySet1.add(1)           // Set [ 1 ]\r\nmySet1.add(5)           // Set [ 1, 5 ]\r\nmySet1.add(5)           // Set [ 1, 5 ]\r\nmySet1.add('some text') // Set [ 1, 5, 'some text' ]\r\nconst o = {a: 1, b: 2}\r\nmySet1.add(o)\r\n\r\nmySet1.add({a: 1, b: 2})   // o is referencing a different object, so this is okay\r\n\r\nmySet1.has(1)              // true\r\nmySet1.has(3)              // false, since 3 has not been added to the set\r\nmySet1.has(5)              // true\r\nmySet1.has(Math.sqrt(25))  // true\r\nmySet1.has('Some Text'.toLowerCase()) // true\r\nmySet1.has(o)       // true\r\n\r\nmySet1.size         // 5\r\n\r\nmySet1.delete(5)    // removes 5 from the set\r\nmySet1.has(5)       // false, 5 has been removed\r\n\r\nmySet1.size         // 4, since we just removed one value\r\n\r\nconsole.log(mySet1)\r\n// logs Set(4) [ 1, \"some text\", {…}, {…} ] in Firefox\r\n// logs Set(4) { 1, \"some text\", {…}, {…} } in Chrome\r\n```\r\n\r\n&nbsp;\r\n\r\n## Set.add()\r\n\r\nThe add() method appends a new element with a specified value to the end of a Set object.\r\n\r\n### Return value\r\n\r\nThe Set object with added value.\r\n\r\n&nbsp;\r\n\r\n## Set.has()\r\n\r\nThe has() method returns a boolean indicating whether an element with the specified value exists in a Set object or not.\r\n\r\n### Return value\r\n\r\nReturns true if an element with the specified value exists in the Set object; otherwise false.\r\n\r\n&nbsp;\r\n\r\n## Set.delete()\r\n\r\nThe delete() method removes a specified value from a Set object, if it is in the set.\r\n\r\n### Return value\r\n\r\nReturns true if value was already in Set; otherwise false.\r\n\r\n&nbsp;\r\n\r\n## Set.clear()\r\n\r\nThe clear() method removes all elements from a Set object.\r\n\r\n### Return value\r\n\r\nundefined\r\n\r\n&nbsp;\r\n\r\n## References\r\n\r\n...\r\n",
      "html": "<h1 id=\"set\">Set <a class=\"heading-anchor-permalink\" href=\"#set\">#</a></h1>\n<p>The Set object lets you store unique values of any type, whether primitive values or object references.</p>\n<p>Set objects are collections of values. You can iterate through the elements of a set in insertion order. A value in the Set may only occur once; it is unique in the Set’s collection.</p>\n<h2 id=\"value-equality\">Value equality <a class=\"heading-anchor-permalink\" href=\"#value-equality\">#</a></h2>\n<p>Because each value in the Set has to be unique, the value equality will be checked. In an earlier version of ECMAScript specification, this was not based on the same algorithm as the one used in the === operator. Specifically, for Sets, +0 (which is strictly equal to -0) and -0 were different values. However, this was changed in the ECMAScript 2015 specification.</p>\n<p>NaN and undefined can also be stored in a Set. All NaN values are equated (i.e. NaN is considered the same as NaN, even though NaN !== NaN).</p>\n<pre><code class=\"language-javascript\">const mySet1 = new Set()\n\nmySet1.add(1)           // Set [ 1 ]\nmySet1.add(5)           // Set [ 1, 5 ]\nmySet1.add(5)           // Set [ 1, 5 ]\nmySet1.add('some text') // Set [ 1, 5, 'some text' ]\nconst o = {a: 1, b: 2}\nmySet1.add(o)\n\nmySet1.add({a: 1, b: 2})   // o is referencing a different object, so this is okay\n\nmySet1.has(1)              // true\nmySet1.has(3)              // false, since 3 has not been added to the set\nmySet1.has(5)              // true\nmySet1.has(Math.sqrt(25))  // true\nmySet1.has('Some Text'.toLowerCase()) // true\nmySet1.has(o)       // true\n\nmySet1.size         // 5\n\nmySet1.delete(5)    // removes 5 from the set\nmySet1.has(5)       // false, 5 has been removed\n\nmySet1.size         // 4, since we just removed one value\n\nconsole.log(mySet1)\n// logs Set(4) [ 1, &quot;some text&quot;, {…}, {…} ] in Firefox\n// logs Set(4) { 1, &quot;some text&quot;, {…}, {…} } in Chrome\n</code></pre>\n<p> </p>\n<h2 id=\"set.add()\">Set.add() <a class=\"heading-anchor-permalink\" href=\"#set.add()\">#</a></h2>\n<p>The add() method appends a new element with a specified value to the end of a Set object.</p>\n<h3 id=\"return-value\">Return value <a class=\"heading-anchor-permalink\" href=\"#return-value\">#</a></h3>\n<p>The Set object with added value.</p>\n<p> </p>\n<h2 id=\"set.has()\">Set.has() <a class=\"heading-anchor-permalink\" href=\"#set.has()\">#</a></h2>\n<p>The has() method returns a boolean indicating whether an element with the specified value exists in a Set object or not.</p>\n<h3 id=\"return-value-2\">Return value <a class=\"heading-anchor-permalink\" href=\"#return-value-2\">#</a></h3>\n<p>Returns true if an element with the specified value exists in the Set object; otherwise false.</p>\n<p> </p>\n<h2 id=\"set.delete()\">Set.delete() <a class=\"heading-anchor-permalink\" href=\"#set.delete()\">#</a></h2>\n<p>The delete() method removes a specified value from a Set object, if it is in the set.</p>\n<h3 id=\"return-value-3\">Return value <a class=\"heading-anchor-permalink\" href=\"#return-value-3\">#</a></h3>\n<p>Returns true if value was already in Set; otherwise false.</p>\n<p> </p>\n<h2 id=\"set.clear()\">Set.clear() <a class=\"heading-anchor-permalink\" href=\"#set.clear()\">#</a></h2>\n<p>The clear() method removes all elements from a Set object.</p>\n<h3 id=\"return-value-4\">Return value <a class=\"heading-anchor-permalink\" href=\"#return-value-4\">#</a></h3>\n<p>undefined</p>\n<p> </p>\n<h2 id=\"references\">References <a class=\"heading-anchor-permalink\" href=\"#references\">#</a></h2>\n<p>…</p>\n",
      "id": 19
    },
    {
      "path": "lists/1-array.md",
      "url": "lists/1-array.html",
      "content": "# Array\r\n\r\nIn computer science, an array data structure, or simply an array, is a data structure consisting of a collection of elements (values or variables), each identified by at least one array index or key. An array is stored such that the position of each element can be computed from its index tuple by a mathematical formula.[1][2][3] The simplest type of data structure is a linear array, also called one-dimensional array.\r\n\r\nFor example, an array of 10 32-bit integer variables, with indices 0 through 9, may be stored as 10 words at memory addresses 2000, 2004, 2008, ... 2036, so that the element with index i has the address 2000 + 4 × i.[4]\r\n\r\nThe memory address of the first element of an array is called first address or foundation address.\r\n\r\nBecause the mathematical concept of a matrix can be represented as a two-dimensional grid, two-dimensional arrays are also sometimes called matrices. In some cases the term \"vector\" is used in computing to refer to an array, although tuples rather than vectors are the more mathematically correct equivalent. Tables are often implemented in the form of arrays, especially lookup tables; the word table is sometimes used as a synonym of array.\r\n\r\nArrays are among the oldest and most important data structures, and are used by almost every program. They are also used to implement many other data structures, such as lists and strings. They effectively exploit the addressing logic of computers. In most modern computers and many external storage devices, the memory is a one-dimensional array of words, whose indices are their addresses. Processors, especially vector processors, are often optimized for array operations.\r\n\r\nArrays are useful mostly because the element indices can be computed at run time. Among other things, this feature allows a single iterative statement to process arbitrarily many elements of an array. For that reason, the elements of an array data structure are required to have the same size and should use the same data representation. The set of valid index tuples and the addresses of the elements (and hence the element addressing formula) are usually,[3][5] but not always,[2] fixed while the array is in use.\r\n\r\nThe term array is often used to mean array data type, a kind of data type provided by most high-level programming languages that consists of a collection of values or variables that can be selected by one or more indices computed at run-time. Array types are often implemented by array structures; however, in some languages they may be implemented by hash tables, linked lists, search trees, or other data structures.\r\n\r\nThe term is also used, especially in the description of algorithms, to mean associative array or \"abstract array\", a theoretical computer science model (an abstract data type or ADT) intended to capture the essential properties of arrays.\r\n\r\n## References\r\n\r\n- [Wikipedia](https://en.wikipedia.org/wiki/Array_data_structure)\r\n- ...\r\n",
      "html": "<h1 id=\"array\">Array <a class=\"heading-anchor-permalink\" href=\"#array\">#</a></h1>\n<p>In computer science, an array data structure, or simply an array, is a data structure consisting of a collection of elements (values or variables), each identified by at least one array index or key. An array is stored such that the position of each element can be computed from its index tuple by a mathematical formula.[1][2][3] The simplest type of data structure is a linear array, also called one-dimensional array.</p>\n<p>For example, an array of 10 32-bit integer variables, with indices 0 through 9, may be stored as 10 words at memory addresses 2000, 2004, 2008, … 2036, so that the element with index i has the address 2000 + 4 × i.[4]</p>\n<p>The memory address of the first element of an array is called first address or foundation address.</p>\n<p>Because the mathematical concept of a matrix can be represented as a two-dimensional grid, two-dimensional arrays are also sometimes called matrices. In some cases the term “vector” is used in computing to refer to an array, although tuples rather than vectors are the more mathematically correct equivalent. Tables are often implemented in the form of arrays, especially lookup tables; the word table is sometimes used as a synonym of array.</p>\n<p>Arrays are among the oldest and most important data structures, and are used by almost every program. They are also used to implement many other data structures, such as lists and strings. They effectively exploit the addressing logic of computers. In most modern computers and many external storage devices, the memory is a one-dimensional array of words, whose indices are their addresses. Processors, especially vector processors, are often optimized for array operations.</p>\n<p>Arrays are useful mostly because the element indices can be computed at run time. Among other things, this feature allows a single iterative statement to process arbitrarily many elements of an array. For that reason, the elements of an array data structure are required to have the same size and should use the same data representation. The set of valid index tuples and the addresses of the elements (and hence the element addressing formula) are usually,[3][5] but not always,[2] fixed while the array is in use.</p>\n<p>The term array is often used to mean array data type, a kind of data type provided by most high-level programming languages that consists of a collection of values or variables that can be selected by one or more indices computed at run-time. Array types are often implemented by array structures; however, in some languages they may be implemented by hash tables, linked lists, search trees, or other data structures.</p>\n<p>The term is also used, especially in the description of algorithms, to mean associative array or “abstract array”, a theoretical computer science model (an abstract data type or ADT) intended to capture the essential properties of arrays.</p>\n<h2 id=\"references\">References <a class=\"heading-anchor-permalink\" href=\"#references\">#</a></h2>\n<ul>\n<li><a href=\"https://en.wikipedia.org/wiki/Array_data_structure\">Wikipedia</a></li>\n<li>…</li>\n</ul>\n",
      "id": 20
    },
    {
      "path": "lists/2-dynamic-array.md",
      "url": "lists/2-dynamic-array.html",
      "content": "# Dynamic array\r\n\r\nIn computer science, a dynamic array, growable array, resizable array, dynamic table, mutable array, or array list is a random access, variable-size list data structure that allows elements to be added or removed. It is supplied with standard libraries in many modern mainstream programming languages. Dynamic arrays overcome a limit of static arrays, which have a fixed capacity that needs to be specified at allocation.\r\n\r\nA dynamic array is not the same thing as a dynamically allocated array, which is an array whose size is fixed when the array is allocated, although a dynamic array may use such a fixed-size array as a back end.[1]\r\n\r\n## References\r\n\r\n- [Wikipedia](https://en.wikipedia.org/wiki/Dynamic_array)\r\n- ...\r\n",
      "html": "<h1 id=\"dynamic-array\">Dynamic array <a class=\"heading-anchor-permalink\" href=\"#dynamic-array\">#</a></h1>\n<p>In computer science, a dynamic array, growable array, resizable array, dynamic table, mutable array, or array list is a random access, variable-size list data structure that allows elements to be added or removed. It is supplied with standard libraries in many modern mainstream programming languages. Dynamic arrays overcome a limit of static arrays, which have a fixed capacity that needs to be specified at allocation.</p>\n<p>A dynamic array is not the same thing as a dynamically allocated array, which is an array whose size is fixed when the array is allocated, although a dynamic array may use such a fixed-size array as a back end.[1]</p>\n<h2 id=\"references\">References <a class=\"heading-anchor-permalink\" href=\"#references\">#</a></h2>\n<ul>\n<li><a href=\"https://en.wikipedia.org/wiki/Dynamic_array\">Wikipedia</a></li>\n<li>…</li>\n</ul>\n",
      "id": 21
    },
    {
      "path": "lists/3-linked-list.md",
      "url": "lists/3-linked-list.html",
      "content": "# Linked List\r\n\r\n_Read this in other languages:_\r\n[_简体中文_](README.zh-CN.md),\r\n[_Русский_](README.ru-RU.md)\r\n\r\nIn computer science, a **linked list** is a linear collection \r\nof data elements, in which linear order is not given by \r\ntheir physical placement in memory. Instead, each \r\nelement points to the next. It is a data structure \r\nconsisting of a group of nodes which together represent \r\na sequence. Under the simplest form, each node is \r\ncomposed of data and a reference (in other words, \r\na link) to the next node in the sequence. This structure\r\nallows for efficient insertion or removal of elements \r\nfrom any position in the sequence during iteration. \r\nMore complex variants add additional links, allowing \r\nefficient insertion or removal from arbitrary element \r\nreferences. A drawback of linked lists is that access \r\ntime is linear (and difficult to pipeline). Faster \r\naccess, such as random access, is not feasible. Arrays \r\nhave better cache locality as compared to linked lists.\r\n\r\n![Linked List](https://upload.wikimedia.org/wikipedia/commons/6/6d/Singly-linked-list.svg)\r\n\r\n## Javascript\r\n\r\n```javascript\r\nclass SinglyLinkedListNode {\r\n    constructor(nodeData, next = null) {\r\n        this.data = nodeData;\r\n        this.next = next;\r\n    }\r\n};\r\n\r\nclass SinglyLinkedList {\r\n    constructor() {\r\n        this.head = null;\r\n        this.tail = null;\r\n    }\r\n\r\n    insertNode(nodeData) {\r\n        const node = new SinglyLinkedListNode(nodeData);\r\n\r\n        if (this.head == null) {\r\n            this.head = node;\r\n        } else {\r\n            this.tail.next = node;\r\n        }\r\n\r\n        this.tail = node;\r\n    }\r\n\r\n    getAt(index) {\r\n        let counter = 0;\r\n        let node = this.head;\r\n        while (node) {\r\n            if (counter === index) {\r\n               return node;\r\n            }\r\n            counter++;\r\n            node = node.next;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    insertAt(nodeData, index) {\r\n        // if the list is empty i.e. head = null\r\n        if (!this.head) {\r\n            this.head = new SinglyLinkedListNode(nodeData);\r\n            return;\r\n        }\r\n        // if new node needs to be inserted at the front of the list i.e. before the head. \r\n        if (index === 0) {\r\n           this.head = new SinglyLinkedListNode(nodeData, this.head);\r\n           return;\r\n        }\r\n        // else, use getAt() to find the previous node.\r\n        const previous = this.getAt(index - 1);\r\n        let newNode = new SinglyLinkedListNode(nodeData);\r\n        newNode.next = previous.next;\r\n        previous.next = newNode;\r\n\r\n        return this.head\r\n   }\r\n};\r\n```\r\n\r\n## Pseudocode for Basic Operations\r\n\r\n### Insert\r\n\r\n```text\r\nAdd(value)\r\n  Pre: value is the value to add to the list\r\n  Post: value has been placed at the tail of the list\r\n  n ← node(value)\r\n  if head = ø\r\n    head ← n\r\n    tail ← n\r\n  else\r\n    tail.next ← n\r\n    tail ← n\r\n  end if\r\nend Add\r\n```\r\n\r\n```text\r\nPrepend(value)\r\n Pre: value is the value to add to the list\r\n Post: value has been placed at the head of the list\r\n n ← node(value)\r\n n.next ← head\r\n head ← n\r\n if tail = ø\r\n   tail ← n\r\n end\r\nend Prepend\r\n```\r\n\r\n### Search\r\n\r\n```text\r\nContains(head, value)\r\n  Pre: head is the head node in the list\r\n       value is the value to search for\r\n  Post: the item is either in the linked list, true; otherwise false\r\n  n ← head\r\n  while n != ø and n.value != value\r\n    n ← n.next\r\n  end while\r\n  if n = ø\r\n    return false\r\n  end if\r\n  return true\r\nend Contains\r\n```\r\n    \r\n### Delete\r\n\r\n```text\r\nRemove(head, value)\r\n  Pre: head is the head node in the list\r\n       value is the value to remove from the list\r\n  Post: value is removed from the list, true, otherwise false\r\n  if head = ø\r\n    return false\r\n  end if\r\n  n ← head\r\n  if n.value = value\r\n    if head = tail\r\n      head ← ø\r\n      tail ← ø\r\n    else\r\n      head ← head.next\r\n    end if\r\n    return true\r\n  end if\r\n  while n.next != ø and n.next.value != value\r\n    n ← n.next\r\n  end while\r\n  if n.next != ø\r\n    if n.next = tail\r\n      tail ← n\r\n    end if\r\n    n.next ← n.next.next\r\n    return true\r\n  end if\r\n  return false\r\nend Remove\r\n```\r\n\r\n### Traverse\r\n\r\n```text\r\nTraverse(head)\r\n  Pre: head is the head node in the list\r\n  Post: the items in the list have been traversed\r\n  n ← head\r\n  while n != ø\r\n    yield n.value\r\n    n ← n.next\r\n  end while\r\nend Traverse\r\n```\r\n\r\n### Traverse in Reverse\r\n\r\n```text\r\nReverseTraversal(head, tail)\r\n  Pre: head and tail belong to the same list\r\n  Post: the items in the list have been traversed in reverse order\r\n  if tail != ø\r\n    curr ← tail\r\n    while curr != head\r\n      prev ← head\r\n      while prev.next != curr\r\n        prev ← prev.next\r\n      end while\r\n      yield curr.value\r\n      curr ← prev\r\n    end while\r\n   yeild curr.value\r\n  end if\r\nend ReverseTraversal\r\n```\r\n\r\n## Complexities\r\n\r\n### Time Complexity\r\n\r\n| Access    | Search    | Insertion | Deletion  |\r\n| :-------: | :-------: | :-------: | :-------: |\r\n| O(n)      | O(n)      | O(1)      | O(1)      |\r\n\r\n### Space Complexity\r\n\r\nO(n)\r\n\r\n## References\r\n\r\n- [Wikipedia](https://en.wikipedia.org/wiki/Linked_list)\r\n- [YouTube](https://www.youtube.com/watch?v=njTh_OwMljA&index=2&t=1s&list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8)\r\n",
      "html": "<h1 id=\"linked-list\">Linked List <a class=\"heading-anchor-permalink\" href=\"#linked-list\">#</a></h1>\n<p><em>Read this in other languages:</em>\n<a href=\"README.zh-CN.html\"><em>简体中文</em></a>,\n<a href=\"README.ru-RU.html\"><em>Русский</em></a></p>\n<p>In computer science, a <strong>linked list</strong> is a linear collection\nof data elements, in which linear order is not given by\ntheir physical placement in memory. Instead, each\nelement points to the next. It is a data structure\nconsisting of a group of nodes which together represent\na sequence. Under the simplest form, each node is\ncomposed of data and a reference (in other words,\na link) to the next node in the sequence. This structure\nallows for efficient insertion or removal of elements\nfrom any position in the sequence during iteration.\nMore complex variants add additional links, allowing\nefficient insertion or removal from arbitrary element\nreferences. A drawback of linked lists is that access\ntime is linear (and difficult to pipeline). Faster\naccess, such as random access, is not feasible. Arrays\nhave better cache locality as compared to linked lists.</p>\n<p><img src=\"https://upload.wikimedia.org/wikipedia/commons/6/6d/Singly-linked-list.svg\" alt=\"Linked List\"></p>\n<h2 id=\"javascript\">Javascript <a class=\"heading-anchor-permalink\" href=\"#javascript\">#</a></h2>\n<pre><code class=\"language-javascript\">class SinglyLinkedListNode {\n    constructor(nodeData, next = null) {\n        this.data = nodeData;\n        this.next = next;\n    }\n};\n\nclass SinglyLinkedList {\n    constructor() {\n        this.head = null;\n        this.tail = null;\n    }\n\n    insertNode(nodeData) {\n        const node = new SinglyLinkedListNode(nodeData);\n\n        if (this.head == null) {\n            this.head = node;\n        } else {\n            this.tail.next = node;\n        }\n\n        this.tail = node;\n    }\n\n    getAt(index) {\n        let counter = 0;\n        let node = this.head;\n        while (node) {\n            if (counter === index) {\n               return node;\n            }\n            counter++;\n            node = node.next;\n        }\n        return null;\n    }\n\n    insertAt(nodeData, index) {\n        // if the list is empty i.e. head = null\n        if (!this.head) {\n            this.head = new SinglyLinkedListNode(nodeData);\n            return;\n        }\n        // if new node needs to be inserted at the front of the list i.e. before the head. \n        if (index === 0) {\n           this.head = new SinglyLinkedListNode(nodeData, this.head);\n           return;\n        }\n        // else, use getAt() to find the previous node.\n        const previous = this.getAt(index - 1);\n        let newNode = new SinglyLinkedListNode(nodeData);\n        newNode.next = previous.next;\n        previous.next = newNode;\n\n        return this.head\n   }\n};\n</code></pre>\n<h2 id=\"pseudocode-for-basic-operations\">Pseudocode for Basic Operations <a class=\"heading-anchor-permalink\" href=\"#pseudocode-for-basic-operations\">#</a></h2>\n<h3 id=\"insert\">Insert <a class=\"heading-anchor-permalink\" href=\"#insert\">#</a></h3>\n<pre><code class=\"language-text\">Add(value)\n  Pre: value is the value to add to the list\n  Post: value has been placed at the tail of the list\n  n ← node(value)\n  if head = ø\n    head ← n\n    tail ← n\n  else\n    tail.next ← n\n    tail ← n\n  end if\nend Add\n</code></pre>\n<pre><code class=\"language-text\">Prepend(value)\n Pre: value is the value to add to the list\n Post: value has been placed at the head of the list\n n ← node(value)\n n.next ← head\n head ← n\n if tail = ø\n   tail ← n\n end\nend Prepend\n</code></pre>\n<h3 id=\"search\">Search <a class=\"heading-anchor-permalink\" href=\"#search\">#</a></h3>\n<pre><code class=\"language-text\">Contains(head, value)\n  Pre: head is the head node in the list\n       value is the value to search for\n  Post: the item is either in the linked list, true; otherwise false\n  n ← head\n  while n != ø and n.value != value\n    n ← n.next\n  end while\n  if n = ø\n    return false\n  end if\n  return true\nend Contains\n</code></pre>\n<h3 id=\"delete\">Delete <a class=\"heading-anchor-permalink\" href=\"#delete\">#</a></h3>\n<pre><code class=\"language-text\">Remove(head, value)\n  Pre: head is the head node in the list\n       value is the value to remove from the list\n  Post: value is removed from the list, true, otherwise false\n  if head = ø\n    return false\n  end if\n  n ← head\n  if n.value = value\n    if head = tail\n      head ← ø\n      tail ← ø\n    else\n      head ← head.next\n    end if\n    return true\n  end if\n  while n.next != ø and n.next.value != value\n    n ← n.next\n  end while\n  if n.next != ø\n    if n.next = tail\n      tail ← n\n    end if\n    n.next ← n.next.next\n    return true\n  end if\n  return false\nend Remove\n</code></pre>\n<h3 id=\"traverse\">Traverse <a class=\"heading-anchor-permalink\" href=\"#traverse\">#</a></h3>\n<pre><code class=\"language-text\">Traverse(head)\n  Pre: head is the head node in the list\n  Post: the items in the list have been traversed\n  n ← head\n  while n != ø\n    yield n.value\n    n ← n.next\n  end while\nend Traverse\n</code></pre>\n<h3 id=\"traverse-in-reverse\">Traverse in Reverse <a class=\"heading-anchor-permalink\" href=\"#traverse-in-reverse\">#</a></h3>\n<pre><code class=\"language-text\">ReverseTraversal(head, tail)\n  Pre: head and tail belong to the same list\n  Post: the items in the list have been traversed in reverse order\n  if tail != ø\n    curr ← tail\n    while curr != head\n      prev ← head\n      while prev.next != curr\n        prev ← prev.next\n      end while\n      yield curr.value\n      curr ← prev\n    end while\n   yeild curr.value\n  end if\nend ReverseTraversal\n</code></pre>\n<h2 id=\"complexities\">Complexities <a class=\"heading-anchor-permalink\" href=\"#complexities\">#</a></h2>\n<h3 id=\"time-complexity\">Time Complexity <a class=\"heading-anchor-permalink\" href=\"#time-complexity\">#</a></h3>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">Access</th>\n<th style=\"text-align:center\">Search</th>\n<th style=\"text-align:center\">Insertion</th>\n<th style=\"text-align:center\">Deletion</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">O(n)</td>\n<td style=\"text-align:center\">O(n)</td>\n<td style=\"text-align:center\">O(1)</td>\n<td style=\"text-align:center\">O(1)</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"space-complexity\">Space Complexity <a class=\"heading-anchor-permalink\" href=\"#space-complexity\">#</a></h3>\n<p>O(n)</p>\n<h2 id=\"references\">References <a class=\"heading-anchor-permalink\" href=\"#references\">#</a></h2>\n<ul>\n<li><a href=\"https://en.wikipedia.org/wiki/Linked_list\">Wikipedia</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=njTh_OwMljA&amp;index=2&amp;t=1s&amp;list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8\">YouTube</a></li>\n</ul>\n",
      "id": 22
    },
    {
      "path": "lists/4-queue.md",
      "url": "lists/4-queue.html",
      "content": "# Queue\r\n\r\n_Read this in other languages:_\r\n[_简体中文_](README.zh-CN.md),\r\n[_Русский_](README.ru-RU.md)\r\n\r\nIn computer science, a **queue** is a particular kind of abstract data \r\ntype or collection in which the entities in the collection are \r\nkept in order and the principle (or only) operations on the \r\ncollection are the addition of entities to the rear terminal \r\nposition, known as enqueue, and removal of entities from the \r\nfront terminal position, known as dequeue. This makes the queue \r\na First-In-First-Out (FIFO) data structure. In a FIFO data \r\nstructure, the first element added to the queue will be the \r\nfirst one to be removed. This is equivalent to the requirement \r\nthat once a new element is added, all elements that were added \r\nbefore have to be removed before the new element can be removed. \r\nOften a peek or front operation is also entered, returning the \r\nvalue of the front element without dequeuing it. A queue is an \r\nexample of a linear data structure, or more abstractly a \r\nsequential collection.\r\n\r\nRepresentation of a FIFO (first in, first out) queue\r\n\r\n![Queue](https://upload.wikimedia.org/wikipedia/commons/5/52/Data_Queue.svg)\r\n\r\n## Javascript\r\n\r\n```javascript\r\nconst queue = [];\r\n\r\n//put value on end of queue\r\nqueue.push(1);\r\n\r\n//Take first value from queue\r\nconst value = queue.shift();\r\n```\r\n\r\n## References\r\n\r\n- [Wikipedia](https://en.wikipedia.org/wiki/Queue_(abstract_data_type))\r\n- [YouTube](https://www.youtube.com/watch?v=wjI1WNcIntg&list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8&index=3&)\r\n",
      "html": "<h1 id=\"queue\">Queue <a class=\"heading-anchor-permalink\" href=\"#queue\">#</a></h1>\n<p><em>Read this in other languages:</em>\n<a href=\"README.zh-CN.html\"><em>简体中文</em></a>,\n<a href=\"README.ru-RU.html\"><em>Русский</em></a></p>\n<p>In computer science, a <strong>queue</strong> is a particular kind of abstract data\ntype or collection in which the entities in the collection are\nkept in order and the principle (or only) operations on the\ncollection are the addition of entities to the rear terminal\nposition, known as enqueue, and removal of entities from the\nfront terminal position, known as dequeue. This makes the queue\na First-In-First-Out (FIFO) data structure. In a FIFO data\nstructure, the first element added to the queue will be the\nfirst one to be removed. This is equivalent to the requirement\nthat once a new element is added, all elements that were added\nbefore have to be removed before the new element can be removed.\nOften a peek or front operation is also entered, returning the\nvalue of the front element without dequeuing it. A queue is an\nexample of a linear data structure, or more abstractly a\nsequential collection.</p>\n<p>Representation of a FIFO (first in, first out) queue</p>\n<p><img src=\"https://upload.wikimedia.org/wikipedia/commons/5/52/Data_Queue.svg\" alt=\"Queue\"></p>\n<h2 id=\"javascript\">Javascript <a class=\"heading-anchor-permalink\" href=\"#javascript\">#</a></h2>\n<pre><code class=\"language-javascript\">const queue = [];\n\n//put value on end of queue\nqueue.push(1);\n\n//Take first value from queue\nconst value = queue.shift();\n</code></pre>\n<h2 id=\"references\">References <a class=\"heading-anchor-permalink\" href=\"#references\">#</a></h2>\n<ul>\n<li><a href=\"https://en.wikipedia.org/wiki/Queue_(abstract_data_type)\">Wikipedia</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=wjI1WNcIntg&amp;list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8&amp;index=3&amp;\">YouTube</a></li>\n</ul>\n",
      "id": 23
    },
    {
      "path": "lists/5-stack.md",
      "url": "lists/5-stack.html",
      "content": "# Stack\r\n\r\nIn computer science, a stack is an abstract data type that serves as a collection of elements, with two main principal operations:\r\n\r\n- Push, which adds an element to the collection, and\r\n- Pop, which removes the most recently added element that was not yet removed.\r\n\r\nThe order in which elements come off a stack gives rise to its alternative name, LIFO (last in, first out). Additionally, a peek operation may give access to the top without modifying the stack.[1] The name \"stack\" for this type of structure comes from the analogy to a set of physical items stacked on top of each other. This structure makes it easy to take an item off the top of the stack, while getting to an item deeper in the stack may require taking off multiple other items first.[2]\r\n\r\nConsidered as a linear data structure, or more abstractly a sequential collection, the push and pop operations occur only at one end of the structure, referred to as the top of the stack. This data structure makes it possible to implement a stack as a singly linked list and a pointer to the top element. A stack may be implemented to have a bounded capacity. If the stack is full and does not contain enough space to accept an entity to be pushed, the stack is then considered to be in an overflow state. The pop operation removes an item from the top of the stack.\r\n\r\n## Javascript\r\n\r\n```javascript\r\nconst stack = [];\r\n\r\n//put value on top of stack\r\nstack.push(1);\r\n\r\n//remove value from top of stack\r\nconst value = stack.pop();\r\n```\r\n",
      "html": "<h1 id=\"stack\">Stack <a class=\"heading-anchor-permalink\" href=\"#stack\">#</a></h1>\n<p>In computer science, a stack is an abstract data type that serves as a collection of elements, with two main principal operations:</p>\n<ul>\n<li>Push, which adds an element to the collection, and</li>\n<li>Pop, which removes the most recently added element that was not yet removed.</li>\n</ul>\n<p>The order in which elements come off a stack gives rise to its alternative name, LIFO (last in, first out). Additionally, a peek operation may give access to the top without modifying the stack.[1] The name “stack” for this type of structure comes from the analogy to a set of physical items stacked on top of each other. This structure makes it easy to take an item off the top of the stack, while getting to an item deeper in the stack may require taking off multiple other items first.[2]</p>\n<p>Considered as a linear data structure, or more abstractly a sequential collection, the push and pop operations occur only at one end of the structure, referred to as the top of the stack. This data structure makes it possible to implement a stack as a singly linked list and a pointer to the top element. A stack may be implemented to have a bounded capacity. If the stack is full and does not contain enough space to accept an entity to be pushed, the stack is then considered to be in an overflow state. The pop operation removes an item from the top of the stack.</p>\n<h2 id=\"javascript\">Javascript <a class=\"heading-anchor-permalink\" href=\"#javascript\">#</a></h2>\n<pre><code class=\"language-javascript\">const stack = [];\n\n//put value on top of stack\nstack.push(1);\n\n//remove value from top of stack\nconst value = stack.pop();\n</code></pre>\n",
      "id": 24
    },
    {
      "path": "maths/big-o-notation.md",
      "url": "maths/big-o-notation.html",
      "content": "# Big O notation \r\n\r\n## Time complexities\r\n\r\n### O(1)\r\n\r\nConstant time. Never changes in respect to # of inputs.\r\n\r\n### O(log n)\r\n\r\nLogarithmic time. Highly efficient, as the ratio of the number of operations to the size of the input decreases and tends to zero when _n_ increases.\r\n\r\n### O(n)\r\n\r\nLinear time. Scales linearly with # of inputs.\r\n\r\n### O(n²)\r\n\r\nQuadratic time. Highly inefficient as _n_ grows.\r\n\r\n### O(2ⁿ)\r\n\r\nExponential time. Crazy inefficient as _n_ scales up.\r\n\r\n### O(n!)\r\n\r\nFactorial time. Hilariously inefficient.\r\n\r\n## Space complexities\r\n\r\nSpace complexity is the amount of memory used by the algorithm (including the input values to the algorithm) to execute and produce the result.\r\n\r\nOR\r\n\r\nSpace complexity is a measure of the amount of working storage an algorithm needs. That means how much memory, in the worst case, is needed at any point in the algorithm. As with time complexity, we're mostly concerned with how the space needs grow, in big-Oh terms, as the size N of the input problem grows.\r\n\r\n## Tables\r\n\r\n![Big O chart](./big-o-chart.png \"Big O\")\r\n\r\n![Big O chart](./1-data-structs.jpg \"Big O\")\r\n\r\n![Big O chart](./2-searching.jpg \"Big O\")\r\n\r\n![Big O chart](./3-sorting.jpg \"Big O\")\r\n\r\n![Big O chart](./4-heaps.jpg \"Big O\")\r\n\r\n![Big O chart](./5-graphs.jpg \"Big O\")\r\n\r\n![Big O cheatsheet](./big-o-cheatsheet-2.png \"Big O\")\r\n\r\n## Resources\r\n\r\n- [Wikipedia - Computational complexity](https://en.wikipedia.org/wiki/Computational_complexity)\r\n- [Wikipedia - Time complexity](https://en.wikipedia.org/wiki/Time_complexity)\r\n- [Big-O Cheat Sheet](http://bigocheatsheet.com/)\r\n- [Getting Sorted & Big O Notation - Computerphile](https://youtu.be/kgBjXUE_Nwc?t=452)\r\n- [Big O Notation - Gayle Laakmann McDowell](https://www.youtube.com/watch?v=v4cd1O4zkGw)\r\n- [Big O Notations - Derek Banas](https://www.youtube.com/watch?v=V6mKVRU1evU)\r\n- [Northwestern University - Space Complexity EECS 311](https://www.cs.northwestern.edu/academics/courses/311/html/space-complexity.html)\r\n",
      "html": "<h1 id=\"big-o-notation\">Big O notation <a class=\"heading-anchor-permalink\" href=\"#big-o-notation\">#</a></h1>\n<h2 id=\"time-complexities\">Time complexities <a class=\"heading-anchor-permalink\" href=\"#time-complexities\">#</a></h2>\n<h3 id=\"o(1)\">O(1) <a class=\"heading-anchor-permalink\" href=\"#o(1)\">#</a></h3>\n<p>Constant time. Never changes in respect to # of inputs.</p>\n<h3 id=\"o(log-n)\">O(log n) <a class=\"heading-anchor-permalink\" href=\"#o(log-n)\">#</a></h3>\n<p>Logarithmic time. Highly efficient, as the ratio of the number of operations to the size of the input decreases and tends to zero when <em>n</em> increases.</p>\n<h3 id=\"o(n)\">O(n) <a class=\"heading-anchor-permalink\" href=\"#o(n)\">#</a></h3>\n<p>Linear time. Scales linearly with # of inputs.</p>\n<h3 id=\"o(n%C2%B2)\">O(n²) <a class=\"heading-anchor-permalink\" href=\"#o(n%C2%B2)\">#</a></h3>\n<p>Quadratic time. Highly inefficient as <em>n</em> grows.</p>\n<h3 id=\"o(2%E2%81%BF)\">O(2ⁿ) <a class=\"heading-anchor-permalink\" href=\"#o(2%E2%81%BF)\">#</a></h3>\n<p>Exponential time. Crazy inefficient as <em>n</em> scales up.</p>\n<h3 id=\"o(n!)\">O(n!) <a class=\"heading-anchor-permalink\" href=\"#o(n!)\">#</a></h3>\n<p>Factorial time. Hilariously inefficient.</p>\n<h2 id=\"space-complexities\">Space complexities <a class=\"heading-anchor-permalink\" href=\"#space-complexities\">#</a></h2>\n<p>Space complexity is the amount of memory used by the algorithm (including the input values to the algorithm) to execute and produce the result.</p>\n<p>OR</p>\n<p>Space complexity is a measure of the amount of working storage an algorithm needs. That means how much memory, in the worst case, is needed at any point in the algorithm. As with time complexity, we’re mostly concerned with how the space needs grow, in big-Oh terms, as the size N of the input problem grows.</p>\n<h2 id=\"tables\">Tables <a class=\"heading-anchor-permalink\" href=\"#tables\">#</a></h2>\n<p><img src=\"./big-o-chart.png\" alt=\"Big O chart\" title=\"Big O\"></p>\n<p><img src=\"./1-data-structs.jpg\" alt=\"Big O chart\" title=\"Big O\"></p>\n<p><img src=\"./2-searching.jpg\" alt=\"Big O chart\" title=\"Big O\"></p>\n<p><img src=\"./3-sorting.jpg\" alt=\"Big O chart\" title=\"Big O\"></p>\n<p><img src=\"./4-heaps.jpg\" alt=\"Big O chart\" title=\"Big O\"></p>\n<p><img src=\"./5-graphs.jpg\" alt=\"Big O chart\" title=\"Big O\"></p>\n<p><img src=\"./big-o-cheatsheet-2.png\" alt=\"Big O cheatsheet\" title=\"Big O\"></p>\n<h2 id=\"resources\">Resources <a class=\"heading-anchor-permalink\" href=\"#resources\">#</a></h2>\n<ul>\n<li><a href=\"https://en.wikipedia.org/wiki/Computational_complexity\">Wikipedia - Computational complexity</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/Time_complexity\">Wikipedia - Time complexity</a></li>\n<li><a href=\"http://bigocheatsheet.com/\">Big-O Cheat Sheet</a></li>\n<li><a href=\"https://youtu.be/kgBjXUE_Nwc?t=452\">Getting Sorted &amp; Big O Notation - Computerphile</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=v4cd1O4zkGw\">Big O Notation - Gayle Laakmann McDowell</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=V6mKVRU1evU\">Big O Notations - Derek Banas</a></li>\n<li><a href=\"https://www.cs.northwestern.edu/academics/courses/311/html/space-complexity.html\">Northwestern University - Space Complexity EECS 311</a></li>\n</ul>\n",
      "id": 25
    },
    {
      "path": "sets-and-maps/2-hash-map.md",
      "url": "sets-and-maps/2-hash-map.html",
      "content": "# Hash Table\r\n\r\nIn computing, a **hash table** (hash map) is a data \r\nstructure which implements an *associative array* \r\nabstract data type, a structure that can *map keys \r\nto values*. A hash table uses a *hash function* to \r\ncompute an index into an array of buckets or slots, \r\nfrom which the desired value can be found\r\n\r\nIdeally, the hash function will assign each key to a \r\nunique bucket, but most hash table designs employ an \r\nimperfect hash function, which might cause hash \r\ncollisions where the hash function generates the same\r\nindex for more than one key. Such collisions must be\r\naccommodated in some way.\r\n\r\n![Hash Table](https://upload.wikimedia.org/wikipedia/commons/7/7d/Hash_table_3_1_1_0_1_0_0_SP.svg)\r\n\r\nHash collision resolved by separate chaining.\r\n\r\n![Hash Collision](https://upload.wikimedia.org/wikipedia/commons/d/d0/Hash_table_5_0_1_1_1_1_1_LL.svg)\r\n\r\n## Javascript\r\n\r\n```javascript\r\nconst map1 = new Map();\r\n\r\nmap1.set('a', 1);\r\nmap1.set('b', 2);\r\nmap1.set('c', 3);\r\n\r\nconsole.log(map1.get('a'));\r\n// expected output: 1\r\n\r\nmap1.set('a', 97);\r\n\r\nconsole.log(map1.get('a'));\r\n// expected output: 97\r\n\r\nconsole.log(map1.size);\r\n// expected output: 3\r\n\r\nmap1.delete('b');\r\n\r\nconsole.log(map1.size);\r\n// expected output: 2\r\n```\r\n\r\n## References\r\n\r\n- [Wikipedia](https://en.wikipedia.org/wiki/Hash_table)\r\n- [YouTube](https://www.youtube.com/watch?v=shs0KM3wKv8&index=4&list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8)\r\n",
      "html": "<h1 id=\"hash-table\">Hash Table <a class=\"heading-anchor-permalink\" href=\"#hash-table\">#</a></h1>\n<p>In computing, a <strong>hash table</strong> (hash map) is a data\nstructure which implements an <em>associative array</em>\nabstract data type, a structure that can <em>map keys\nto values</em>. A hash table uses a <em>hash function</em> to\ncompute an index into an array of buckets or slots,\nfrom which the desired value can be found</p>\n<p>Ideally, the hash function will assign each key to a\nunique bucket, but most hash table designs employ an\nimperfect hash function, which might cause hash\ncollisions where the hash function generates the same\nindex for more than one key. Such collisions must be\naccommodated in some way.</p>\n<p><img src=\"https://upload.wikimedia.org/wikipedia/commons/7/7d/Hash_table_3_1_1_0_1_0_0_SP.svg\" alt=\"Hash Table\"></p>\n<p>Hash collision resolved by separate chaining.</p>\n<p><img src=\"https://upload.wikimedia.org/wikipedia/commons/d/d0/Hash_table_5_0_1_1_1_1_1_LL.svg\" alt=\"Hash Collision\"></p>\n<h2 id=\"javascript\">Javascript <a class=\"heading-anchor-permalink\" href=\"#javascript\">#</a></h2>\n<pre><code class=\"language-javascript\">const map1 = new Map();\n\nmap1.set('a', 1);\nmap1.set('b', 2);\nmap1.set('c', 3);\n\nconsole.log(map1.get('a'));\n// expected output: 1\n\nmap1.set('a', 97);\n\nconsole.log(map1.get('a'));\n// expected output: 97\n\nconsole.log(map1.size);\n// expected output: 3\n\nmap1.delete('b');\n\nconsole.log(map1.size);\n// expected output: 2\n</code></pre>\n<h2 id=\"references\">References <a class=\"heading-anchor-permalink\" href=\"#references\">#</a></h2>\n<ul>\n<li><a href=\"https://en.wikipedia.org/wiki/Hash_table\">Wikipedia</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=shs0KM3wKv8&amp;index=4&amp;list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8\">YouTube</a></li>\n</ul>\n",
      "id": 26
    },
    {
      "path": "sets-and-maps/3-heap.md",
      "url": "sets-and-maps/3-heap.html",
      "content": "# Heap (data-structure)\r\n\r\nIn computer science, a **heap** is a specialized tree-based \r\ndata structure that satisfies the heap property described\r\nbelow.\r\n\r\nIn a *min heap*, if `P` is a parent node of `C`, then the\r\nkey (the value) of `P` is less than or equal to the\r\nkey of `C`.\r\n\r\n![MinHeap](https://upload.wikimedia.org/wikipedia/commons/6/69/Min-heap.png)\r\n\r\nIn a *max heap*, the key of `P` is greater than or equal\r\nto the key of `C`\r\n\r\n![Heap](https://upload.wikimedia.org/wikipedia/commons/3/38/Max-Heap.svg)\r\n\r\nThe node at the \"top\" of the heap with no parents is \r\ncalled the root node.\r\n\r\n## Javascript\r\n\r\n```javascript\r\nclass MaxHeap{\r\n    constructor(){\r\n        this.heap = [];\r\n    }\r\n\r\n    parentIndex(index){\r\n        return Math.floor((index-1)/2);\r\n    }\r\n\r\n    leftChildIndex(index){\r\n        return (2*index + 1);\r\n    }\r\n\r\n    rightChildIndex(index){\r\n        return (2*index + 2);\r\n    }\r\n\r\n    swap(a, b) {\r\n        let temp = this.heap[a];\r\n        this.heap[a] = this.heap[b];\r\n        this.heap[b] = temp;\r\n    }\r\n\r\n    insert(item) {\r\n        this.heap.push(item);\r\n        var index = this.heap.length - 1;\r\n        var parent = this.parentIndex(index);\r\n        while(this.heap[parent] && this.heap[parent] < this.heap[index]) {\r\n            this.swap(parent, index);\r\n            index = this.parentIndex(index);\r\n            parent = this.parentIndex(index);\r\n        }\r\n    }\r\n\r\n    delete() {\r\n      var item = this.heap.shift();\r\n      this.heap.unshift(this.heap.pop());\r\n      var index = 0;\r\n      var leftChild = this.leftChildIndex(index);\r\n      var rightChild = this.rightChildIndex(index);\r\n      while(this.heap[leftChild] && this.heap[leftChild] > this.heap[index] || this.heap[rightChild] > this.heap[index]){\r\n          var max = leftChild;\r\n          if(this.heap[rightChild] && this.heap[rightChild] > this.heap[max]){\r\n              max = rightChild\r\n          }\r\n          this.swap(max, index);\r\n          index = max;\r\n          leftChild = this.leftChildIndex(max);\r\n          rightChild = this.rightChildIndex(max);\r\n      }\r\n      return item;\r\n  }\r\n}\r\n```\r\n\r\n## References\r\n\r\n- [Wikipedia](https://en.wikipedia.org/wiki/Heap_(data_structure))\r\n- [YouTube](https://www.youtube.com/watch?v=t0Cq6tVNRBA&index=5&t=0s&list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8)\r\n",
      "html": "<h1 id=\"heap-(data-structure)\">Heap (data-structure) <a class=\"heading-anchor-permalink\" href=\"#heap-(data-structure)\">#</a></h1>\n<p>In computer science, a <strong>heap</strong> is a specialized tree-based\ndata structure that satisfies the heap property described\nbelow.</p>\n<p>In a <em>min heap</em>, if <code>P</code> is a parent node of <code>C</code>, then the\nkey (the value) of <code>P</code> is less than or equal to the\nkey of <code>C</code>.</p>\n<p><img src=\"https://upload.wikimedia.org/wikipedia/commons/6/69/Min-heap.png\" alt=\"MinHeap\"></p>\n<p>In a <em>max heap</em>, the key of <code>P</code> is greater than or equal\nto the key of <code>C</code></p>\n<p><img src=\"https://upload.wikimedia.org/wikipedia/commons/3/38/Max-Heap.svg\" alt=\"Heap\"></p>\n<p>The node at the “top” of the heap with no parents is\ncalled the root node.</p>\n<h2 id=\"javascript\">Javascript <a class=\"heading-anchor-permalink\" href=\"#javascript\">#</a></h2>\n<pre><code class=\"language-javascript\">class MaxHeap{\n    constructor(){\n        this.heap = [];\n    }\n\n    parentIndex(index){\n        return Math.floor((index-1)/2);\n    }\n\n    leftChildIndex(index){\n        return (2*index + 1);\n    }\n\n    rightChildIndex(index){\n        return (2*index + 2);\n    }\n\n    swap(a, b) {\n        let temp = this.heap[a];\n        this.heap[a] = this.heap[b];\n        this.heap[b] = temp;\n    }\n\n    insert(item) {\n        this.heap.push(item);\n        var index = this.heap.length - 1;\n        var parent = this.parentIndex(index);\n        while(this.heap[parent] &amp;&amp; this.heap[parent] &lt; this.heap[index]) {\n            this.swap(parent, index);\n            index = this.parentIndex(index);\n            parent = this.parentIndex(index);\n        }\n    }\n\n    delete() {\n      var item = this.heap.shift();\n      this.heap.unshift(this.heap.pop());\n      var index = 0;\n      var leftChild = this.leftChildIndex(index);\n      var rightChild = this.rightChildIndex(index);\n      while(this.heap[leftChild] &amp;&amp; this.heap[leftChild] &gt; this.heap[index] || this.heap[rightChild] &gt; this.heap[index]){\n          var max = leftChild;\n          if(this.heap[rightChild] &amp;&amp; this.heap[rightChild] &gt; this.heap[max]){\n              max = rightChild\n          }\n          this.swap(max, index);\n          index = max;\n          leftChild = this.leftChildIndex(max);\n          rightChild = this.rightChildIndex(max);\n      }\n      return item;\n  }\n}\n</code></pre>\n<h2 id=\"references\">References <a class=\"heading-anchor-permalink\" href=\"#references\">#</a></h2>\n<ul>\n<li><a href=\"https://en.wikipedia.org/wiki/Heap_(data_structure)\">Wikipedia</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=t0Cq6tVNRBA&amp;index=5&amp;t=0s&amp;list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8\">YouTube</a></li>\n</ul>\n",
      "id": 27
    }
  ]
}